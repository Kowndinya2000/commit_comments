    replaced trunk with code from beta5 branch
    Update README.md
    Update README.md
    Update README.md
    Update README.md
    Update README.md
    Update and rename README.txt to README.md
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Bugfix: Omitted including main Makefile with request to build BootDemo.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Added SD Card - SPI RAM interfacing demo.
    Add bin2hex and midiconv to the main Makefile
    
    I've completed testing on Linux, OS X, and Windows using MinGW 2013-10-04, and
    everything builds without problems using a standard out-of-the-box setup. The
    only requirement is a somewhat recent version of GCC (with decent C++11 support).
    
    Really old versions of MinGW that use GCC 4.8.1 are known to not work.
    Added Mode13ExtendedDemo to the main build script.
    Added MegaSokoban to the main build script.
    Fixed Game of Life to compile properly, adding it to the main build script.
    Fixed Zombienator to compile properly, adding it to the main build script.
    -added Loderunner to global makefile
    Fixed makefile to create bin and roms folders.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Fix Mode5Demo's makefile and add it to the big one.
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    fixing build on GNU/Linux
    Modified Mode9demo project to support global Makefile
    -updated demos makefiles
    -modified global Makefile to create .hex and .uze files to /roms folder
    -added Tutorial project to global Makefile
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Second part of the DEST_DIR flag.
    Using -j (build in parallel) may break the builds. This happens when a demo needs packrom before him being built (fixed)
    Enabled Demos bootloader and Bootloader_pragma
    Removed binary files from Bootloader_pragma
    Added flag DEST_DIR when building tools. The second step is implement this support in the tools and stop just copying using the directory name.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Fixed font issue due to references to RAM_TILES_COUNT
    Fix megatris build on gcc 4.6.2, fix chess4uzebox, Mode5Demo and Atomix build on Linux (match case and avr-size flags).
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Raised ramtiles count in Arkanoid to avoid flicker
    -Fixed font issue due to references to RAM_TILES_COUNT
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Changed project's name in the comment.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    MegaSokoban function declarations fixed, used "inline" incorrectly, resulting
    in possible failure to compile it.
    fix default data in eeprom
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    -Fixed mode 10 timing
    -Standardized MegaSokoban makefile
    added game MegaSokoban and video mode 10
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    added game MegaSokoban and video mode 10
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    replaced trunk with code from beta5 branch
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Fixed issue with MIDI IN.
    gcode issue 16: added missing files to supermariodemo project, fixed makefile in musicdemo.
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Video Mode 2 sprites structure bugfix: The structure had multiple declarations
    in the kernel and also in the Zombienator game, and somehow it still compiled
    until now, gcc 10.1.0 known to fail with it.
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    -restore SpriteDemo
    -Added Zombienator project
    replaced trunk with code from beta5 branch
    Fixed Zombienator to compile properly, adding it to the main build script.
    -restore SpriteDemo
    -Added Zombienator project
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Added missing palette file
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Added missing palette file
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Updated vector demo project
    Fixed Game of Life to compile properly, adding it to the main build script.
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Updated vector demo project
    Initial import.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Bugfix: Improper allocations in Game of Life (.byte in .bss section).
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Fixed Game of Life to compile properly, adding it to the main build script.
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    replaced trunk with code from beta5 branch
    Fixed gconvert path in GameOfLife's makefile.
    
    This prevented the project to build if make determined the .inc files
    needed updating (since they are included in the git repo, this may or
    may not happen on a fresh clone).
    Fixed Game of Life to compile properly, adding it to the main build script.
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Initial import.
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    replaced trunk with code from beta5 branch
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Added Uze8 (Chip8 Emulator) demo project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    work on timers
    work
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    work
    -Added PORTIOs to uzebox linkscript
    work on timers
    work
    work
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    work on timers
    work
    temp
    work on timing
    -Fixed project to work with latest updated to mode 3 with scrolling
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    work
    work
    work on timers
    work
    work
    work
    work
    work
    Added Flavio Zavan's ControllerTester to the main distro
    work
    work
    work
    work
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    -Mode 9: Added feature to set background color for each character line
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    replaced trunk with code from beta5 branch
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    Modified Mode9demo project to support global Makefile
    replaced trunk with code from beta5 branch
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    Added video mode 9 demo project
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    Added video mode 9 demo project
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added codetile font for 80x25 text mode
    -Created video mode 13
    -Created video mode 13
    Added video mode 9 demo project
    -Created video mode 13
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    Initial import.
    Added video mode 9 demo project
    replaced trunk with code from beta5 branch
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Added demo for video mode 5
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added demo for video mode 5
    Added demo for video mode 5
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Added demo for video mode 5
    Mode5demo makefile: added UZEBIN_DIR ref to gconvert invocation
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Fix megatris build on gcc 4.6.2, fix chess4uzebox, Mode5Demo and Atomix build on Linux (match case and avr-size flags).
    Fix Mode5Demo's makefile and add it to the big one.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added demo for video mode 5
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Added demo for video mode 5
    Added demo for video mode 5
    emuze - initial commit
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added demo for video mode 5
    Added demo for video mode 5
    Initial import.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added demo for video mode 5
    Added demo for video mode 5
    Added video mode 9 demo project
    replaced trunk with code from beta5 branch
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Bootloader SD library FAT32 fix: Forgot to change the conditional
    according with the updated cluster value check.
    Bootloader SD library FAT-32 fix: Clusters were parsed incorrectly,
    preventing most notably the listing of the Root Directory to complete,
    unable to detect the end of it.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Bootloader workaround: Mac OS X generated files no longer show up as junk
    entries in the Game Selector.
    
    This also means that neither valid UZE files beginning with an underscore
    character would show up as by FAT16 filename only this can be used to
    isolate those OS X files. This shouldn't be a problem as there is no known
    game in existence with such a name (it is an extremely unlikely use case).
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Bootloader 5.0.10: A milder "click" sound. (#89)
    
    Changed the "click" sound produced for controller activity (like navigation in the game list) for a milder one.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Bootloader 5.0.10: A milder "click" sound. (#89)
    
    Changed the "click" sound produced for controller activity (like navigation in the game list) for a milder one.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    replaced trunk with code from beta5 branch
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Bootloader SD library FAT-32 fix: Clusters were parsed incorrectly,
    preventing most notably the listing of the Root Directory to complete,
    unable to detect the end of it.
    Bootloader workaround: Mac OS X generated files no longer show up as junk
    entries in the Game Selector.
    
    This also means that neither valid UZE files beginning with an underscore
    character would show up as by FAT16 filename only this can be used to
    isolate those OS X files. This shouldn't be a problem as there is no known
    game in existence with such a name (it is an extremely unlikely use case).
    Bootloader 5.0.10: A milder "click" sound. (#89)
    
    Changed the "click" sound produced for controller activity (like navigation in the game list) for a milder one.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Atomix sources
    Atomix sources
    -Created AVR Studio projects to atomix and chess4uzebox
    Atomix sources
    -Created AVR Studio projects to atomix and chess4uzebox
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Fix megatris build on gcc 4.6.2, fix chess4uzebox, Mode5Demo and Atomix build on Linux (match case and avr-size flags).
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Atomix sources
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Fix megatris build on gcc 4.6.2, fix chess4uzebox, Mode5Demo and Atomix build on Linux (match case and avr-size flags).
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Atomix sources
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    Added the sdSimple library to the kernel and a simple demo to show its usage
    -Updated vector demo project
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    changed names of sdSimple to sdBase
    First commit of Tornado 2000
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Added the sdSimple library to the kernel and a simple demo to show its usage
    -Updated vector demo project
    Initial import.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Added the sdSimple library to the kernel and a simple demo to show its usage
    changed names of sdSimple to sdBase
    Added the sdSimple library to the kernel and a simple demo to show its usage
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Added the sdSimple library to the kernel and a simple demo to show its usage
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    replaced trunk with code from beta5 branch
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    replaced trunk with code from beta5 branch
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Updated Megatris makefile
    -updated demos makefiles
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Fixed screen centering
    -added missing asmFunctions.s
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    Ported unittest to the current kernel. It uses gconvert and compiles, but might be broken somewhere.
    Added missing palette file
    work on timing
    -Fixed project to work with latest updated to mode 3 with scrolling
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Merged uzem-140
    temp
    Fixed garbage in overlay.
    -Fixed project to work with latest updated to mode 3 with scrolling
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Fixed master volume that was too loud
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    work on timing
    -Fixed project to work with latest updated to mode 3 with scrolling
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Merged uzem-140
    temp
    work on timing
    -Fixed project to work with latest updated to mode 3 with scrolling
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    gcode issue 16: added missing files to supermariodemo project, fixed makefile in musicdemo.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Fixed project to work with latest updated to mode 3 with scrolling
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    gcode issue 16: added missing files to supermariodemo project, fixed makefile in musicdemo.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Bugfix: Issue #82 , along with revising the init of all ports. (#83)
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -mmc.s: Added wait states to support more SD cards brands
    -Updated controller reading code to support Asciipad
    bugfix: Activate internal pullup on joypad data lines. This avoids issues when no joypad is connected.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    -Changes for 0.4.2: misc cleanup
    Align the title.
    Show the correct author if page number > 1
    Version 0.4:
    -fixed LED bug
    -bootloader boot mode can now be set in menu
    -clip files >61440 to avoid overwriting the bootloader
    -Removed old Bootloader_Pragma project
    Added GPL text.
    Updated bootloader to support up to 128 games.
    replaced trunk with code from beta5 branch
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    replaced trunk with code from beta5 branch
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -Updated controller reading code to support Asciipad
    -Changes for 0.4.2: misc cleanup
    Version 0.4:
    -fixed LED bug
    -bootloader boot mode can now be set in menu
    -clip files >61440 to avoid overwriting the bootloader
    -Removed old Bootloader_Pragma project
    Updated bootloader to support up to 128 games.
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -Updated controller reading code to support Asciipad
    bugfix: Activate internal pullup on joypad data lines. This avoids issues when no joypad is connected.
    Version 0.4:
    -fixed LED bug
    -bootloader boot mode can now be set in menu
    -clip files >61440 to avoid overwriting the bootloader
    -Removed old Bootloader_Pragma project
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    replaced trunk with code from beta5 branch
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    replaced trunk with code from beta5 branch
    Bugfix: Issue #82 , along with revising the init of all ports. (#83)
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -Updated controller reading code to support Asciipad
    bugfix: Activate internal pullup on joypad data lines. This avoids issues when no joypad is connected.
    Version 0.4:
    -fixed LED bug
    -bootloader boot mode can now be set in menu
    -clip files >61440 to avoid overwriting the bootloader
    -Removed old Bootloader_Pragma project
    Updated bootloader to support up to 128 games.
    replaced trunk with code from beta5 branch
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    -Changes for 0.4.2: misc cleanup
    Version 0.4:
    -fixed LED bug
    -bootloader boot mode can now be set in menu
    -clip files >61440 to avoid overwriting the bootloader
    -Removed old Bootloader_Pragma project
    fixing build on GNU/Linux
    Updated bootloader to support up to 128 games.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    consistant function names
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    consistant function names
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    replaced trunk with code from beta5 branch
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    consistant function names
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    replaced trunk with code from beta5 branch
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    fixing build on GNU/Linux
    replaced trunk with code from beta5 branch
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    Added Flavio Zavan's ControllerTester to the main distro
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    SD reading demo with BLIT to RAM shown
    Added demo for video mode 5
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    replaced trunk with code from beta5 branch
    chess4uzebox sources
    -Created AVR Studio projects to atomix and chess4uzebox
    -Created AVR Studio projects to atomix and chess4uzebox
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    chess4uzebox sources
    Atomix sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    chess4uzebox sources
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Fix megatris build on gcc 4.6.2, fix chess4uzebox, Mode5Demo and Atomix build on Linux (match case and avr-size flags).
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    chess4uzebox sources
    Atomix sources
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Filename fixes for LodeRunner
    -Linux fix: Added strlwr function to uzem.cpp
    -removed GetUserRamTiles();
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    Initial import.
    -fixed mouse control
    -work on user ram tiles
    -lode runner fix
    Initial import.
    -Filename fixes for LodeRunner
    -Linux fix: Added strlwr function to uzem.cpp
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    Initial import.
    Merged uzem-140
    Added missing palette file
    -Fixed file names in LodeRunner
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    Initial import.
    Merged uzem-140
    Added missing palette file
    -Fixed file names in LodeRunner
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    Initial import.
    -Fixed file names in LodeRunner
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    Initial import.
    Initial import.
    -work on user ram tiles
    -lode runner fix
    Initial import.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Filename fixes for LodeRunner
    -Linux fix: Added strlwr function to uzem.cpp
    -Fixed file names in LodeRunner
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Initial import.
    Added missing palette file
    -Fixed file names in LodeRunner
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    -Implemented user ram tiles
    -Fixed Loderunner
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Initial import.
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Initial import.
    Initial import.
    replaced trunk with code from beta5 branch
    Initial import.
    replaced trunk with code from beta5 branch
    Initial import.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Initial import.
    Initial import.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Initial import.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Initial import.
    Initial import.
    Initial import.
    Initial import.
    Initial import.
    Initial import.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Initial import.
    Initial import.
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Initial import.
    Initial import.
    -restore SpriteDemo
    -Added Zombienator project
    Added missing palette file
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -restore SpriteDemo
    -Added Zombienator project
    Added missing palette file
    cleanup
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Fix for Issue #77
    
    Shortened the beat pcm sample so the rom fit under 61440 bytes.
    See: https://github.com/Uzebox/uzebox/issues/77
    Fix for Issue #77
    
    Shortened the beat pcm sample so the rom fit under 61440 bytes.
    See: https://github.com/Uzebox/uzebox/issues/77
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    SPI RAM library: The init routine now does a check for SPI RAM presence. (#86)
    
    The init routine now checks SPI RAM presence by a short addressing test (writing, then reading back values from relatively random addresses).
    
    The example using this library is updated and will report if the SPI RAM is not detected.
    Added SD Card - SPI RAM interfacing demo.
    Added SD Card - SPI RAM interfacing demo.
    Added SD Card - SPI RAM interfacing demo.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Added SD Card - SPI RAM interfacing demo.
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    Added SD Card - SPI RAM interfacing demo.
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added SD Card - SPI RAM interfacing demo.
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Add files via upload
    Add files via upload
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Add files via upload
    changed names of sdSimple to sdBase
    Added the sdSimple library to the kernel and a simple demo to show its usage
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Add files via upload
    Added the sdSimple library to the kernel and a simple demo to show its usage
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Add files via upload
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Add files via upload
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    Added keyboard firmware project
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    Added keyboard firmware project
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    Added a keyboard demo to KeyboardFirmware project
    replaced trunk with code from beta5 branch
    Added keyboard firmware project
    Added a keyboard demo to KeyboardFirmware project
    Added keyboard firmware project
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    -Created video mode 13
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    -Updated Keyboard demo project to use mode 9/80 columns
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added codetile font for 80x25 text mode
    -Created video mode 13
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    -Updated Keyboard demo project to use mode 9/80 columns
    Added a keyboard demo to KeyboardFirmware project
    -Improved tutorial project to support multiple video modes/font sizes: added missing .inc files.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Bootloader API library added with a demo. (#87)
    
    This API library enables using SDHC cards and FAT32 filesystems with
    fragmentation through the V.5.x.x bootloader if it is available (otherwise
    reverting to an MMC and FAT16 implementation).
    
    The demo shows off the basic features of this library, also doubling as an
    useful program for querying SD cards.
    Bootloader API library added with a demo. (#87)
    
    This API library enables using SDHC cards and FAT32 filesystems with
    fragmentation through the V.5.x.x bootloader if it is available (otherwise
    reverting to an MMC and FAT16 implementation).
    
    The demo shows off the basic features of this library, also doubling as an
    useful program for querying SD cards.
    Bootloader API library added with a demo. (#87)
    
    This API library enables using SDHC cards and FAT32 filesystems with
    fragmentation through the V.5.x.x bootloader if it is available (otherwise
    reverting to an MMC and FAT16 implementation).
    
    The demo shows off the basic features of this library, also doubling as an
    useful program for querying SD cards.
    Added SD Card - SPI RAM interfacing demo.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    replaced trunk with code from beta5 branch
    Kernel SNES mouse fix: The "mx" and "my" variables probably were
    unintentionally made global. These are now made static (local to the kernel
    source). This revealed when compiling the Whack-a-Mole game failed on recent
    (10.1.0) gcc, due to these having multiple definitions. The game might end up
    being broken with an actual mouse after this patch though since it might have
    been using the kernel variable directly. Still the fix is added to make the
    repository compile on recent compilers.
    replaced trunk with code from beta5 branch
    Desperately trying to patch up that broken Whack-a-Mole game to at least
    compile with a modern gcc.
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    DrMario: Ver 1.1 - Many bug fixes
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    DrMario: Ver 1.1 - Many bug fixes
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    DrMario: Ver 1.1 - Many bug fixes
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    replaced trunk with code from beta5 branch
    DrMario: Ver 1.1 - Many bug fixes (added missing files)
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixed screen centering
    -added missing asmFunctions.s
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Updated Megatris makefile
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Updated Megatris makefile
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Bugfix: GitHub Issue 62 (Megatris options menu).
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    fixed bug that ignored back-to-back
    -Added P1/P2 level selection in option menu
    -Remove scoring code to recover flash memory
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Fixed screen centering
    -added missing asmFunctions.s
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    Updated Megatris makefile
    -updated demos makefiles
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Fixed screen centering
    -added missing asmFunctions.s
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Fixed screen centering
    -added missing asmFunctions.s
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Fix slashes in Megatris' gconvert xml.
    Updated Megatris makefile
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    VectorDemo.c: added const keyword to PROGMEM array
    -Updated vector demo project
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Updated vector demo project
    -Updated vector demo project
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Updated vector demo project
    replaced trunk with code from beta5 branch
    -Updated vector demo project
    Initial import.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Updated vector demo project
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Updated vector demo project
    -Updated vector demo project
    -Updated vector demo project
    -Updated vector demo project
    replaced trunk with code from beta5 branch
    -Updated vector demo project
    Bug fixes and new keys supported
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -fixed mouse control
    -work on user ram tiles
    -lode runner fix
    Initial import.
    Bug fixes and new keys supported
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    added uzebox.net host to server
    -Fixes to connect to Uzenet Chat server
    -Added AtmelStudio 6 project files
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -work on user ram tiles
    -lode runner fix
    Initial import.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    gcode issue 16: added missing files to supermariodemo project, fixed makefile in musicdemo.
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    fixing build on GNU/Linux
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Updated Keyboard demo project to use mode 9/80 columns
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added codetile font for 80x25 text mode
    -Created video mode 13
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Initial import.
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    replaced trunk with code from beta5 branch
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    Initial import.
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    replaced trunk with code from beta5 branch
    Added Flavio Zavan's ControllerTester to the main distro
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Improved SNES mouse timing to support WII nunchuck interface.
    -Updated controller tester mouse support
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    replaced trunk with code from beta5 branch
    Added Flavio Zavan's ControllerTester to the main distro
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Apply the patch for issue 11. It fixes building withouth having packrom and gconvert in your $PATH.
    Added Flavio Zavan's ControllerTester to the main distro
    Modified Mode9demo project to support global Makefile
    Added video mode 9 demo project
    -updated demos makefiles
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    Added Flavio Zavan's ControllerTester to the main distro
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added Flavio Zavan's ControllerTester to the main distro
    Fix building on Linux, remove bootloader_pragma from Makefile and use relative paths on ControllerTester's xmls.
    Added Flavio Zavan's ControllerTester to the main distro
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Fixed offset bug in SetFont in mode 3
    -Merged SetFont and SetTile in mode 3
    -Removed RAM_TILES_COUNT references in uzeboxVideoEngine.c
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Added read from FLASH directive for the fader[FADER_STEPS] of previous update
    Added PROGMEM directive to unsigned char fader[FADER_STEPS] to recover 12 bytes of RAM
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Fix for bug#7: Fill() issue in mode 3
    replaced trunk with code from beta5 branch
    Bugfix: Missing and incorrect section identifications.
    
    Particularly around the waves table due to this problem unnecessary
    alignments were inserted increasing code size.
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Fixed bug that disabled sound randomly
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Bugfix: Issue #81
    
    The new soft reset routine checks if the watchdog was already started,
    this way it can prevent a periodic reset of the watchdog, achieving the
    soft-reset reliably.
    Replaced WAIT macro to one generating fewer instructions.
    Simple kernel boost (#78)
    
    * KERNELBOOST: 57 cycles gained on HSync entry, giving ~2000 extra VBlank cycles
    
    The modification replaces the jitter elimination part in the HSync and
    VSync entry codes to a more efficient solution.
    
    It is not fully compatible with the original kernel, but mostly works.
    Notably all timing is shifted 57 cycles "down" relative to the timer,
    which normally isn't a problem (expect for timer value related comments).
    However video modes using the timer for terminating their scanlines (such
    as Mode 13) doesn't work with this modification! (their timer related
    logic has to be modified to follow the 57 cycles shift)
    
    * Kernel boost: Added Timer1 terminated video mode compatibility.
    
    A new TIMER1_DISPLACE constant is introduced which can be used in timer
    terminated video modes to make them compatible with different kernels. Its
    use is added to Mode 13, so now it compiles correctly with the kernel
    boost enabled.
    
    * Kernel boost: Cleaning up.
    
    The Vsync generation also became smaller and a little faster.
    
    * Kernel boost: Cleaned up Mode 13's modification.
    
    It now can be used as a general working example for setting up other
    Timer1 terminated video modes.
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixed true random gen initialization to work with bootloader
    cleanup
    stuff to support uzem140 (testing new mode13)
    work in timing
    work on timing
    Uzem 1.3.1:
    -Fixed issue that prevented clean exit at command line under windows.
    -Added feature to capture/playback controller buttons
    -Added support for watchdog to support true random generator
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Created video mode 13
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Added functions to control LED: on,off and toggle
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Improved SNES mouse timing to support WII nunchuck interface.
    -Updated controller tester mouse support
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    -Main program can decided when controllers are read instead of kernel with CONTROLLERS_VSYNC_READ compile switch
    -DetectControllers() can now detect if a joypad or mouse is connected to both ports (note: function is not backward compatible)
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Bugfix: Bootloader interface library FS_Get_Pos() and FS_Set_Pos() fixed.
    
    It was a missing "ret".
    Bootloader interface library: Added SD write capability. (#93)
    
    Two new exposed functions are introduced:
    SDC_Write_Sector() for low-level SD sector writes
    FS_Write_Sector() for filesystem level access
    
    Tested on some SDSC and SDHC cards with real hardware and CUzeBox.
    Bootloader API library added with a demo. (#87)
    
    This API library enables using SDHC cards and FAT32 filesystems with
    fragmentation through the V.5.x.x bootloader if it is available (otherwise
    reverting to an MMC and FAT16 implementation).
    
    The demo shows off the basic features of this library, also doubling as an
    useful program for querying SD cards.
    New bootloader.
    
    Introduced the "new" bootloader (V.5.0.09). This bootloader primarily
    adds support for SDHC cards with FAT32 filesystems along with several
    other new features. The following major features are present:
    
    - SDHC support (supports both SDSC and SDHC cards).
    - FAT32 support.
    - Fragmentation support (files and FAT32 root directory).
    - Up to 255 .UZE files may be listed.
    - Robust programming with error checking and retry if necessary.
    - Hotplug support (you can swap SD cards while being in the bootloader).
    - SD cards with a single .UZE are auto-booted.
    - Flashes based on content difference, somewhat reducing wear.
    - SD card and FAT filesystem API exposed for games.
    - Fully assembler source with no reliance on C compiler optimizations.
    Bugfix: sdBase.S now properly implements SPIF waiting.
    
    The AVR datasheet has to be taken literally for clearing SPIF which may
    not happen if another component (such as the SPI RAM library) doesn't use
    SPIF at all.
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    changed names of sdSimple to sdBase
    Added the sdSimple library to the kernel and a simple demo to show its usage
    consistant function names
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    SPI RAM library: The init routine now does a check for SPI RAM presence. (#86)
    
    The init routine now checks SPI RAM presence by a short addressing test (writing, then reading back values from relatively random addresses).
    
    The example using this library is updated and will report if the SPI RAM is not detected.
    Bugfix: SPI RAM library problems fixed.
    
    A few of the functions didn't work at all. The SPIF flag dependency is
    removed, it is almost useless and it has some ROM cost to set it up. Now
    cycle timed code handles the cases previously handled by it.
    SPI RAM library (#72)
    
    * SPIRAM: Added basic interface functions.
    
    * SPIRAM: Bugfixes (broken jumps on tightly packed sequential access)
    
    * SPIRAM: Optimizations in the sequential readers and writers.
    Bugfix: PCM channel in the inline mixer now works properly.
    
    Nothing significant, it was an accidental use of a wrong register in one
    instruction.
    Reverting the revert to prepare for a proper bugfix.
    
    This reverts commit 3d5f382b854b61796af45efa2a3cc16f6f7df638.
    Revert "Mixer boost (#88)" because it breaks PCM sound effects
    
    This reverts commit ddc078a0bb71f99e41ffec68676b80f58f0ff4a2.
    Mixer boost (#88)
    
    A significantly faster inline mixer based on Flight of a Dragon and CunningFellow's mixer optimizations. It doesn't change anything in the behaviour, the most notable benefit is more CPU time available for user code in VBlank, also in some video modes, it may enable using a more complex inline mixer.
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Merged uzem-140
    -fix for random note stuck
    fix for audio glitch
    stuff to support uzem140 (testing new mode13)
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Added MOD player
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Updated the EepromHeaderStruct to add the bootloaderFlags field.
    -Fixed an alignment bug in the EEPROM's format table.
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    Bootloader interface library: Added SD write capability. (#93)
    
    Two new exposed functions are introduced:
    SDC_Write_Sector() for low-level SD sector writes
    FS_Write_Sector() for filesystem level access
    
    Tested on some SDSC and SDHC cards with real hardware and CUzeBox.
    Bootloader API library added with a demo. (#87)
    
    This API library enables using SDHC cards and FAT32 filesystems with
    fragmentation through the V.5.x.x bootloader if it is available (otherwise
    reverting to an MMC and FAT16 implementation).
    
    The demo shows off the basic features of this library, also doubling as an
    useful program for querying SD cards.
    replaced trunk with code from beta5 branch
    SPI RAM library: The init routine now does a check for SPI RAM presence. (#86)
    
    The init routine now checks SPI RAM presence by a short addressing test (writing, then reading back values from relatively random addresses).
    
    The example using this library is updated and will report if the SPI RAM is not detected.
    SPI RAM library (#72)
    
    * SPIRAM: Added basic interface functions.
    
    * SPIRAM: Bugfixes (broken jumps on tightly packed sequential access)
    
    * SPIRAM: Optimizations in the sequential readers and writers.
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Bugfix: Missing and incorrect section identifications.
    
    Particularly around the waves table due to this problem unnecessary
    alignments were inserted increasing code size.
    -Added IsSongPlaying() function.
    another fix for the hanged sound bug
    fix for stuck note
    -Implemented user ram tiles
    -Fixed Loderunner
    -Final sound fix
    -fix for random note stuck
    fix for audio glitch
    Update uzeboxSoundEngine.c
    
    Changed "tracks" to "track" in PatchCommand11 and 12w.
    -Fixed PCM channel regression when used on chan3(noise channel)
    stuff to support uzem140 (testing new mode13)
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Fixed issue with MIDI IN.
    -Added MOD player
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    -Added missing logo include files
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Kernel SNES mouse fix: The "mx" and "my" variables probably were
    unintentionally made global. These are now made static (local to the kernel
    source). This revealed when compiling the Whack-a-Mole game failed on recent
    (10.1.0) gcc, due to these having multiple definitions. The game might end up
    being broken with an actual mouse after this patch though since it might have
    been using the kernel variable directly. Still the fix is added to make the
    repository compile on recent compilers.
    Kernel: New feature: Stack relocation.
    
    It is now possible to relocate the stack using UZEBOX_STACK_TOP. This is
    primarily meant for video mode design, to allow video modes to reserve
    aligned RAM above the stack.
    Bugfix: Issue #82 , along with revising the init of all ports. (#83)
    Bugfix: Issue #81
    
    The new soft reset routine checks if the watchdog was already started,
    this way it can prevent a periodic reset of the watchdog, achieving the
    soft-reset reliably.
    Simple kernel boost (#78)
    
    * KERNELBOOST: 57 cycles gained on HSync entry, giving ~2000 extra VBlank cycles
    
    The modification replaces the jitter elimination part in the HSync and
    VSync entry codes to a more efficient solution.
    
    It is not fully compatible with the original kernel, but mostly works.
    Notably all timing is shifted 57 cycles "down" relative to the timer,
    which normally isn't a problem (expect for timer value related comments).
    However video modes using the timer for terminating their scanlines (such
    as Mode 13) doesn't work with this modification! (their timer related
    logic has to be modified to follow the 57 cycles shift)
    
    * Kernel boost: Added Timer1 terminated video mode compatibility.
    
    A new TIMER1_DISPLACE constant is introduced which can be used in timer
    terminated video modes to make them compatible with different kernels. Its
    use is added to Mode 13, so now it compiles correctly with the kernel
    boost enabled.
    
    * Kernel boost: Cleaning up.
    
    The Vsync generation also became smaller and a little faster.
    
    * Kernel boost: Cleaned up Mode 13's modification.
    
    It now can be used as a general working example for setting up other
    Timer1 terminated video modes.
    Merged uzem-140
    Add "used" attribute to wdt_init and Initialize
    
    This prevents the compiler/linker from removing the necessary .init7
    and .init8 sections when compiling games that have:
    
    COMMON = -mmcu=$(MCU) -flto -fwhole-program
    
    in their Makefile.
    
    Without the "used" attribute, the linker will remove those sections,
    breaking the game.
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    -fix for random note stuck
    stuff to support uzem140 (testing new mode13)
    work on timing
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Added functions to control LED: on,off and toggle
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Updated controller reading code to support Asciipad
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Improved SNES mouse timing to support WII nunchuck interface.
    -Updated controller tester mouse support
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    -Direction bits corrected and pull ups activated for soft-power switches
    -Corrected bug in EepromReadBlock that prevented the reading block 0
    -Main program can decided when controllers are read instead of kernel with CONTROLLERS_VSYNC_READ compile switch
    -DetectControllers() can now detect if a joypad or mouse is connected to both ports (note: function is not backward compatible)
    -Updated the EepromHeaderStruct to add the bootloaderFlags field.
    -Fixed an alignment bug in the EEPROM's format table.
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    removed commented out sections
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixed PCM channel regression when used on chan3(noise channel)
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Fixed bug that disabled sound randomly
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    Merged uzem-140
    stuff to support uzem140 (testing new mode13)
    Update mmc.s
    -mmc.s: Added wait states to support more SD cards brands
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    replaced trunk with code from beta5 branch
    New kernel compile time constant: INTRO_WAVETABLE.
    
    This constant defines the wavetable to use for the intro sound if
    INTRO_LOGO is set 1. By default the previous behaviour (using wave 8) is
    reproduced, the feature is useful if you supply a custom wavetable.
    replaced trunk with code from beta5 branch
    -added uzebox linkscript
    -Added PORTIOs to uzebox linkscript
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    work
    Bugfix: Added include for stdint.h to kernel/sdBase.h
    
    This fixes compiling errors which occur if sdBase.h is included before an
    other include which provides stdint.h whose types it uses.
    changed names of sdSimple to sdBase
    consistant function names
    SD reading demo with BLIT to RAM shown
    Added local mmc.s and mmcextra.c to a tutorial to show simple SD card reading stuff
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Reverting the revert to prepare for a proper bugfix.
    
    This reverts commit 3d5f382b854b61796af45efa2a3cc16f6f7df638.
    Revert "Mixer boost (#88)" because it breaks PCM sound effects
    
    This reverts commit ddc078a0bb71f99e41ffec68676b80f58f0ff4a2.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    Mixer boost (#88)
    
    A significantly faster inline mixer based on Flight of a Dragon and CunningFellow's mixer optimizations. It doesn't change anything in the behaviour, the most notable benefit is more CPU time available for user code in VBlank, also in some video modes, it may enable using a more complex inline mixer.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Simple kernel boost (#78)
    
    * KERNELBOOST: 57 cycles gained on HSync entry, giving ~2000 extra VBlank cycles
    
    The modification replaces the jitter elimination part in the HSync and
    VSync entry codes to a more efficient solution.
    
    It is not fully compatible with the original kernel, but mostly works.
    Notably all timing is shifted 57 cycles "down" relative to the timer,
    which normally isn't a problem (expect for timer value related comments).
    However video modes using the timer for terminating their scanlines (such
    as Mode 13) doesn't work with this modification! (their timer related
    logic has to be modified to follow the 57 cycles shift)
    
    * Kernel boost: Added Timer1 terminated video mode compatibility.
    
    A new TIMER1_DISPLACE constant is introduced which can be used in timer
    terminated video modes to make them compatible with different kernels. Its
    use is added to Mode 13, so now it compiles correctly with the kernel
    boost enabled.
    
    * Kernel boost: Cleaning up.
    
    The Vsync generation also became smaller and a little faster.
    
    * Kernel boost: Cleaned up Mode 13's modification.
    
    It now can be used as a general working example for setting up other
    Timer1 terminated video modes.
    New kernel compile time constant: INTRO_WAVETABLE.
    
    This constant defines the wavetable to use for the intro sound if
    INTRO_LOGO is set 1. By default the previous behaviour (using wave 8) is
    reproduced, the feature is useful if you supply a custom wavetable.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Added defines for videomode14
    -Added Game of Life sources
    -Added kernel support for custom video modes (mode 0)
    First commit of Tornado 2000
    stuff to support uzem140 (testing new mode13)
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Fixed issue with MIDI IN.
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Created video mode 13
    -Added MOD player
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Renamed mode 11 to mode 12
    -Added new video mode 11 (wip)
    -minor fixes to sound engine slide & note hold commands
    -added comments and constants
    added game MegaSokoban and video mode 10
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    added video mode 9 sources
    -Main program can decided when controllers are read instead of kernel with CONTROLLERS_VSYNC_READ compile switch
    -DetectControllers() can now detect if a joypad or mouse is connected to both ports (note: function is not backward compatible)
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Revert "Add missing prototype for SetScrolling function"
    
    This reverts commit 3d65053606168890f96e471c36cd549a2645b329.
    Add missing prototype for SetScrolling function
    -Added IsSongPlaying() function.
    Merged uzem-140
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    -fix for random note stuck
    stuff to support uzem140 (testing new mode13)
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -New: ClearVsyncCounter and GetVsyncCounter functions
    -Added UzenetDemo project
    -Added MOD player
    -Added support for true random number generation using the WDT entropy trick
    -Fixed audio bug in channel 5. Looping would not account for accumulated fractional part.
    -Added functions to control LED: on,off and toggle
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Added missing logo include files
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    -Main program can decided when controllers are read instead of kernel with CONTROLLERS_VSYNC_READ compile switch
    -DetectControllers() can now detect if a joypad or mouse is connected to both ports (note: function is not backward compatible)
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Modified Petitfatfs to support makefile compile time switches to deactivate functions
    -Added PetitFatFs library
    -Added PetitFatFs library
    -Added FatFS library
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Modified Petitfatfs to support makefile compile time switches to deactivate functions
    -Added PetitFatFs library
    -Added PetitFatFs library
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Modified Petitfatfs to support makefile compile time switches to deactivate functions
    -Added PetitFatFs library
    -Added PetitFatFs library
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -mode6 wip: added high-res mode, ported point & line function to assembler
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -mode6 wip: added high-res mode, ported point & line function to assembler
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    -mode6 wip: added high-res mode, ported point & line function to assembler
    replaced trunk with code from beta5 branch
    added game MegaSokoban and video mode 10
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Fixed mode 10 timing
    -Standardized MegaSokoban makefile
    added game MegaSokoban and video mode 10
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixed mode 10 timing
    -Standardized MegaSokoban makefile
    added game MegaSokoban and video mode 10
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Added video mode 5 sources
    -fixed mode 1 bugs
    -refactored logo stuff
    -Fixed mode 10 timing
    -Standardized MegaSokoban makefile
    added game MegaSokoban and video mode 10
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Bugfix: Accidentally left some defines referring Mode 41 in Mode 42.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Mode 9: Added feature to set background color for each character line
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Bugfix: Accidentally left some defines referring Mode 41 in Mode 42.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    MODE42: A Mode 40 derivative with 16 color palettized attributes.
    
    This video mode allows to have foreground and background attributes while
    retaining the memory footprint of Mode 41. It achieves this with slightly
    larger ROM usage.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    work
    MODE13: The scrolling Mode 13 is now capable to be 30 tiles wide. (#71)
    
    I revised it, found acceptable, so merging in!
    work
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    Mode3: Added support for Y flipping in MapSprite2.
    -Added compile switch to specify horizontal resolution in mode 3 without scrolling
    -Fixed a timing bug in mode3 when RAM_TILES_COUNT=0
    -Video Mode 3: added Y sprite flipping
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Added conditional compile switch to set VRAM_TILES_H for mode 3 in non-scrolling mode.
    -Mode 3: Added tile bank select to sprite flags
    added conditional for TRANSLUCENT_COLOR in videoMode3.def.h
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Simple kernel boost (#78)
    
    * KERNELBOOST: 57 cycles gained on HSync entry, giving ~2000 extra VBlank cycles
    
    The modification replaces the jitter elimination part in the HSync and
    VSync entry codes to a more efficient solution.
    
    It is not fully compatible with the original kernel, but mostly works.
    Notably all timing is shifted 57 cycles "down" relative to the timer,
    which normally isn't a problem (expect for timer value related comments).
    However video modes using the timer for terminating their scanlines (such
    as Mode 13) doesn't work with this modification! (their timer related
    logic has to be modified to follow the 57 cycles shift)
    
    * Kernel boost: Added Timer1 terminated video mode compatibility.
    
    A new TIMER1_DISPLACE constant is introduced which can be used in timer
    terminated video modes to make them compatible with different kernels. Its
    use is added to Mode 13, so now it compiles correctly with the kernel
    boost enabled.
    
    * Kernel boost: Cleaning up.
    
    The Vsync generation also became smaller and a little faster.
    
    * Kernel boost: Cleaned up Mode 13's modification.
    
    It now can be used as a general working example for setting up other
    Timer1 terminated video modes.
    MODE13: The scrolling Mode 13 is now capable to be 30 tiles wide. (#71)
    
    I revised it, found acceptable, so merging in!
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    done
    completed timing fix
    work on timers
    work
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Created video mode 13
    -Mode 9: Added feature to set background color for each character line
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    added video mode 9 sources
    work
    work
    -Added missing logo include files
    fixed case-sensitivity issue in videoMode13.c
    work
    Mode3: Added support for Y flipping in MapSprite2.
    Video mode 3: Y scrolling fixed
    -fixed mode 1 bugs
    -refactored logo stuff
    -Video Mode 3: added Y sprite flipping
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Mode 3: Added tile bank select to sprite flags
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    work
    -Video mode 3: Added GetTile() function
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added overlay for mode3 w/o scrolling
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    -Mode 3: Added tile bank select to sprite flags
    replaced trunk with code from beta5 branch
    work
    -Added missing logo include files
    MODE3: RAM sourced sprites are added.
    
    RAM sprites can be enabled by SPRITE_RAM_ENABLE, then the SPRITE_RAM flag
    will select RAM sourced sprites. This case the sprite index is an user RAM
    tile index.
    
    Some optimizations are also added to the C language sprite blitter.
    MODE3: Fixing sprite Y scroll. SPRITE_OFF flag added.
    
    The sprite Y scroll of the scrolling Mode 3 should now work in a
    reasonable manner (sprite displays when vertically it is in the visible
    region, no artifacts present when it is outside).
    
    A SPRITE_OFF flag is added. This flag can be used on sprites to disable
    them (so you don't need to destroy a sprite coordinate to move it off
    screen).
    MODE3: Added proper sprite X clipping to scrolling Mode 3.
    
    Sprites not visible are no longer drawn (as long as the SCREEN_TILES_H is
    less than 32).
    Mode3 new frame driver (#79)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    
    * MODE3: Added RT_ALIGNED compile time option.
    
    With this, you can get RAM tiles aligned to 64 byte boundary, slightly
    improving blitting performance. The RAM tiles this case are located after
    the VRAM which is aligned already to avoid wasting bytes.
    
    * MODE3: Documenting critical parts.
    
    Preparations for understanding and rewriting the frame code of the mode
    (for the later 5.5 cycles / pixel option, and also cleaning it up as much
    as possible).
    
    * MODE3: New scanline loop and higher resolution feature.
    
    The normal scrolling Mode 3 can now have 30 tiles width. The
    RESOLUTION_EXT compile time flag is added to enable compiling the 5.5
    cycles / pixel scanline loop instead of the 6 cycles / pixel one, if
    that is used, scrolling Mode 3 can have up to 31 tiles width (not more
    only due to the VRAM layout).
    
    In the next phase, the non-scrolling Mode 3 will also be transformed to
    have these capabilities (the 5.5 cycles / pixel scanline loop supporting
    up to 32 tiles width).
    
    * MODE3: Added non-scrolling support.
    
    Now it works both with scrolling and non-scrolling games, with the default
    settings everything should compile and run fine as before. RESOLUTION_EXT
    is completely transparent.
    
    * MODE3: Fixing accidental commit with RESOLUTION_EXT enabled by default.
    
    It should be disabled to produce compatible visual output with the
    original Mode 3, I had it set for testing.
    
    * MODE3: Miscalculated wait corrected.
    
    The modified wait wasn't updated to the modified count of instructions on
    the oter branch.
    
    * MODE3: Added kernel timing compatibility constant.
    
    The TIMER1_DISPLACE constant introduced with the kernel boost is applied
    on the new Mode3 frame driver.
    Mode 3 blitter boost - RT_ALIGNED feature (aligned RAM tiles) (#76)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    
    * MODE3: Added RT_ALIGNED compile time option.
    
    With this, you can get RAM tiles aligned to 64 byte boundary, slightly
    improving blitting performance. The RAM tiles this case are located after
    the VRAM which is aligned already to avoid wasting bytes.
    Mode 3 blitter boost & features (#75)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    -work on user ram tiles
    -lode runner fix
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    Mode3: Added support for Y flipping in MapSprite2.
    -Added compile switch to specify horizontal resolution in mode 3 without scrolling
    -Fixed a timing bug in mode3 when RAM_TILES_COUNT=0
    -Video Mode 3: added Y sprite flipping
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Added conditional compile switch to set VRAM_TILES_H for mode 3 in non-scrolling mode.
    -Mode 3: Added tile bank select to sprite flags
    added conditional for TRANSLUCENT_COLOR in videoMode3.def.h
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Bugfix: videoMode3core.s, SetFont
    
    Originally mentioned in: http://uzebox.org/forums/viewtopic.php?f=3&t=9994&p=29736&hilit=SetFont#p29736
    
    In the line with add r20,21 (1535) the "r" is missing from "21". It should be "add r20,r21". It appears that 21 and r21 act the same though. Still, this is technically a typo and should be updated.
    MODE3: RAM sourced sprites are added.
    
    RAM sprites can be enabled by SPRITE_RAM_ENABLE, then the SPRITE_RAM flag
    will select RAM sourced sprites. This case the sprite index is an user RAM
    tile index.
    
    Some optimizations are also added to the C language sprite blitter.
    Mode3 new frame driver (#79)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    
    * MODE3: Added RT_ALIGNED compile time option.
    
    With this, you can get RAM tiles aligned to 64 byte boundary, slightly
    improving blitting performance. The RAM tiles this case are located after
    the VRAM which is aligned already to avoid wasting bytes.
    
    * MODE3: Documenting critical parts.
    
    Preparations for understanding and rewriting the frame code of the mode
    (for the later 5.5 cycles / pixel option, and also cleaning it up as much
    as possible).
    
    * MODE3: New scanline loop and higher resolution feature.
    
    The normal scrolling Mode 3 can now have 30 tiles width. The
    RESOLUTION_EXT compile time flag is added to enable compiling the 5.5
    cycles / pixel scanline loop instead of the 6 cycles / pixel one, if
    that is used, scrolling Mode 3 can have up to 31 tiles width (not more
    only due to the VRAM layout).
    
    In the next phase, the non-scrolling Mode 3 will also be transformed to
    have these capabilities (the 5.5 cycles / pixel scanline loop supporting
    up to 32 tiles width).
    
    * MODE3: Added non-scrolling support.
    
    Now it works both with scrolling and non-scrolling games, with the default
    settings everything should compile and run fine as before. RESOLUTION_EXT
    is completely transparent.
    
    * MODE3: Fixing accidental commit with RESOLUTION_EXT enabled by default.
    
    It should be disabled to produce compatible visual output with the
    original Mode 3, I had it set for testing.
    
    * MODE3: Miscalculated wait corrected.
    
    The modified wait wasn't updated to the modified count of instructions on
    the oter branch.
    
    * MODE3: Added kernel timing compatibility constant.
    
    The TIMER1_DISPLACE constant introduced with the kernel boost is applied
    on the new Mode3 frame driver.
    MODE3: Don't attempt to write RAM without the VSync sprite processing.
    
    When SPRITES_VSYNC_PROCESS is off, this behaviour is easier to use (the
    video frame won't damage VRAM under algorithms spanning multiple frames).
    Mode 3 blitter boost - RT_ALIGNED feature (aligned RAM tiles) (#76)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    
    * MODE3: Added RT_ALIGNED compile time option.
    
    With this, you can get RAM tiles aligned to 64 byte boundary, slightly
    improving blitting performance. The RAM tiles this case are located after
    the VRAM which is aligned already to avoid wasting bytes.
    Mode 3 blitter boost & features (#75)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    Update videoMode3core.s
    
    fixed CopyRamTile functions: cleared r1 before exit.
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    stuff to support uzem140 (testing new mode13)
    work on timing
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Video mode 3: Added GetTile() function
    Video mode 3: Y scrolling fixed
    -vmode3: removed unused linear buffer array (recovers 30 bytes)
    -Added compile switch to specify horizontal resolution in mode 3 without scrolling
    -Fixed a timing bug in mode3 when RAM_TILES_COUNT=0
    -Video Mode 3: added Y sprite flipping
    -Fixed offset bug in SetFont in mode 3
    -Merged SetFont and SetTile in mode 3
    -Removed RAM_TILES_COUNT references in uzeboxVideoEngine.c
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added overlay for mode3 w/o scrolling
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    -Mode 3: Added tile bank select to sprite flags
    -Fixed bug in mode 3, no scrolling: ramtiles were never restored because forgot to clear r1 before call to RestoreBackground()
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -yet more screen centering tweaking for mode 1 & 3
    -fixed CENTER_ADJUSTMENT from mode 1
    -Cleanup in videoMode3core.s
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    Mode 3 blitter boost & features (#75)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    -removed GetUserRamTiles();
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    -Video mode 3: Added GetTile() function
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added overlay for mode3 w/o scrolling
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    -Mode 3: Added tile bank select to sprite flags
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    MODE3: RAM sourced sprites are added.
    
    RAM sprites can be enabled by SPRITE_RAM_ENABLE, then the SPRITE_RAM flag
    will select RAM sourced sprites. This case the sprite index is an user RAM
    tile index.
    
    Some optimizations are also added to the C language sprite blitter.
    MODE3: Fixing sprite Y scroll. SPRITE_OFF flag added.
    
    The sprite Y scroll of the scrolling Mode 3 should now work in a
    reasonable manner (sprite displays when vertically it is in the visible
    region, no artifacts present when it is outside).
    
    A SPRITE_OFF flag is added. This flag can be used on sprites to disable
    them (so you don't need to destroy a sprite coordinate to move it off
    screen).
    MODE3: Added proper sprite X clipping to scrolling Mode 3.
    
    Sprites not visible are no longer drawn (as long as the SCREEN_TILES_H is
    less than 32).
    Mode3 new frame driver (#79)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    
    * MODE3: Added RT_ALIGNED compile time option.
    
    With this, you can get RAM tiles aligned to 64 byte boundary, slightly
    improving blitting performance. The RAM tiles this case are located after
    the VRAM which is aligned already to avoid wasting bytes.
    
    * MODE3: Documenting critical parts.
    
    Preparations for understanding and rewriting the frame code of the mode
    (for the later 5.5 cycles / pixel option, and also cleaning it up as much
    as possible).
    
    * MODE3: New scanline loop and higher resolution feature.
    
    The normal scrolling Mode 3 can now have 30 tiles width. The
    RESOLUTION_EXT compile time flag is added to enable compiling the 5.5
    cycles / pixel scanline loop instead of the 6 cycles / pixel one, if
    that is used, scrolling Mode 3 can have up to 31 tiles width (not more
    only due to the VRAM layout).
    
    In the next phase, the non-scrolling Mode 3 will also be transformed to
    have these capabilities (the 5.5 cycles / pixel scanline loop supporting
    up to 32 tiles width).
    
    * MODE3: Added non-scrolling support.
    
    Now it works both with scrolling and non-scrolling games, with the default
    settings everything should compile and run fine as before. RESOLUTION_EXT
    is completely transparent.
    
    * MODE3: Fixing accidental commit with RESOLUTION_EXT enabled by default.
    
    It should be disabled to produce compatible visual output with the
    original Mode 3, I had it set for testing.
    
    * MODE3: Miscalculated wait corrected.
    
    The modified wait wasn't updated to the modified count of instructions on
    the oter branch.
    
    * MODE3: Added kernel timing compatibility constant.
    
    The TIMER1_DISPLACE constant introduced with the kernel boost is applied
    on the new Mode3 frame driver.
    Mode 3 blitter boost & features (#75)
    
    * MODE3: Converted assembly file to Unix new lines.
    
    Preparation for a larger modification.
    
    * MODE3: Blitter optimizations.
    
    The blitter main loop became about 25% faster.
    
    * MODE3: Removed old commented-out blitter code.
    
    * MODE3: Minor overhead optimizations in the blitter
    
    Made the blitter slightly smaller and faster, using one byte less stack.
    
    * MODE3: Minor overhead and loop optimizations in the blitter.
    
    Made it sligthly faster and using a byte less stack (no stack usage now).
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Further blitter loop optimization.
    
    An earlier quirk of the loop's algorithm was removed, making it both
    smaller and faster.
    
    * MODE3: Converted videoMode3.c to Unix format.
    
    Preparing for a larger change.
    
    * MODE3: Rewrote ProcessSprites().
    
    The new function body should be sligthly faster and should contain less
    bugs while providing better support for irregular tile sizes (not 8x8).
    
    Also added copyright notices where appropriate.
    
    * MODE3: RestoreBackground reimplemented in assembly.
    
    This saves a few hundred clocks for a frame as the assembly generated from
    the C code was poor.
    
    * MODE3: Made RestoreBackground a little smaller and faster.
    
    * MODE3: Converted videoMode3.h and videoMode3.def.h to Unix newlines.
    
    In preparation for larger modifications.
    
    * MODE3: Added SPRITES_VSYNC_PROCESS compile time flag.
    
    By default the flag's value is 1, which is the behavior of the kernel
    before the introduction of this flag. By setting it to 0, it is possible
    to turn off automatic sprite management.
    
    * MODE3: Added SPRITES_AUTO_PROCESS compile time flag.
    
    Setting this zero allows for using a simple blitter instead of Mode3's
    default sprite engine.
    
    * MODE3: Added RAM Tile restore list disable option.
    
    This compile time option can be used to remove the RAM Tile restore list,
    useful for games not needing it (which only use User RAM tiles or always
    rebuild the full VRAM).
    -Fixes & Cleanup to LoadeRunner
    -Update to ramtiles manipulation functions
    -removed GetUserRamTiles();
    -Implemented user ram tiles
    -Fixed Loderunner
    -work on user ram tiles
    -lode runner fix
    Mode3: Added support for Y flipping in MapSprite2.
    Video mode 3: Y scrolling fixed
    -fixed mode 1 bugs
    -refactored logo stuff
    -Video Mode 3: added Y sprite flipping
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    Kernel upgrade final update
    -Fixed remaining broken games
    -Added const keyword to all progmem declares
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Mode 3: Added tile bank select to sprite flags
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    work
    -Video mode 3: Added GetTile() function
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Added overlay for mode3 w/o scrolling
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    -Mode 3: Added tile bank select to sprite flags
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    removed ClearVram call in mode9 init function
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    Video Mode 2 sprites structure bugfix: The structure had multiple declarations
    in the kernel and also in the Zombienator game, and somehow it still compiled
    until now, gcc 10.1.0 known to fail with it.
    -fixed mode 1 bugs
    -refactored logo stuff
    Kernel:
    - Mode 2 MoveSprite now spaces individual sprites within a mega-sprite 6 pixels apart along the x-axis
    replaced trunk with code from beta5 branch
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    replaced trunk with code from beta5 branch
    Bugfix: Missing and incorrect section identifications.
    
    Particularly around the waves table due to this problem unnecessary
    alignments were inserted increasing code size.
    Merged uzem-140
    stuff to support uzem140 (testing new mode13)
    Typo fixes
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Video Mode 12: Added support to set bg/fg colors
    -Added 128x64 sub video mode
    -Renamed mode 11 to mode 12 + refactoring
    -Added new video mode 11 (wip)
    Merged uzem-140
    stuff to support uzem140 (testing new mode13)
    Typo fixes
    -Video Mode 12: Added support to set bg/fg colors
    -Added 128x64 sub video mode
    -Renamed mode 11 to mode 12 + refactoring
    -Added new video mode 11 (wip)
    replaced trunk with code from beta5 branch
    Merged uzem-140
    stuff to support uzem140 (testing new mode13)
    Typo fixes
    -Renamed mode 11 to mode 12 + refactoring
    -Added new video mode 11 (wip)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    Fixed VideoMode8 PutPixel and GetPixel functions.
    
    Apparently there is a bug in GCC's linker making it omitting copying
    initialized data into RAM on init, so RAM arrays would lack their initial
    data. Mode 8's functions relied on this.
    
    The fix simply moves them into ROM, making the routines 2 cycle slower, but
    working consistently.
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    Bug fix in GetPixel function that used wrong pixel mask
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Mode 9: Added feature to set background color for each character line
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Updated file comments to specify the mode now support variable height tiles.
    -fixed mode 1 bugs
    -refactored logo stuff
    Video mode 1: added support for 8 pixel wide tiles
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    -Optimized kernel code size. Games now ~550-900 bytes smaller.
    -Move button functions to gui.c
    -yet more screen centering tweaking for mode 1 & 3
    -fixed CENTER_ADJUSTMENT from mode 1
    -Cleanup in videoMode3core.s
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    -Added missing logo include files
    Video mode 1: added support for 8 pixel wide tiles
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    -Added missing logo include files
    -fixed mode 1 bugs
    -refactored logo stuff
    -Uncommented fading code in vsync call
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -fixed mode 1 bugs
    -refactored logo stuff
    video mode 1: MODE1_FAST_VSYNC now set to 1 by default.
    Video mode 1: added support for 8 pixel wide tiles
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    -Added FatFS library
    -Added FatFS library
    -Added FatFS library
    -Updates to petitfatfs
    -Added audio channel 5 to inline mixer
    -Added print functions for debugging
    -Added FatFS library
    -Added FatFS library
    -Added FatFS library
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Mode 9: Added feature to set background color for each character line
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    removed ClearVram call in mode9 init function
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    removed ClearVram call in mode9 init function
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Clean-ups and optimizations in the SPI RAM blitter.
    MODE74: SPI RAM sourced sprite blitter added.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    -restore SpriteDemo
    -Added Zombienator project
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Mode748 (#94)
    
    MODE748: SPI RAM based Mode 74 variant.
    
    This video mode uses SPI RAM extensively for generating its display, enabling the creation of complex, graphics-rich games. It is also simpler to use than Mode 74.
    
    The most important type of display in this mode offers a 192 pixels wide surface of 8x8 16 color tiles onto which sprites can be output using a similar blitter to that of Mode 74. Otherwise it supports several SPI RAM sourced bitmapped modes.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    replaced trunk with code from beta5 branch
    -Added video mode 5
    -Added support to dynamically change the number of scanlines rendered
    -Added support to dynamically enable/disable the sound engine
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    replaced trunk with code from beta5 branch
    MODE74: Minor bugfix in the rendering of Y flipped sprites.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Added noreturn attribute to M74_Halt() improving generated code.
    
    The M74_Halt() function is used when Mode 74 is used with frame reset, to
    wait for the next frame in an infinite loop. The next frame would then
    jump to a reset address.
    
    This function never returns. Adding __attribute__((noreturn)) indicates
    this for GCC, allowing generating smaller code (for example a no-return
    path doesn't need to restore registers, saving lots of pushes and pops).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: SPI RAM sourced sprite blitter added.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: SPI RAM sourced sprite blitter added.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Clean-ups and optimizations in the SPI RAM blitter.
    MODE74: SPI RAM sourced sprite blitter added.
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Changed check that detects if a game is already flashed
    -Removed old files
    -Copied MMC lib to project to insure stability
    -Small optimizations to assembler code to reduce binary size
    replaced trunk with code from beta5 branch
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Added video mode 5 sources
    -Added missing logo include files
    Merged uzem-140
    stuff to support uzem140 (testing new mode13)
    -added patch command loop
    -added prng functions
    -added function to find if block exists
    -Removed first_render_line_tmp and ender_lines_count_tmp that were useless
    -fixed bug in eeprom code
    -fixed mode 1 bugs
    -refactored logo stuff
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    -Added missing logo include files
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    -Added video mode 5 sources
    replaced trunk with code from beta5 branch
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    Properly allocate bytes in the bss (#65)
    
    * Properly allocate bytes in the bss
    
    * Fix comment broken by text replacement
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    stuff to support uzem140 (testing new mode13)
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    -Mode 9: Added feature to set background color for each character line
    -Added current field to sync flags for all video modes
    -Sprite struct now 4 bytes in size
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -Fixed video timing for video modes: 1,2,3,5,6,7,8,9 because of new kernel video features released in version r191
    added video mode 9 sources
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added UART TX buffer
    -Rewrite of UART RX buffer
    -Added HSYNC_USABLE_CYCLES to video modes 1,3,9
    -Update to Uzenet project
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    removed ClearVram call in mode9 init function
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Mode 9: Added feature to set background color for each character line
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Bugfix: Mode 40/41 character base calculation.
    
    Now the kernel print functions behave correctly on ASCII character sets in
    these modes (IBM ASCII and Mattel). The C64 sets are not ASCII, so are not
    possible to be used with the kernel's API.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    Mode90 (#70)
    
    * MODE90: Initial commit
    
    A new video mode proof of concept based on Mode 9, drastically reducing ROM
    consumption (only the 360 pixels wide variant).
    
    Some features might be added still, mainly for palette manipulation (row by
    row color selection option and likes).
    
    * MODE90: Added GetTile() and GetFont() functions.
    
    * MODE90: Removed an unnecessary instruction.
    
    * MODE90: Added Mode 92 derivative supporting 2bpp framebuffer.
    
    * MODE90: Fixed the ugly subi / sbci hack, now the vram can be anywhere.
    
    * MODE90: Added a missing allocation.
    
    The m90_split symbol pointed at an internal variable which would have messed
    up the SetFont and GetFont kernel routines if they were used.
    
    * MODE90: Added palette split feature.
    
    Mostly it fit well. In Mode 90 the audio mixer had to be reduced to 228
    cycles (but in Mode 92 it could remain 230 cycles). Tested, apparently
    works. Documentations are in the VideoMode9Xcore.s files.
    -Update to Uzenetdemo
    -Added cursor support to mode9/80
    -Mode 9: Added feature to set background color for each character line
    added video mode 9 sources
    replaced trunk with code from beta5 branch
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    MODE41: A companion mode for Mode 40
    
    This is a companion mode for Mode 40 with similar features but with less RAM consumption, allowing only foreground color attributes. Some old systems had such limitations (the C64 in particular had), using this mode gives more free RAM when recreating such games.
    Mode40 (#84)
    
    MODE40: 40x25 Attribute mode
    
    A new video mode capable to recreate the text modes of several old 8 and 16 bit machines, notably including the Commodore 60 / Plus 4, IBM CGA ASCII and Mattel Aquarius.
    MODE74: Polished example programs.
    
    Configurations are now in a kconf.h file (instead of m74cfg.h suggesting
    only Mode 74 specifics), this is more appropriate for this video mode.
    
    Makefiles also got a little polish to get them slightly more readable.
    EEPROM generation was removed (it is not useful since the EEPROM is
    normally shared on an Uzebox between games).
    Mode74 (#69)
    
    * MODE74: First commit of Video Mode 74
    
    It should be functional. The tile row modes themselves were already tested,
    however some combinations weren't. The RAM clear and SPI load features in
    particular weren't tried yet.
    
    The documentation (M74 Manual in the video mode's directory) is ongoing, for
    now it should be sufficient to get the idea.
    
    Next mayor goal is the creation of a fitting sprite library.
    
    The video mode and all associated code within its directory should use Unix
    newline format.
    
    * MODE74: Added more documentation.
    
    The new parts briefly describe the major components and features of the mode,
    concerning their possible uses. For in-depth documentation, still the
    descriptive comments within videoMode74.s should be used.
    
    * MODE74: Typo fixes in the documentation.
    
    * MODE74: A fairly complete rebuild.
    
    Notable features are:
    
    - Smaller tile row descriptors after moving out several pointers to compile
      time definitions.
    
    - Capability to have 3 modes mixed in a row (the row dependent mode, 64 ROM
      4bpp tiles, 64 RAM 4bpp tiles).
    
    - A new 2bpp Multicolor RAM source mode as an optional feature (about 3K).
    
    * MODE74: Sprite engine added, partially tested.
    
    Notable features:
    
    - Simple restore + blit interface.
    - 8x8 fixed size sprites (combine to get larger sprites).
    - Up to 64 RAM tiles can be used (2K RAM).
    - Supports user RAM tiles and RAM sprite sources.
    - X & Y flipping.
    - Mask support: Sprites may be partially or completely covered by tiles.
    - Importance support to prioritize sprite parts when exceeding RAM tile limit.
    
    Testing: Sufficient for running the dragon disc tech-demo. This means notably
    that X and Y flipping and user RAM tile support is not tested yet, but if they
    don't work right, the problem should be fixable without much trouble. The
    dragon disc tech-demo excercises all the critical features.
    
    Documentation is not yet produced, the videoMode74_sprite.s source's (long)
    head comment should adequately describe how to use it. Flag definitions are in
    videoMode74.def.h.
    
    * MODE74: Sprite X flipping bug fixed (Y flipping tested OK).
    
    * MODE74: Algorithm redesigns in the sprite engine, detaching the RAM tile allocator.
    
    * MODE74: Single pixel blitting (PutPixel) function added and tested.
    
    * MODE74: VRAM assistance functions (scrolling, filling) added.
    
    * Mode74: RAM tile allocator modified to eliminate a glitch when render spills out of VBLANK.
    
    * MODE74: Added (optional) support for sprite recoloring. Tested, works.
    
    * MODE74: Added and tested SD card support along with a few other changes.
    
    Apart from the necessities of proper SD loading support a few other, mostly
    related changes were performed. User video mode support was removed.
    
    A new feature was added to the 2bpp Multicolor mode: simple double scanning.
    This can be set up compile time, and may be activated by a flag.
    
    * MODE74: SD load received a base sector feature.
    
    * MODE74: Dropping a few lesser features, bugfixes, clean-ups, SD access optimizations.
    
    The features dropped were:
    
    - Scanline maps. Only the RAM based restart markers remained which should be
      sufficient, the scanline maps having little use. This enabled dropping a few
      bytes of RAM and gained some cycles for potential audio use.
    
    - Full X scroll specification. Only X shift (0 - 7 pixels) remained (so
      horizontal scrolling capability is still there!). The sprite engine relies
      on VRAM copies, so with that, the full X scroll would be useless anyway.
    
    SD access optimizations:
    
    - When no horizontal scroll is performed, an additional SD access may be made,
      thus making it possible to use this feature at full (24 tiles) width.
    
    - Row mode 3 (2bpp Multicolor) got an extra SD access on top of this (so with
      no color 0 reload, it does 2 SD loads: 4 bytes even at 24 tiles width).
    
    - It is possible (compile time switch) to add an extra SD access at the cost
      of audio cycles (leaving 196 cycles which is 29 cycles more than necessary
      for the 4 channel inline mixer, but not enough for 5 channels / UART)
    
    - Row mode 7 (Separator line) can do 24 SD accesses contrary to 17 before.
    
    Bugfixes and clean-ups were performed across the entire code base except for
    the sprite engine. Notably a new WAIT mechanism was also added to trim a bit
    on code size (especially in Row mode 7 when compiled without SD access).
    
    * MODE74: Feature fix: 256 byte increments possible for tiles 0x00 - 0x7F.
    
    This is important to support sharing 1bpp tileset between row mode 3 (which
    can only use an increment of 256) and the other 1bpp row modes.
    
    * MODE74: Two examples added to demonstrate some of the video mode.
    
    One is the Outcasts title screen concept which demonstrates Row mode 3 (2bpp
    Multicolor), and some palette effects.
    
    The other is the dragon disc sprite demo, showing off most of the sprite
    engine's features over a simple tiled background (Row mode 0).
    
    * MODE74: Added image & data generators.
    
    Simple data and image generators for producing tileset and other data for Mode
    74, those used to produce the example programs.
    
    * MODE74: Documentation updates.
    
    * MODE74: Uzebox logo added.
    
    From now it is possible to use an Uzebox intro logo like in other video modes
    using the INTRO_LOGO define. This is designed so it interferes the least with
    the flexibility of the mode (that is, the logo should simply work fine with
    most sane use-cases).
    
    The two examples are also updated to show the logo.
    
    * MODE74: Made logo display code a bit smaller.
    
    * MODE74: Reset on frame return capability added.
    
    The reset on frame end capability allows for creating a main program which is
    only allowed to run until the start of the next video frame. Then it is
    terminated. Upon the return from the video frame, it is restarted with an
    empty stack.
    
    The sprite engine received a few necessary fixes to work properly with this
    feature, that is, it can be terminated within render.
    
    A new example is added, the same sprite demo, but modified to this reset
    enabled concept.
    
    The reset function was also tested succesfully with the SD loading feature in
    the Multicolor mode.
    
    A major benefit of this feature, and the default configuration is set up
    accordingly is that almost the complete Stack can be eliminated: the main
    program can use the Palette buffer as Stack. This saves 240 bytes in the
    0x1010 - 0x10FF range (the 0x1000 - 0x100F range is used as stack for the
    video mode, which is sufficient for this purpose).
    
    Later the video mode stack might be moved off to an arbitrary location so the
    Palette buffer and Main program stack may be moved up into the 0x1000 - 0x10FF
    region.
    
    * MODE74: Reset feature enhanced to allow more freedom in stack layout.
    
    The main program and the video frame stacks were decoupled, which allows for
    locating the main program stack along with the palette buffer at 0x1000 -
    0x10FF. The default configuration however is left as previously (both stack
    tops set at 0x1010, that is, 0x1010 being the first byte not occupied by
    stack) to allow for displaying the logo using the default stack top (with no
    reset).
    
    * MODE74: Color index 0 disable feature added.
    
    Color index 0 disable if enabled causes omitting the fill of color 0 in the
    palette buffer, thus saving 16 bytes of RAM. Color 0 is the transparent color
    for sprites, so it might be likely to be left unused.
    
    This disables the "normal" 2bpp mode since it uses color indices 0 - 3. The
    Multicolor 2bpp mode is still available if enabled (it may be used with
    repeating a single VRAM row to conserve RAM memory if necessary for a simple
    2bpp screen).
    
    * MODE74: New feature: slower, but smaller sprite recolor.
    
    This new sprite recolor uses (normally) 16 byte tables for recoloring filled
    simply by the target color indices, thus saving lots of ROM when using many
    recolor tables. The cost is an about 15 percents worse rendering performance.
    It is an optional compile time feature, can be chosen instead of the other 256
    byte based recolor.
    
    Tested with the sprite demo, works.
    
    * MODE74: A fairly complete redesign.
    
    Most features of the mode remained intact, however it received an all around
    restructuring to become more capable.
    
    - Most notably 4bpp tiles are now tile organized in the ROM and RAM, which
      allows more flexible tileset designs (partial overlaying), and is more
      economic in the RAM (RAM tile usage can be dynamically changed to fit the
      needs).
    
    - Row mode 0 (4bpp) is split into 4 x 64 tiles, the 3 ROM tile banks can
      be located arbitrarily.
    
    - Sprite engine now can deal with different ROM tile configurations on the
      same row, thus enabling using more than 192 ROM tiles on a single screen.
    
    - Sprite engine can do parallax scrolling (untested, but should work).
    
    These are roughly the most important features.
    
    Still needs documentation (it wasn't touched yet).
    
    * MODE74: Minor optimizations.
    
    The pixel output got slightly faster by a rearrangement of the RAM tile
    allocator allowing for using less registers.
    
    The reset feature got two small functions to add a halt and a sequence point
    to routines meant to be terminated by a new frame. This gives cleaner code for
    those while conforming the C standard.
    
    * MODE74: Documentation updated.
    
    * MODE74: Bugfix: missing include of the VRAM routines.
    
    * MODE74: Added an extra column of scroll support to the VRAM scroller.
    
    This is necessary to support vertical scroll on a free-directional scrolling
    full (24 tiles) width surface.
    
    * MODE74: Small typo fix in one of the image data generators.
    
    * MODE74: Minor bugfix in Row mode 6's output (1bpp 6 pixel wide tiles).
    
    * MODE74: Properly allocate bytes in .bss
    
    (Following the similar change in the uzebox/master branch)
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    fixed palette in color_table.gif
    replaced trunk with code from beta5 branch
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    added PNG version of color_table
    replaced trunk with code from beta5 branch
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    Initial import.
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    replaced trunk with code from beta5 branch
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    replaced trunk with code from beta5 branch
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Initial import.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    Initial import.
    -Added font include files for mode 9 (60 & 80 cols)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    Added video mode 9 demo project
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Added font include files for mode 9 (60 & 80 cols)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Mode 9: Added feature to set background color for each character line
    Added video mode 9 demo project
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Added font include files for mode 9 (60 & 80 cols)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added codetile font for 80x25 text mode
    -Created video mode 13
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Added font include files for mode 9 (60 & 80 cols)
    -Created video mode 13
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Updated Keyboard demo project to use mode 9/80 columns
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Added codetile font for 80x25 text mode
    -Created video mode 13
    -Added font include files for mode 9 (60 & 80 cols)
    Added video mode 9 demo project
    -Added font include files for mode 9 (60 & 80 cols)
    Added demo for video mode 5
    Added video mode 9 demo project
    replaced trunk with code from beta5 branch
    Work on UzenetDemo
    
    -Added support for new telnet commands
    -Bug fixes
    -Work on the Uzenet API
    -Added terminal-like support to mode 9
    -Full mode9 font
    -Cleanup of VSisualStudio files
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Initial import.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    Initial import.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    emuze - initial commit
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Initial import.
    -Updated video mode1 .def file to allow variable tile height
    -Improved tutorial project to support multiple video modes/font sizes
    -Added more font png and .inc files under the /gfx folder. Break down by font sizes.
    Added demo for video mode 5
    Initial import.
    Fix: Modify Makefile for midiconv so it can run on MinGW without errors
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Rename README files, so the Uzebox one shows up in Github
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Rename README files, so the Uzebox one shows up in Github
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Fix: Allow MinGW (most recent version) to compile bin2hex and midiconv
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    Fix: Allow MinGW (most recent version) to compile bin2hex and midiconv
    Add channel 9 rewrite to channel 3
    Add cross-platform C++ port of midiconv to uzebox/tools/midiconv directory
    
    Converts a MIDI song in format 0 or 1 to a Uzebox MIDI stream
    outputted as a C include file.
    
    This is a cross-platform C++ port of the Java tool named MidiConvert
    contained within the uzebox/tools/JavaTools/dist/uzetools.jar package.
    
    It is built using the Midifile, a C++ library for parsing Standard
    MIDI Files, which is Copyright (c) 1999-2015, Craig Stuart Sapp. All
    rights reserved.
    
    To speed up the build time, all of the original examples that were in
    the src-programs directory have been moved to src-programs-extras. Any
    of those files can be copied back into the src-programs directory and
    then built using the instructions below.
    
    BUILD/INSTALL INSTRUCTIONS:
    
        make
    
    or:
    
        make library
        make midiconv
    
    This will build and install the midiconv binary as uzebox/bin/midiconv
    at which point you can run it using basically the same options as the
    Java version, but pay close attention to the command line arguments
    because some may be slightly different, and long options are provided.
    
    To get a list of all supported options, just run:
    
        ./midiconv --help
    
    TIPS AND TRICKS:
    
    If you used Rosegarden to create a MIDI file by arranging multiple
    segments, unless those segments are joined by clicking the name of
    each track (to select all segments on that track) and pressing Ctrl-J
    to join them, the resulting Uzebox C include file may contain multiple
    redundant control messages, which wastes space. After you export your
    MIDI (using File > Export > Export MIDI File...) you can undo these
    joins if you wish to keep your original segmented source file (for
    instance to preserve any of your linked segments).
    -Fixed .UZE structure packing to one byte in uzem
    -Completed the header structure definition in packrom to match uzem's
    Bug fix: (s >= 'a' && s <= 'f')
    64-bit packrom and uzem are now able to handle headers correctly. This does make the old corrupt 64-bit uze files incompatible with uzem.
    Bug fixes.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Second part of the DEST_DIR flag.
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Add bin2hex tool to make it easier to include raw PCM samples
    
    This is a command line utility that can turn any input file into a C
    style PROGMEM array, useful for including raw PCM data in a Uzebox
    game, but can also be used to include any binary data file.
    
    (Under the hood, it is actually just the xxd utility, but with slight
    modifications to make it default to the correct C style array format
    for Uzebox games.)
    Add bin2hex tool to make it easier to include raw PCM samples
    
    This is a command line utility that can turn any input file into a C
    style PROGMEM array, useful for including raw PCM data in a Uzebox
    game, but can also be used to include any binary data file.
    
    (Under the hood, it is actually just the xxd utility, but with slight
    modifications to make it default to the correct C style array format
    for Uzebox games.)
    Improve Makefile for bin2hex
    Fix: Allow MinGW (most recent version) to compile bin2hex and midiconv
    Modify bin2hex Makefile so it puts the binary inside the bin dir
    Add bin2hex tool to make it easier to include raw PCM samples
    
    This is a command line utility that can turn any input file into a C
    style PROGMEM array, useful for including raw PCM data in a Uzebox
    game, but can also be used to include any binary data file.
    
    (Under the hood, it is actually just the xxd utility, but with slight
    modifications to make it default to the correct C style array format
    for Uzebox games.)
    Emuze:
    - Fixed undo buffer queueing bug
    - Initialized undo buffer with invalid indexes to prevent invalid undo operations on kernel block (which is index 0)
    Emuze:
    - Kernel block is now editable
    - Added 3-deep undo buffer
    - All changes must be saved to persist
    - Added art assets for games: Donkey Kong
    emuze - initial commit
    Fixed emuze const related warnings.
    Fix emuze's kernel path, avr-size flags and progmem arrays.
    Emuze:
    - Fixed undo buffer queueing bug
    - Initialized undo buffer with invalid indexes to prevent invalid undo operations on kernel block (which is index 0)
    Emuze:
    - Kernel block is now editable
    - Added 3-deep undo buffer
    - All changes must be saved to persist
    - Added art assets for games: Donkey Kong
    emuze - initial commit
    emuze - initial commit
    Add -fno-toplevel-reorder to all demo makefiles to make sure gcc 4.6.2 doesn't reorder progmem arrays.
    Fix emuze's kernel path, avr-size flags and progmem arrays.
    emuze - initial commit
    -updated demos makefiles
    -Removed custom function from the API used only by Megatris
    -Added -mcall-prologues to demos makefile (saves ~300-500 bytes of flash)
    -Added support for variable tile/sprite height in mode 3
    -Corrected sync timing in mode 3,8 that caused shearing at the top of screen
    -Corrected screen centering from mode 1,3 so "CENTER_ADJUSTMENT=0" have the picture perfectly centered on a real TV.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Emuze:
    - Kernel block is now editable
    - Added 3-deep undo buffer
    - All changes must be saved to persist
    - Added art assets for games: Donkey Kong
    emuze - initial commit
    emuze - initial commit
    emuze - initial commit
    Emuze:
    - Kernel block is now editable
    - Added 3-deep undo buffer
    - All changes must be saved to persist
    - Added art assets for games: Donkey Kong
    emuze - initial commit
    Emuze:
    - Kernel block is now editable
    - Added 3-deep undo buffer
    - All changes must be saved to persist
    - Added art assets for games: Donkey Kong
    emuze - initial commit
    emuze - initial commit
    Merged uzem-140
    -Fixed .UZE structure packing to one byte in uzem
    -Completed the header structure definition in packrom to match uzem's
    64-bit packrom and uzem are now able to handle headers correctly. This does make the old corrupt 64-bit uze files incompatible with uzem.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Merged uzem-140
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    work on timing
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    Merged uzem-140
    Make ends_with function case insensitiv, therefore it doesn't matter if files are ending with .uze, .UZE, uZe or whatever.
    Lowering the filename prevents loading files that contain upper case letters in filenames.
    Use strncasecmp when comparing file ending instead.
    Fix Emscripten linker warnings, add NOGDB compile flag
    
    The recording feature was causing the Emscripen build to give multiple
    linker warnings, so I added:
    
     ...
    
    guards around the recording code, so none of the functions that can't be
    called from an Emscripen build are seen during the compile.
    
    I also added:
    
     ...
    
    guards around all of the code that deals with GDB, since it has two
    conditionals inside that get executed every emulated clock tick. If
    you are compiling using Emscripten:
    
    EMSCRIPTEN_BUILD=1 make release
    
    the Makefile will automatically set NOGDB=1 for you, or if you want to
    make a native build without GDB support (so it executes faster) you can
    set the flag manually using:
    
    NOGDB=1 make release
    
    when compiling.
    Manual merge of CunningFellow's instruction pre-decoder with Jubatian's Clean-up attempts over cycle-perfect emulation
    Improve the SDL2 port
    
    * Fix screenshots so they are back to being 630x448, rather than 720x224.
    * Add new feature so pressing shift while taking a screenshot gives you a 240x224 bitmap.
    * Fix fullscreen mode so it changes the resolution of the monitor and makes fullscreen fast again on slower computers.
    * Add --swrenderer (-w) flag which will force SDL to use software rendering
    * Add --novsync (-v) flag which disables waiting for VSYNC when using accelerated rendering
    * Combine Jubatian's scanline optimization (fewer conditionals) with Uze's 720px wide render scaling trick with my arbitrary rescaling using a texture trick. It allows for arbitrary rescaling using both hardware and software renderers, while remaining fast on a 2.0 GHz Core 2.
    UZEM: Clean-up attempts over cycle-perfect emulation.
    
    The main change here is splitting up update_hardware into two parts, one to
    manage the cycle precise part, the other to manage the instruction precise
    part. The cycle precise part became entirely responsible for progressing the
    emulated cycle count.
    
    The elimination of various cycle counters (notably the "cycles" variable)
    made cycle counts more consistent, only relying on the count of calls made
    towards update_hardware. This may help implementing further cycle perfection
    changes like proper EEPROM access timing, or in general anything requiring
    extra cycles consumed in various parts of the emulator.
    
    Performance seems to remain the same as before (this is not so trivial to
    determine since avr8's exec function in the original code returned bogus
    cycle counts, missing cycles from various emulation stages).
    
    Newlines should be consistent Microsoft format in the changes.
    Fix buffer overflow (index out of bounds for type 'char [len + 4]')
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    Limit the framerate of the Emscripten version to 60fps
    Add (optional) Emscripten support by setting a flag in the Makefile
    -speed improvements
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -Added movie recording feature using ffmpeg piping
    -Filename fixes for LodeRunner
    -Linux fix: Added strlwr function to uzem.cpp
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    done
    work in timing
    work on timing
    Uzem 1.3.1:
    -Fixed issue that prevented clean exit at command line under windows.
    -Added feature to capture/playback controller buttons
    -Added support for watchdog to support true random generator
    uzem: corrected parameter list
    uzem fix: resolved null path for sd card on linux
    -fix for segfault under Linux when loading directory
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Added a hack for visualizing SRAM/Progmem
    -Added OCR1B interrupt support required by kernel upgrade
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    bug8 fix:Uzem getopt bug
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Merged uzem-140
    Bumped uzem version to 1.3.3
    raised minor version
    -Uzem fix: fixed controller capture replay code.
    Uzem 1.3.1:
    -Fixed issue that prevented clean exit at command line under windows.
    -Added feature to capture/playback controller buttons
    -Added support for watchdog to support true random generator
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    uzem 1.19.1:
    -Bug fix: Initial seek was ignored
    -Bug fix: Can't read past 64k. FAT was not filled with cluster chain.
    -Changed cluster size to a more standard 32k
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    -Upgraded version to 1.18
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    uzem v1.16: Added emulation for timer 1 overflow interrupt
    -Added OCR1B interrupt support required by kernel upgrade
    Mapped the player 2 start button in 2P mode.
    uzem:
    - v1.13
    - Better support for joysticks
    -Tweaked left_edge to -177: Syncronized with the kernel, this value now results in the image being perfectly centered in both the emulator and a real TV
    -Updated version to 1.12
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    update emulator version to 1.10
    replaced trunk with code from beta5 branch
    -Fixed TOV interrupt timing bug. Uzem is now cycle perfect.
    -Removed non-mega644 instruction in the instruction decoder
    -Removed unused SDL_Framerate
    UZEM: Merged in the rearranged CPU instruction decoder switch tree.
    
    Important:
    
    It seems like there are bugs in the instruction timing calculations, see
    the TODO comments. There may be more locations of interest! For now I only
    attempted to merge as-is, not attempting to fix these, just adding a few
    comments here and there to note where the location of the cycles variable
    is important.
    Merged uzem-140
    UZEM: Fixed flag logic bug (exposed by the raycaster experiment of Jhhoward).
    Fix Emscripten linker warnings, add NOGDB compile flag
    
    The recording feature was causing the Emscripen build to give multiple
    linker warnings, so I added:
    
     ...
    
    guards around the recording code, so none of the functions that can't be
    called from an Emscripen build are seen during the compile.
    
    I also added:
    
     ...
    
    guards around all of the code that deals with GDB, since it has two
    conditionals inside that get executed every emulated clock tick. If
    you are compiling using Emscripten:
    
    EMSCRIPTEN_BUILD=1 make release
    
    the Makefile will automatically set NOGDB=1 for you, or if you want to
    make a native build without GDB support (so it executes faster) you can
    set the flag manually using:
    
    NOGDB=1 make release
    
    when compiling.
    UZEM: Re-added update_hardware_fast calls where they were appropriate.
    
    I did some performance tests, mainly using Arkanoid, but also a few other
    programs to see how much impact the use of update_hardware_fast has.
    
    On my PC (a Core 2 Duo, 2,2GHz) with Arkanoid I got the following figures:
    
    55 MHz without the new instruction decoder, without any of my changes.
    70 MHz with my changes only (update_hardware_fast).
    70 MHz with the merge (no update_hardware_fast in the decoder, only on the end).
    62 MHz with no update_hardware_fast at all.
    77 MHz with _fast on the end and only in lpm instructions.
    78 MHz with _fast on the end and lpm, mul, rjmp and ijmp instructions.
    68 MHz with _fast everywhere.
    
    Some conslusions based on these results:
    
    The rebuilt instruction decoder gives about 12% performance increment.
    The update_hardware_fast changeset gives about 27% performance increment.
    The update_hardware_fast used only at the end is about 13%.
    The update_hardware_fast used only in lpm is about 10%.
    Using update_hardware_fast elsewhere barely matters (may deteriorate).
    
    Some explanations:
    
    By nature Uzebox games depend heavily on lpm since the most common is to use
    this to fetch pixel data. The only instruction with more occurrences is out,
    used to put pixel data on the display. On a 8bpp 6 cycles / pixel display,
    about 3 million lpm instructions are executed per second, but a million may be
    expected for just about any game.
    
    The next most common instruction would likely be an incrementing variant of ld
    to produce RAM tiles. However with the rebuilt instruction decoder ld occurs
    on many branches, and adding _fast even to only the incrementing variants
    already had an adverse effect on performance (75MHz). It is harder to select
    those which are likely used by all reasonable games since there are many use
    cases, requiring different variants of ld, unlike lpm.
    
    After these, the management of the tile loop, the load of tiles usually use
    rjmp and mul instructions, the latter for calculating start addresses. The
    ijmp instruction sometimes along with mul may be used heavily with code tiles
    and variations of this technique, such as in the video mode of Tempest 2K.
    
    Considering all these, the likely best use of update_hardware_fast is the lpm,
    mul, rjmp and ijmp instructions, likely providing a consistent performance
    boost for all possible reasonable use cases.
    UZEM: Small tweaks ending up in a massive performance bump!
    
    There are four distinct changes in this package, which performed individually
    for some reason produce dubious results in performance, but combined, give a
    massive near 30 percents increase!
    
    Change 0 relates to Timer 1 again. The TCNT1 counter is no longer incremented
    on the fast path within update_hardware, but rather calculated on demand. The
    rationale is that it saves a load, an increment, and a store on the critical
    path.
    
    Change 1 concerns how the line buffer is filled. Now, taking advantage of that
    it is possible to use the line buffer as a circular buffer, dropping the
    current_cycles variable, the cycleCounter is used directly. This, like the
    change for the timer, removes a load, an increment, and a store from the
    critical path.
    
    Change 2 moves the delayed outputs off of update_hardware, to
    update_hardware_ins, along with placing a note there on why it can be done. It
    can be done since as of now, all AVR instructions which write to I/O ports do
    this in their last cycle, so a delayed output can only appear then, which is
    so handled correctly within update_hardware_ins. By alone this has a meager
    benefit (eliminates a load, and a single hardly ever taken branch), but rather
    prepares for Change 3.
    
    Change 3 creates an inline stub for update_hardware named
    update_hardware_fast, which can perform the fast path inlined. This is then
    used with the most common instructions (like ld, st, lpm, mul, rjmp, ijmp, the
    latter heavily used in code block based graphics modes), and also on the end
    of the instruction decoder. This saves function call overheads, one for all
    instructions, and one extra for those frequently used 2 cycle instructions.
    This is what actually gives the performance bump, but it doesn't work without
    the previous changes cleaning up the fast path.
    UZEM: Combined TIMER1's low and high registers for a small speed bump.
    
    This change eliminates the use of the TCNT1H and TCNT1L registers in the IO
    array favoring an unified counter of native type whose increment can be
    compiled into smaller and faster native code. This results in a small, but
    consistent overall improvement in performance.
    Manual merge of CunningFellow's instruction pre-decoder with Jubatian's Clean-up attempts over cycle-perfect emulation
    Slight change to rendering loop
    Fix memory leak in screenshotting code
    Improve the SDL2 port
    
    * Fix screenshots so they are back to being 630x448, rather than 720x224.
    * Add new feature so pressing shift while taking a screenshot gives you a 240x224 bitmap.
    * Fix fullscreen mode so it changes the resolution of the monitor and makes fullscreen fast again on slower computers.
    * Add --swrenderer (-w) flag which will force SDL to use software rendering
    * Add --novsync (-v) flag which disables waiting for VSYNC when using accelerated rendering
    * Combine Jubatian's scanline optimization (fewer conditionals) with Uze's 720px wide render scaling trick with my arbitrary rescaling using a texture trick. It allows for arbitrary rescaling using both hardware and software renderers, while remaining fast on a 2.0 GHz Core 2.
    UZEM: Clean-up attempts over cycle-perfect emulation.
    
    The main change here is splitting up update_hardware into two parts, one to
    manage the cycle precise part, the other to manage the instruction precise
    part. The cycle precise part became entirely responsible for progressing the
    emulated cycle count.
    
    The elimination of various cycle counters (notably the "cycles" variable)
    made cycle counts more consistent, only relying on the count of calls made
    towards update_hardware. This may help implementing further cycle perfection
    changes like proper EEPROM access timing, or in general anything requiring
    extra cycles consumed in various parts of the emulator.
    
    Performance seems to remain the same as before (this is not so trivial to
    determine since avr8's exec function in the original code returned bogus
    cycle counts, missing cycles from various emulation stages).
    
    Newlines should be consistent Microsoft format in the changes.
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    Fix transposition bug in CMD12 state machine implementation so T2K works again
    Add (optional) Emscripten support by setting a flag in the Makefile
    -Fixed TOV interrupt timing bug. Uzem is now cycle perfect.
    -Removed non-mega644 instruction in the instruction decoder
    -Removed unused SDL_Framerate
    UZEM: Some minor final touches on performance and commenting.
    
    A few rearrangements were carried out to clean up the major execution path a
    little for a minor performance bump. This involved Timer 1, the watchdog, and
    the pixel output.
    
    Several variable types were changed to native int for no noticable effect on
    performance, for some targets (such as Emscripten) it might matter.
    
    Comments were added describing a few components and their roles. Some TODO
    notes were also inserted where I suspected bugs or problems present from the
    original code.
    UZEM: Flags logic polished into a clear all - set bits pattern.
    
    The flags logic in the instruction decoder previously intermixed clearing and
    setting bits which couldn't be untangled well by the compiler. This was
    straightened out so affected flag bits (expect CPC, SBC and SBCI zero flag)
    are cleared first, and only sets happen afterwards. This pattern folds up in
    fewer instructions.
    
    A minor performance bump is provided by this modification, depending on
    instruction usage.
    UZEM: Timer1's code was modified for performance.
    
    What was introduced is the calculation of time between events of Timer1, so
    update_hardware can get Timer1 done with a single comparison if it is still
    far from reaching the next compare or overflow event.
    
    The logic of Timer1 wasn't changed (except for a removal of a TCNT1 assignment
    from write_io, which is unnecessary since these 16 bit variables are only set
    up and used within the Timer1 logic). No bugs except from imperfections in the
    time between events calculation should appear.
    
    Note that with this, write_io necessarily has to clear the new timer1_next
    variable whenever it writes to a timer register under the code avoided by the
    new logic. For this, new cases had to be added for the OCR1A and OCR1B
    registers.
    UZEM: Moved the pixel output outer, in an inline function.
    
    The pixel output is performed about 2 - 3 million times a second in a Uzebox
    game, usually with a single cycle OUT instruction. The write_io function was
    split, so the pixel output could me moved out of it, into a small "header"
    function (which carried over the write_io name), which can be inlined,
    boosting pixel output.
    
    Also removed inline qualifiers from the read_sram_io and write_sram_io
    functions, they are used in 2 cycle instructions where function call overhead
    doesn't matter that much. This helps instruction cache a bit by making code
    notably smaller (and leaving inline for write_sram_io would have made it
    larger again due to the pixel output inline).
    UZEM: The write_io function got a switch-case implementation instead of an if-tree.
    
    The if tree expanded into a jump ladder which is prone to introduce several
    branch mispredictions in a single execution and even if everything was
    predicted right, the latter cases were a long way down. A switch produces a
    single misprediction (and modern processors also remember the last jump
    target, so a sequence of pixels written out should still perform the same way
    like with the jump ladder).
    UZEM: Attempting to create a clean cycle-perfect emulation solution.
    
    Mostly see added comments, they hopefully explain well how the code should
    work. Basically the previous hacks for cycle perfection were tidied up along
    with verifying that they don't cause instruction decoding interfering with
    interrupt entry. Effective behavior for cases tested so far should remain
    identical, while this general solution should solve other I/O related cycle
    perfection problems as well.
    Auto-detect the pixel format that SDL2 chose as "optimal" and use that ordering when recording. Also, fix the recording code so it still works after the previous speed improvements.
    speed improvements
    -speed improvements
    -Speed improvements
    UZEM: Merged in the rearranged CPU instruction decoder switch tree.
    
    Important:
    
    It seems like there are bugs in the instruction timing calculations, see
    the TODO comments. There may be more locations of interest! For now I only
    attempted to merge as-is, not attempting to fix these, just adding a few
    comments here and there to note where the location of the cycles variable
    is important.
    Remove SDL_RENDERER_PRESENTVSYNC flag, so the emulator is sync'd with the sound again
    Fix dropped scanline, while maintaining cycle-perfectness
    Actually fix the synchronization of audio and video when recording a movie
    Fix the synchronization of audio and video when recording a movie
    
    Tell ffmpeg that the raw video frames are coming in at 59.94 fps, and
    keep track of the accumulated error between the actual audio sample
    rate (28636360 / 1820) Hz, and what we told ffmpeg it was (15734 Hz),
    inserting a duplicate audio sample when necessary to keep them in
    sync.
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -Added movie recording feature using ffmpeg piping
    -fixed mouse control
    -fixed SD CMD12
    Fixed soft switch
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    fixes
    -Added PORTIOs to uzebox linkscript
    -Fixed problem with gdb
    -Started to add memory mapped IO symbols in linkscript to be able to display them in uzem/gdb
    done
    completed timing fix
    work on timers
    work in timing
    work on timing
    -Uzem fix: fixed controller capture replay code.
    Uzem 1.3.1:
    -Fixed issue that prevented clean exit at command line under windows.
    -Added feature to capture/playback controller buttons
    -Added support for watchdog to support true random generator
    -Uzem Fix:Added back winodw icon
    -fix for segfault under Linux when loading directory
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    uzem 1.19.1:
    -Bug fix: Initial seek was ignored
    -Bug fix: Can't read past 64k. FAT was not filled with cluster chain.
    -Changed cluster size to a more standard 32k
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    Remove excessive debug info. Added uzebox logo to the taskbar.
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Remove boost threads, and use SDL threads instead.
    Added a hack for visualizing SRAM/Progmem
    Added extra buffering of graphics, and added a seperate thread to update the display using the boost library. Also added Alec's fix for the aspect ratio.
    uzem v1.16: Added emulation for timer 1 overflow interrupt
    -Added OCR1B interrupt support required by kernel upgrade
    Mapped the player 2 start button in 2P mode.
    uzem:
    - v1.13
    - Better support for joysticks
    uzem:
    - Suppressed erroneous console message when attempting to begin re-mapping a joystick when a re-mapping is already in process.
    uzem:
    - Added support for joysticks
    - Updated makefile to make Windows default paths more common (hopefully)
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    -Final tweaked to left_edge (now centered on most TVs)
    -Tweaked left_edge to -177: Syncronized with the kernel, this value now results in the image being perfectly centered in both the emulator and a real TV
    -Updated version to 1.12
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Fix 'ordered comparison between pointer and zero' (#91)
    
    Bugfix: Uzem: Fix "ordered comparison between pointer and zero" compile error encountered on Mac OSX.
    
    See Issue #90 - (https://github.com/Uzebox/uzebox/issues/90)
    Fix readdir bug
    
    Address of array 'entry->d_name' will always evaluate to 'true',
    however readdir can return 0, and if that happens it we should
    check for that to prevent a crash.
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    -fix for segfault under Linux when loading directory
    uzem 1.19.1:
    -Bug fix: Initial seek was ignored
    -Bug fix: Can't read past 64k. FAT was not filled with cluster chain.
    -Changed cluster size to a more standard 32k
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    Remove excessive debug info. Added uzebox logo to the taskbar.
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    -Added PORTIOs to uzebox linkscript
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Added uzebox logo to the taskbar. (missing file)
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    Uzem: Haiku support (#74)
    Merged uzem-140
    Fix Emscripten linker warnings, add NOGDB compile flag
    
    The recording feature was causing the Emscripen build to give multiple
    linker warnings, so I added:
    
     ...
    
    guards around the recording code, so none of the functions that can't be
    called from an Emscripen build are seen during the compile.
    
    I also added:
    
     ...
    
    guards around all of the code that deals with GDB, since it has two
    conditionals inside that get executed every emulated clock tick. If
    you are compiling using Emscripten:
    
    EMSCRIPTEN_BUILD=1 make release
    
    the Makefile will automatically set NOGDB=1 for you, or if you want to
    make a native build without GDB support (so it executes faster) you can
    set the flag manually using:
    
    NOGDB=1 make release
    
    when compiling.
    UZEM: Small tweaks ending up in a massive performance bump!
    
    There are four distinct changes in this package, which performed individually
    for some reason produce dubious results in performance, but combined, give a
    massive near 30 percents increase!
    
    Change 0 relates to Timer 1 again. The TCNT1 counter is no longer incremented
    on the fast path within update_hardware, but rather calculated on demand. The
    rationale is that it saves a load, an increment, and a store on the critical
    path.
    
    Change 1 concerns how the line buffer is filled. Now, taking advantage of that
    it is possible to use the line buffer as a circular buffer, dropping the
    current_cycles variable, the cycleCounter is used directly. This, like the
    change for the timer, removes a load, an increment, and a store from the
    critical path.
    
    Change 2 moves the delayed outputs off of update_hardware, to
    update_hardware_ins, along with placing a note there on why it can be done. It
    can be done since as of now, all AVR instructions which write to I/O ports do
    this in their last cycle, so a delayed output can only appear then, which is
    so handled correctly within update_hardware_ins. By alone this has a meager
    benefit (eliminates a load, and a single hardly ever taken branch), but rather
    prepares for Change 3.
    
    Change 3 creates an inline stub for update_hardware named
    update_hardware_fast, which can perform the fast path inlined. This is then
    used with the most common instructions (like ld, st, lpm, mul, rjmp, ijmp, the
    latter heavily used in code block based graphics modes), and also on the end
    of the instruction decoder. This saves function call overheads, one for all
    instructions, and one extra for those frequently used 2 cycle instructions.
    This is what actually gives the performance bump, but it doesn't work without
    the previous changes cleaning up the fast path.
    UZEM: Combined TIMER1's low and high registers for a small speed bump.
    
    This change eliminates the use of the TCNT1H and TCNT1L registers in the IO
    array favoring an unified counter of native type whose increment can be
    compiled into smaller and faster native code. This results in a small, but
    consistent overall improvement in performance.
    Manual merge of CunningFellow's instruction pre-decoder with Jubatian's Clean-up attempts over cycle-perfect emulation
    Improve the SDL2 port
    
    * Fix screenshots so they are back to being 630x448, rather than 720x224.
    * Add new feature so pressing shift while taking a screenshot gives you a 240x224 bitmap.
    * Fix fullscreen mode so it changes the resolution of the monitor and makes fullscreen fast again on slower computers.
    * Add --swrenderer (-w) flag which will force SDL to use software rendering
    * Add --novsync (-v) flag which disables waiting for VSYNC when using accelerated rendering
    * Combine Jubatian's scanline optimization (fewer conditionals) with Uze's 720px wide render scaling trick with my arbitrary rescaling using a texture trick. It allows for arbitrary rescaling using both hardware and software renderers, while remaining fast on a 2.0 GHz Core 2.
    UZEM: Clean-up attempts over cycle-perfect emulation.
    
    The main change here is splitting up update_hardware into two parts, one to
    manage the cycle precise part, the other to manage the instruction precise
    part. The cycle precise part became entirely responsible for progressing the
    emulated cycle count.
    
    The elimination of various cycle counters (notably the "cycles" variable)
    made cycle counts more consistent, only relying on the count of calls made
    towards update_hardware. This may help implementing further cycle perfection
    changes like proper EEPROM access timing, or in general anything requiring
    extra cycles consumed in various parts of the emulator.
    
    Performance seems to remain the same as before (this is not so trivial to
    determine since avr8's exec function in the original code returned bogus
    cycle counts, missing cycles from various emulation stages).
    
    Newlines should be consistent Microsoft format in the changes.
    -Fixed TOV interrupt timing bug. Uzem is now cycle perfect.
    -Removed non-mega644 instruction in the instruction decoder
    -Removed unused SDL_Framerate
    UZEM: Some minor final touches on performance and commenting.
    
    A few rearrangements were carried out to clean up the major execution path a
    little for a minor performance bump. This involved Timer 1, the watchdog, and
    the pixel output.
    
    Several variable types were changed to native int for no noticable effect on
    performance, for some targets (such as Emscripten) it might matter.
    
    Comments were added describing a few components and their roles. Some TODO
    notes were also inserted where I suspected bugs or problems present from the
    original code.
    UZEM: Timer1's code was modified for performance.
    
    What was introduced is the calculation of time between events of Timer1, so
    update_hardware can get Timer1 done with a single comparison if it is still
    far from reaching the next compare or overflow event.
    
    The logic of Timer1 wasn't changed (except for a removal of a TCNT1 assignment
    from write_io, which is unnecessary since these 16 bit variables are only set
    up and used within the Timer1 logic). No bugs except from imperfections in the
    time between events calculation should appear.
    
    Note that with this, write_io necessarily has to clear the new timer1_next
    variable whenever it writes to a timer register under the code avoided by the
    new logic. For this, new cases had to be added for the OCR1A and OCR1B
    registers.
    UZEM: Moved the pixel output outer, in an inline function.
    
    The pixel output is performed about 2 - 3 million times a second in a Uzebox
    game, usually with a single cycle OUT instruction. The write_io function was
    split, so the pixel output could me moved out of it, into a small "header"
    function (which carried over the write_io name), which can be inlined,
    boosting pixel output.
    
    Also removed inline qualifiers from the read_sram_io and write_sram_io
    functions, they are used in 2 cycle instructions where function call overhead
    doesn't matter that much. This helps instruction cache a bit by making code
    notably smaller (and leaving inline for write_sram_io would have made it
    larger again due to the pixel output inline).
    UZEM: Attempting to create a clean cycle-perfect emulation solution.
    
    Mostly see added comments, they hopefully explain well how the code should
    work. Basically the previous hacks for cycle perfection were tidied up along
    with verifying that they don't cause instruction decoding interfering with
    interrupt entry. Effective behavior for cases tested so far should remain
    identical, while this general solution should solve other I/O related cycle
    perfection problems as well.
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -Added movie recording feature using ffmpeg piping
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    fixes
    done
    completed timing fix
    work on timers
    work on timing
    Uzem 1.3.1:
    -Fixed issue that prevented clean exit at command line under windows.
    -Added feature to capture/playback controller buttons
    -Added support for watchdog to support true random generator
    -fix for segfault under Linux when loading directory
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    uzem 1.19.1:
    -Bug fix: Initial seek was ignored
    -Bug fix: Can't read past 64k. FAT was not filled with cluster chain.
    -Changed cluster size to a more standard 32k
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Remove boost threads, and use SDL threads instead.
    Added a hack for visualizing SRAM/Progmem
    Added extra buffering of graphics, and added a seperate thread to update the display using the boost library. Also added Alec's fix for the aspect ratio.
    -Added OCR1B interrupt support required by kernel upgrade
    uzem:
    - v1.13
    - Better support for joysticks
    uzem:
    - Added support for joysticks
    - Updated makefile to make Windows default paths more common (hopefully)
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Uzem: Haiku support (#74)
    Fix Emscripten linker warnings, add NOGDB compile flag
    
    The recording feature was causing the Emscripen build to give multiple
    linker warnings, so I added:
    
     ...
    
    guards around the recording code, so none of the functions that can't be
    called from an Emscripen build are seen during the compile.
    
    I also added:
    
     ...
    
    guards around all of the code that deals with GDB, since it has two
    conditionals inside that get executed every emulated clock tick. If
    you are compiling using Emscripten:
    
    EMSCRIPTEN_BUILD=1 make release
    
    the Makefile will automatically set NOGDB=1 for you, or if you want to
    make a native build without GDB support (so it executes faster) you can
    set the flag manually using:
    
    NOGDB=1 make release
    
    when compiling.
    Fix Makefile so all OSes can take advantage of optimizations
    
    Includes:
     * link-time optimization
     * whole program optimization
     * optional program guided optimization (biggest performance gains)
    Fix Makefile so it doesn't break the Emscripten build
    Improve the SDL2 port
    
    * Fix screenshots so they are back to being 630x448, rather than 720x224.
    * Add new feature so pressing shift while taking a screenshot gives you a 240x224 bitmap.
    * Fix fullscreen mode so it changes the resolution of the monitor and makes fullscreen fast again on slower computers.
    * Add --swrenderer (-w) flag which will force SDL to use software rendering
    * Add --novsync (-v) flag which disables waiting for VSYNC when using accelerated rendering
    * Combine Jubatian's scanline optimization (fewer conditionals) with Uze's 720px wide render scaling trick with my arbitrary rescaling using a texture trick. It allows for arbitrary rescaling using both hardware and software renderers, while remaining fast on a 2.0 GHz Core 2.
    Add (optional) Emscripten support by setting a flag in the Makefile
    UZEM: Merged in the rearranged CPU instruction decoder switch tree.
    
    Important:
    
    It seems like there are bugs in the instruction timing calculations, see
    the TODO comments. There may be more locations of interest! For now I only
    attempted to merge as-is, not attempting to fix these, just adding a few
    comments here and there to note where the location of the cycles variable
    is important.
    fixed build
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    work on timing
    -Uzem Fix:Added back winodw icon
    -v1.3:Fixed framerate issue (now 60hz) and small optimizations
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Remove boost threads, and use SDL threads instead.
    Added extra buffering of graphics, and added a seperate thread to update the display using the boost library. Also added Alec's fix for the aspect ratio.
    -Added OCR1B interrupt support required by kernel upgrade
    uzem:
    - v1.13
    - Better support for joysticks
    uzem:
    - Added support for joysticks
    - Updated makefile to make Windows default paths more common (hopefully)
    -Fixed eeprom loading bug and re-enabled read/write by default. (was disabled)
    Renamed makefile to Makefile to keep the standard
    Second part of the DEST_DIR flag.
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Modify source so it is C++14 compatible
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    fixed build
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -Added PORTIOs to uzebox linkscript
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    Fix all warnings except the sign comparison ones.
    
    This allows Uzem to be properly built using clang++ rather than g++,
    which allow games that use the SD card to run properly when built for
    the web using Emscripten.
    -Added preliminary support for keyboard
    -Added string.h import in SDEmulator.h to fix compile issues under Linux
    -Got rid of warning: deprecated conversion from string constant to ‘char*’
    uzem 1.19.1:
    -Bug fix: Initial seek was ignored
    -Bug fix: Can't read past 64k. FAT was not filled with cluster chain.
    -Changed cluster size to a more standard 32k
    -Uzem v1.19
    -New:If no SD image path specified, mounts the HEX's file path
    -Completed the SD emulation, fixed bugs and improved performance
    -Implemented missing SD functions to support PetitFatFS
    -Bug fixes
    Fixed bug in thread code which stopped uzem from working on windows. Added SD card emulation from any directory. Tested on Mac OS X & Windows XP.
    Added p2m (polyphonic to monophonic) MIDI tool
    
    This is an open-source python tool (not written by me) that converts a
    midi file containing a polyphonic track into a multitrack one (one voice
    per track).
    
    This is very useful if you've recorded a Uzebox track using a MIDI
    keyboard and you pressed multiple keys at once. Just use the same
    instrument for the multiple channels, and now you can fake a bit of
    polyphony support on the Uzebox.
    Added p2m (polyphonic to monophonic) MIDI tool
    
    This is an open-source python tool (not written by me) that converts a
    midi file containing a polyphonic track into a multitrack one (one voice
    per track).
    
    This is very useful if you've recorded a Uzebox track using a MIDI
    keyboard and you pressed multiple keys at once. Just use the same
    instrument for the multiple channels, and now you can fake a bit of
    polyphony support on the Uzebox.
    Added p2m (polyphonic to monophonic) MIDI tool
    
    This is an open-source python tool (not written by me) that converts a
    midi file containing a polyphonic track into a multitrack one (one voice
    per track).
    
    This is very useful if you've recorded a Uzebox track using a MIDI
    keyboard and you pressed multiple keys at once. Just use the same
    instrument for the multiple channels, and now you can fake a bit of
    polyphony support on the Uzebox.
    Added p2m (polyphonic to monophonic) MIDI tool
    
    This is an open-source python tool (not written by me) that converts a
    midi file containing a polyphonic track into a multitrack one (one voice
    per track).
    
    This is very useful if you've recorded a Uzebox track using a MIDI
    keyboard and you pressed multiple keys at once. Just use the same
    instrument for the multiple channels, and now you can fake a bit of
    polyphony support on the Uzebox.
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    work
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -Mode 9: Added feature to set background color for each character line
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Port Uzem to SDL2, and fix outstanding bugs that prevent it from compiling on Linux
    
    It includes the following general bugfixes:
    
      * Fix for undefined behavior (and uninitialized) bug in
        tools/gconvert/lodepng.cpp
    
      * Adds missing tools/gconvert/paletteTable.h file so gconvert will
        compile
    
      * Fix for "consider adding parenthesis warning" in
        tools/gconvert/tinyxmlparser.cpp
    
      * Remove strlwr() since it causes ROMS with mixed case to give "not
        found" errors on case sensitive filesystems (Linux). Instead, it
        checks for both upper and lower case extensions.
    
      * Zero uzebox.captureFile after closing it when reading the capture
        file so fclose() doesn't get called twice in shutdown() causing a
        segfault on Linux.
    
      * Conditionalize Windows-only code, so uzem can be compiled on
        Linux.
    
      * Finish removing the unused SDL_framerate class
    
      * Add missing #include <stdio.h> to gdbserver.h so it compiles on
        Linux now that the SDL_framerate class is totally gone[/list]
    
    For the SDL2 Port:
    
      * Change keyboard scancodes type and constants to SDL2 compatible in
        uzem/Keyboard.h and avr8.cpp
    
      * Fix Makefile so it uses SDL2, and no longer compiles
        SDL_framerate.cpp
    
      * avr8.h - Change include files to SDL2, and initialize the ring
        buffer with silence, since SDL2 does not initialize the audio
        buffer anymore (fixes sound glitch on startup). Remove the
        undefined sdl_flags, since SDL doesn't have those anymore. Remove
        SDL_EnableKeyRepeat since it no longer exists in SDL2 (it's the
        default behavior).
    
      * Modify rendering code so it renders into a 640x240 chunk of memory
        (much faster!) and change recording parameters to compensate for
        the different aspect ratio, so it still records at 720p with the
        proper aspect ratio.
    
      * Fullscreen mode no longer switches the mode of the monitor,
        instead it makes a fullscreen window and uses the GPU to scale the
        image.
    
      * Ported Joystick code over, removing the functions that don't exist
        on SDL2 anymore. According to the documentation, if the joystick
        is not opened, its handle will be null.
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Gconvert version bump to 1.7 for mega-map support. (#80)
    
    * Bumped version number of gconvert for mega-map release
    Megatiles (#60)
    
    * Initial WIP commit for mega tile support in gconvert
    
    * Fixed mega tile extraction algorithm
    
    * Fixed width and height printed values for mega map child maps
    
    * Improved white spacing in map output
    Modify source so it is C++14 compatible
    -Added support for custom defines that points to static tile locations in the tileset
    gconvert: Tile defines
    -Added function IsPowerSwitchPressed()
    -Fixed uzem power switch emulation
    -Fixed Maze to support power switch and added true random
    -Gconvert 1.5: added support to keep duplicate tiles
    work on timers
    -Changes to mode 9 to support variable SCREEN_TILES_H
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Fix: Mode 2 : SetTileTable() now sets screen section[0].
    -Mode3: Added split screen when using scrolling.
    -Fix: Added check in gconvert to insure picture size are integer multiples of the specified tile size
    -Update to Mode3 with scrolling: New VRAM memory arrangement frees cycles in HSYNC. This allows use of inline sound mixer to recover ~500b of RAM and many cyles in VSYNC.
    -Updated mario demo to support mode3 update
    -Added 1bpp convertion mode to gconvert
    -Mode 9: Added feature to set background color for each character line
    updated gconvert to support code tiles export (currently only support 6x8) tiles
    -Fixed bug that crashed the program if no maps are defined
    added licence to gconvert.cpp
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Second part of the DEST_DIR flag.
    Uzem:
    -Some parameters were inverted and missing from 'shortopts'
    -Fixed bug in loadUzeImage() introduced in the last version. Now loading '.uze' files is working again.
    -Windows related changes:
            g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
            Add .exe when defining TARGET_NAME to avoid linking again if nothing changed and to fix 'make clean'
            SDL setup sucks:
                Using SDL_BASE to define libSDL directory and coping SDL.dll to Uzem dir during compilation.
                LDFLAGS += -lmingw32 -lSDLmain -lSDL #keeping in this order is important
    Packrom:
    -g++ from MinGW doesn't support "native" (must be >= GCC-4.2). Removing the default ARCH value.
    Created bin directory
    Created main Makefile to build all tools and demos
    Packrom:
    - Directory renamed from rompacker to packrom to match the application name
    - Created a Makefile
    - Removed the dirs: Debug and Release from rompacker (those are generated in compile time)
    - Fixes to remove all warnings
    - Fixed buffer overflow (using strcpy an extra '\0' is added at the end, but marker[] is 6 bytes long only):
            -       strcpy((char*)rom.header.marker,"UZEBOX");
            +       memcpy(rom.header.marker,"UZEBOX",MARKER_SIZE);
    Uzem:
    - Directory renamed from emulator to uzem to match the application name
    Demos:
    - Some files renamed because to avoid case-sensitive problems
    - Some Makefiles fixed about case-sensitive issues too
    - Added gameinfo.properties to DrMario
    - Added gameinfo.properties to SpriteDemos and added packrom rules
    - Added the packrom path for all demo's Makefiles
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Fixed gconvert XSD sequence ordering and spelling mistake (#95)
    
    * Moved sequence to the top of the complex type where it belongs, otherwise the XSD is invalid
    
    * Fixed 'mega-maps' to 'mega-map'
    Megatiles (#60)
    
    * Initial WIP commit for mega tile support in gconvert
    
    * Fixed mega tile extraction algorithm
    
    * Fixed width and height printed values for mega map child maps
    
    * Improved white spacing in map output
    -Mode 9: Added feature to set background color for each character line
    Put gconvert schema under version control
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    Streaming Music Fixed (#92)
    
    * Added SPIRamMusicDemo
    
    * Initial commit for streaming music(fixed)
    
    * Simultaneous music and PCM streaming
    
    * Delete compressedsong.inc
    
    * Simultaneous music and PCM streaming
    
    * Create README.txt
    
    * Create README.txt
    
    * Initial commit for dconvert
    
    * Initial commit for mconvert
    
    * Fix for streaming music
    
    * Delete SD_MUSIC.DAT
    
    * Fixes for streaming music
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    added PackRomGUI tool
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    -Fixed palette file and color tables images to reflect current DAC design.
    -Cleaned up Java tools
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add support for NOTE_OFF commands (0x80 with vol 64) to MidiConv
    
    There are multiple ways to specify a MIDI note off, previously the only
    one supported by MidiConv was a NOTE_ON command with a volume of 0, and
    that is also the only thing that the Uzebox kernel supports.
    
    This change simply transforms any ShortMessage.NOTE_OFF commands found
    in the MIDI stream to ShortMessage.NOTE_ON commands with a volume of 0
    before converting them into the Uzebox format, so MIDIs exported by
    Rosegarden (an open source MIDI sequencer for Linux) are compatible with
    the note off command line flags supported in MidiConv.
    
    This change also adds a powerful MIDI debugging aid named MessageInfo
    (written by IBM), to MidiConv, which is what I used to figure out why my
    NOTE_OFF commands had been getting ignored. To enable it, all you need to
    do is to set the log4j log level from OFF to DEBUG.
    Add MIDI type 1 support to the MidiConv tool.
    
    The existing uzetools.jar file does not match its source code (and can not be built
    with the existing source code!) so I built a new jar file called MidiConv.jar that
    only contains the modified MIDI converter tool.
    
    Example Usage:
    
    java -cp ~/uzebox/tools/JavaTools/dist/MidiConv.jar org.uzebox.tools.converters.midi.MidiConvert -f 8 midisong.mid midisong.h
    
    where midisong.mid may be a type 0 MIDI file, or a type 1 MIDI file.
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    Kernel "upgrade":
    -Implemented inline mixer: mixes during HSYNC (recovers 512 bytes of RAM)
    -Added a 5th channel of type PCM when using the inline mixer
    -optimized the VSYNC code to recover ~3 scanlines of CPU
    -Reduced kernel size by about 350 bytes
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    Bug fix: Conversion would fail if -e & -s switches were not present.
    replaced trunk with code from beta5 branch
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add support for NOTE_OFF commands (0x80 with vol 64) to MidiConv
    
    There are multiple ways to specify a MIDI note off, previously the only
    one supported by MidiConv was a NOTE_ON command with a volume of 0, and
    that is also the only thing that the Uzebox kernel supports.
    
    This change simply transforms any ShortMessage.NOTE_OFF commands found
    in the MIDI stream to ShortMessage.NOTE_ON commands with a volume of 0
    before converting them into the Uzebox format, so MIDIs exported by
    Rosegarden (an open source MIDI sequencer for Linux) are compatible with
    the note off command line flags supported in MidiConv.
    
    This change also adds a powerful MIDI debugging aid named MessageInfo
    (written by IBM), to MidiConv, which is what I used to figure out why my
    NOTE_OFF commands had been getting ignored. To enable it, all you need to
    do is to set the log4j log level from OFF to DEBUG.
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Merged mode 13 in mode 9
    -Updated gconvert to generate 60 and 80 columns code tiles.inc
    -Fixed bugs in MOD engine
    -Deprecated DrawMap2()
    -Added Module converter Java tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Add missing TileMap.java to src tree so uzetools.jar can be completely rebuilt
    
    Now that the entire uzetools.jar package can be rebuilt, the standalone
    MidiConv.jar (that just contained the MIDI stuff) is no longer
    necessary, and the uzetools.jar package has been updated to contain all
    of the new MIDI enhancements that were recently added (support for type
    1 MIDI files, and NOTE_OFF support).
    -Audio conversion tool package refactoring
    -Added MOD conversion tool (beta)
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Added WIP version of the uzenet server. It is currently able to register users and send info about waiting games
    Added WIP version of the uzenet server. It is currently able to register users and send info about waiting games
    -added gconvert tool to convert images to tilesets and maps
    -updated Megatris Makefile to use gconvert (see project for example)
    -renamed UzeboxTools to JavaTools
    replaced trunk with code from beta5 branch
    Added WIP version of the uzenet server. It is currently able to register users and send info about waiting games
    replaced trunk with code from beta5 branch
    Added WIP version of the uzenet server. It is currently able to register users and send info about waiting games
