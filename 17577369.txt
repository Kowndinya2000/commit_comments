    Fixed termination order of chkpt and recovery
    Set --std=c++14
    
    - Y'all better update yo compilers
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Set std=c++11 and cleaned up some fc files
    Enabled parent cb pointer on buffer
    
    - Control blocks used to hold a pointer to the parent when swizzling is
    activated. I turned this back on with the BP_MAINTAIN_PARENT_PTR flag.
    - My goal is to use the parent pointer on the new eviction algorithm.
    - Also commented out all stuff related to the swizzled_lru list.
    Small improvements to debug features
    
    - Added shorter macros DBG1, DBG3, and DBG5
    - Added some info when printing out checkpoint log records
    - Tweaked CMake options for debug
    New build types for cmake
    
    - Enabling access to debug levels 1, 3, and 5
    - Added profiling build to use with gprof
    CMake non-verbose by default
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Removed deleted (purged with filter-branch) folders from CMakeLists.txt
    Added compilation command generation to cmake (for my IDE setup)
    make file -Og for retail and -O0 for debug, because -Og might not work for some versions of gcc in debug build, but it works for retail build
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Disabled tcmalloc
    NUMA pinning for TPCC
    Added Google-test 1.7 and google cpplint
    use tcmalloc if exists
    deleted more files.
    dropping solaris support
    remove -Werror. It's impossible to keep supporting in multiple environments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    scripts and tools used for techcon 2014 NVRAM submission
    trying to integrate w/build; need missing figures
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    Fix up CmakeLists for gcc warnings levels
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Addressed Harumi's/Alvin's comments:
    -Used LINTEL_REQUIRED_HEADER so that it won't fail silently if MUTrace is not there
    -Replace HAVE_MUTRACE_PROFILER_H with MUTRACE_ENABLED_H
    Flag to build Zero with MUtrace support
    swizzling experiments: implemented bursty workload and fixed sliding window workload to slide at a fixed rate
    Generate improved documentation. Fixes ZERO-135.
    (1) Fixed race in TATAS implementation. (2) Scripts to run a mixed workload
    Facility to limit physical memory consumed by a process
    Changes for benchmark build
    
    Changed cmakelists.txt such that inlining works better (less debugging/asserts)
    Removed unneeded wrok from bf_tree_inline.h
    
    pin.h, scan.cpp, sm.h, and smfile.cpp got fixes to supress warnings in stubbed functions.
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    fixed things so that doxygen works with cmake
    removed some obsolete options from Doxyfile.cmake
    fixed a doxygen comment in src/sthread/srwlock.h with an unbalanced
      quote, which was causing doxygen to crash because of a doxygen bug
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Add support for controlling location of log dir via a program option
      * Fix bug in mmap code that was resulting in unmapping pages that were not
        owned by the code, potentially unmapping thread code and stack pages leading
        to segmentation faults.
    
    CMakeLists.txt: find lintel
    
    experiments/CMakeLists.txt: include lintel, define experiment libraries variable
    
    experiments/*/CMakeLists.txt: link with standard set of experiment libraries
    
    experiments.h: add program option
    
    select_only.cpp: use program option
    
    dynarray.cpp: fix bug by not subtracting MM_PAGE_SIZE from align; if align == MM_PAGE_SIZE this
      results in additional alignment of 0, but kernel may mis-align by actual page size.  Also error
      out on mmap/munmap failures (thought this was the problem, it wasn't, but many callers aren't
      checking the return code)
    Zero branch from subversion rev 11038
    Update README.md
    Update README.md
    Update README.md
    Updated README with boost version on dependencies
    Updated README file
    New README with deptool-independent build instructions
    refactoring w_rc_t
    Patch to make make doc work
    OKVL terminology change and optimizations
    Adding INPUT back in (without cmake).
    Commented out lines that refer to @PROJECT_SOURCE_DIR@ for now while attempting
    to debug doxygen on jenkins server.
    Generate improved documentation. Fixes ZERO-135.
    Changes to documentation build, to generate fuller documentation.
    Fixes issue JIRA-135
    added module owner file
    Update top-level copyright notice to include HP copyright, remove
    reference to Solaris license (code is no longer present)
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Implement atomic_ops in terms of lintel::Atomic<>.
    This 99% removes atomoc_ops directory. A bit is still temporarily left as physical, but not logical, artifact).
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Fixes so that we can do a complete out of tree build.  Also
      other minor improvements.
    
    {examples,experiments,src/**,tests}/CMakeLists.txt: auto-generated file include paths
       Generate files in the binary directory only, and only generate them once rather
       than N different custom commands.
    
    experiments/experiments.h: move log/data stuff to /dev/shm
    
    experiments/random_inserts/select_only.cpp: improve usage message
    
    src/sthread/srwlock.cpp: add { } to eliminate compiler warning
    Zero branch from subversion rev 11038
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Including a webserver into zero
    Here are included the first classes to start a simple webserver with
    commands zapps. The webserver has an object kits, which allows the
    webserver to start kits benchmarks.
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Moved boost linker flags to sm target
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Webserver now able to receive benchmark parameters
    - Adding some changes regarding variables to respect singleton pattern.
    Web server: Adding the option to choose the port to run the webserver.
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Including a webserver into zero
    Here are included the first classes to start a simple webserver with
    commands zapps. The webserver has an object kits, which allows the
    webserver to start kits benchmarks.
    Added page counts to redo progress in web server
    Implemented thread-based, non-cumulative stats
    Implemented undo progress and fixed restore progress
    Redesigned stat collection mechanism in web server
    WS uses boost parse_config_file instead of parse_command_line
    Fixed kits life cycle in webserver
    Webserver: tracking media recovery progress
    Webserver: Tracking current status of redo and log analysis.
    Webserver now able to receive benchmark parameters
    - Adding some changes regarding variables to respect singleton pattern.
    Webserver: Removing favicon
    Webserver: Now webserver reads post messages
    The post messages should have the format  key : value and separated by comma
    Webserver: Adding single root page failure
    There is a new routine in the webserver API, which changes the LSN of a root page to 1,0. Such change makes the page invalid so it should be recovered by the system.
    Webserver: adding media failure option.
    Webserver: Adding option to crash the database
    Webserver: Fix bug. The function, which verifies if the database is executing or not, responded as not running during the load time.
    Webserver: command kits is recreated in order to allow the system to run the benchmarks multiple times over one execution of the system.
    Webserver: creating a call, which returns all counters (agglog and stats) from the system in only one json reply
    Webserver: Adding JSON call to verify if Kits is running
    WEBSERVER: JSON response with counters
    The system prepares a JSON response with the counters in every second
    that the benchmark is running. This response is prepared by a thread
    that starts together with the benchmark and makes a call to the method
    gatherstats_sm every second.
    Adding command agglog to webserver
    Now, after start a benchmark, the webserver returns JSON calls with the
    results of the agglog command.
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Including a webserver into zero
    Here are included the first classes to start a simple webserver with
    commands zapps. The webserver has an object kits, which allows the
    webserver to start kits benchmarks.
    Fixed webserver bug
    Added page counts to redo progress in web server
    Fixed stats
    Implemented thread-based, non-cumulative stats
    Added a third state to the system: initializing
    Implemented undo progress and fixed restore progress
    Redesigned stat collection mechanism in web server
    Fixed redo progress
    Fixed counter generation in web server
    More bugfixes in web server
    Small bugfix in web server
    WS uses boost parse_config_file instead of parse_command_line
    Removed warnings and small fixes
    Fixed kits life cycle in webserver
    Webserver: separating calls to restart progress and media recovery progress
    Webserver: tracking media recovery progress
    Webserver: Tracking current status of redo and log analysis.
    Webserver now able to receive benchmark parameters
    - Adding some changes regarding variables to respect singleton pattern.
    Webserver: Removing favicon
    Webserver: Now webserver reads post messages
    The post messages should have the format  key : value and separated by comma
    Webserver: Adding single root page failure
    There is a new routine in the webserver API, which changes the LSN of a root page to 1,0. Such change makes the page invalid so it should be recovered by the system.
    Webserver: adding media failure option.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Webserver: Adding a new option 'no_stop' to run benchmarks. This option is used to run a benchmark with no limit of time, transactions, or log size. The only way to stop the benchmark is by calling the function set_stop_benchmark(true) from kits_cmd. Webserver was updated with this option.
    Webserver: Adding option to crash the database
    Webserver: Fix bug. The function, which verifies if the database is executing or not, responded as not running during the load time.
    Webserver: command kits is recreated in order to allow the system to run the benchmarks multiple times over one execution of the system.
    Webserver: creating a call, which returns all counters (agglog and stats) from the system in only one json reply
    Webserver: Adding JSON call to verify if Kits is running
    WEBSERVER: JSON response with counters
    The system prepares a JSON response with the counters in every second
    that the benchmark is running. This response is prepared by a thread
    that starts together with the benchmark and makes a call to the method
    gatherstats_sm every second.
    Adding command agglog to webserver
    Now, after start a benchmark, the webserver returns JSON calls with the
    results of the agglog command.
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Including a webserver into zero
    Here are included the first classes to start a simple webserver with
    commands zapps. The webserver has an object kits, which allows the
    webserver to start kits benchmarks.
    Replaced uses of ArchiveScanner with new ArchiveScan
    Added --pid option to scanner.cpp
    Some assertions and new default values for log archiver
    Updated zapps scanner and genarchive command
    Small update in zapps MergeScanner
    Removed readSize parameter from ArchiveScanner::open
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Renamed RunFileStats to RunId
    Using shared_ptr to manage archive scans
    Unified classes ArchiveIndex and ArchiveDirectory
    Fixed zapps log scanner for multi-level archive
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved nested classes out of LogArchiver
    Cleaning up some compiler warnings
    Implemented multi-level log archive
    Added level number to log archive run file name
    Removed more headers, fixing their previous uses
    Updated scanner and verifylog components
    Removed option sm_archive_block_size
    
    - Log archived currently only supports a fixed block size (for some
    reason I can't remember), so it does not make sense to offer such
    option. Removing it to avoid any future frustrations.
    Using boost filesystem in log archiver directory
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Removed class ErrLog and replaced its uses with std::cerr
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation on gcc 4.9
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added --pid option to scanner.cpp
    Fixed zapps log scanner for multi-level archive
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added --pid option to scanner.cpp
    Fixed zapps log scanner for multi-level archive
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed group commit default options
    Removed page-img-logrec nonsense from decoupled cleaner
    Decoupled cleaner optimization with page-img log records
    Lightweight propstats using chkpt data
    Made cleanee more flexible with attempt-based triggers
    Added option sm_eviction_interval
    Added --pid option to scanner.cpp
    Added NoDBGen command
    
    - Generates log containing page-image log records of all pages in a
    database file
    Added fetch_page log records for debugging
    Implemented random pick_vitcim and optional used of clock
    Logging page evictions for debug
    Print txn. tput directly to a file in ticker thread (no log scans)
    Added option to flush dirty pages on eviction
    Chkpt considers archived LSN to compute min_rec_lsn w/o nodb mode
    Fixed deafult value of archiver bucket size
    Cleaner now has both async (dedicated thread) and sync (on-demand) modes
    Using shared_ptr to manage cleaner and evictioner
    Fixed default value of group commit timer
    Buffer-pool warm-up now configurable with sm options
    
    - Also starting background recovery in instant restart only after
    warm-up
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Brought back traditional fuzzy checkpoints
    Added LogrecInfo command
    Correct recovery of dirty pages in nodb mode
    Generating benchmark_start log record on SM constructor
    Added direct I/O options for log archive and log
    Added option for store clustering
    
    - Also fixed metadata initialization without clustering.
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Forgot to add kits option for warmup batch size
    Cleaner tolerates invalid parent in some cases
    
    - Added write elision option
    - If write elision is on and pointer is unswizzled, page cleaner is now
    free to evict page without a valid parent pointer
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Simple group commit implementation
    Added run recycler thread
    Fixed zapps log scanner for multi-level archive
    Fixed archive merging and implemented merger daemon
    Added (yet unused) option chkpt_only_root_pages
    
    - It's not as easy as I thought to keep track of root pages only in
    checkpoints, so I abandoned the project but left the option here for the
    future.
    Added prioritize_archive option on vol_t
    
    - also deleted method restart_m::recover_single_page, since SprIterator
    is really easy to use and the method was only called from
    vol_t::read_page_verify
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed old tests and commands that used sthread IO
    Added loginspect command tracerestore
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Removed option sm_archive_block_size
    
    - Log archived currently only supports a fixed block size (for some
    reason I can't remember), so it does not make sense to offer such
    option. Removing it to avoid any future frustrations.
    Added loginspect command to print average xct latency
    Options to truncate log archive and run benchmark for a given log volume
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Supporting restore simulation in kits, obsoleting restore_cmd
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Including a webserver into zero
    Here are included the first classes to start a simple webserver with
    commands zapps. The webserver has an object kits, which allows the
    webserver to start kits benchmarks.
    Restore: removed faulty assertion and changed default arguments
    Fixed asynchronous candidate collection in cleaner
    
    - Separate thread can collect candidates asynchronously while other
    frames (collected in a previous invocation) are cleaned
    - Added option to activate this behavior
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Added support for metadata pages to bf_tree_cleaner
    
    - If parameter sm_cleaner_ignore_metadata is false, each cleaner round
    will also flush dirty alloc and stnode pages.
    Added delete_old_partitions option to log_storage
    Added cleaner option to only write large clusters of pages
    
    - Requires new logic in the bf_tree_cleaner::clean_candidates loop
    - Also added timer stats for cleaner
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Added command to extract propagation stats from log
    
    - Propagation stats a.k.a. recovery backlog
    - Counts number of dirty pages and REDO length for each tick on the log
    Cleaner refactoring IV: policy infrastructure
    
    - Added functionality to parametrize candidate selection in the cleaner
    according to a policy, which so far includes a type (enum class
    cleaner_policy) and a number of candidates to select (num_candidates)
    Added best-effort partition recycling mechanism
    
    - Support for sm_log_max_partitions options, which limits the number of
    partition files in the log directory. At each partition creation, old
    partitions are deleted proactively. If the limit is reached, a forced
    deletion is attempted, but it only works if the min active LSN collected
    on the last checkpoint allow it -- hence the best-effort approach.
    - A true recycling mechanism is only possible with log reservations,
    which we removed because they were messy and not fully effective
    (required "fudge factors").
    Parametrizing use of O_DIRECT in vol_t
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Removed size arguments from kits_cmd
    
    - All size arguments passed directly as sm_* options, most of which in
    MB
    Implemented new log read buffer for log_core::fetch
    
    - Buffers a certain number of log partitions, starting from the latest
    one backwards.
    - Asynchronous thread loads buffer in chunks of 32MB in reverse
    chronological order.
    - log_core keeps track of LSN range already buffered and get log record
    from buffers in case of a hit.
    - Since a big sequential LSN range is what is buffered, a pair of
    variables suffices and there is no need to track individual log pages
    with a hash table. Given the pattern of log reads during restart
    recovery, this mechanism is also quite effective.
    - Also moved log analysis log record inside init method, so that we
    also count the buffer initialization as startup time in the experiments.
    Added chkpt_interval option to command.cpp
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Added options to log page reads and writes
    Supporting read-only mode in vol_t
    
    - Write-page calls are simply ignored, meaning that write elision and
    single-page recovery are required for correct behavior.
    Fixed option sm_logsize
    
    - Now given in MB rather than KB
    - Removed redundant --logsize in kits
    Added some command options
    Introducing page_cleaner_base generic class
    
    - virtual class for page cleaner (bf_tree_cleaner now inherits from this class)
    - join_cleaner(timeout_t) replaced for simple join(), since timeout_t seems not to be working anymore
    - request_stop_cleaner() and join() unified into new shutdown() method
    - take_interval() and interval_millisec_min/max removed. Cleaner now wakes up every fixed time and clean pages, even if no implicit request was made
    Fixed some restart bugs & general clean-up
    Added loganalysis command
    
    - .. which performs log analysis and prints out results, also comparing
    the list of active transactions with one obtained from a full log scan
    for validation purposes.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Small bugfix in zapps basethread_t
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed class ErrLog and replaced its uses with std::cerr
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Oct 2014 fix from Ryan Johnson on Shore-Kits
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Whitespace changes
    Removed w_stream stuff
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved stop_benchmark from global to ShoreEnv
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Webserver: Adding a new option 'no_stop' to run benchmarks. This option is used to run a benchmark with no limit of time, transactions, or log size. The only way to stop the benchmark is by calling the function set_stop_benchmark(true) from kits_cmd. Webserver was updated with this option.
    Options to truncate log archive and run benchmark for a given log volume
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Fixed compilation errors in gcc6
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Trying to make smthread_t fully static (huge commit from hell)
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed db_fetch warmup and index scan bug
    Revert "Minor fixes to kits scanner and btcursor"
    
    This reverts commit ce06fb17c6b1bfaa32de1f92055798c367893483.
    Minor fixes to kits scanner and btcursor
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Simplified kits "skewer" and implemented shifting skew
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Removed unused CPU-core binding from Kits
    Removed old restore usage in vol_t
    Simplified kits "skewer" and implemented shifting skew
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Kits now supports crash and recovery in the same execution
    
    - Also implemented wait for warmup
    Implemented undo progress and fixed restore progress
    Various bugfixes
    Fixed redo progress
    Removed warning from kits shutdown
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Moved stop_benchmark from global to ShoreEnv
    Replaced restart_m with restart_thread_t
    Webserver: tracking media recovery progress
    Webserver: Tracking current status of redo and log analysis.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Fixed initialization of sm_options in kits_cmd
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed 1thread mutex and xct dependency list
    Moved latch/mutex stuff out of sthread files
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Fixed compilation errors in gcc6
    Removed old RestoreCmd
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Trying to make smthread_t fully static (huge commit from hell)
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Simplified kits "skewer" and implemented shifting skew
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation errors in gcc6
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Removed unused CPU-core binding from Kits
    asyncCommit now true by default
    Kits not disabling eager archiving during restore
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Kits using new restore (commented old one in vol_t)
    Simplified kits "skewer" and implemented shifting skew
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Fixed kits skew option
    Small update on kits_cmd
    Kits crash delay starts counting before sm initialization
    Kits now supports crash and recovery in the same execution
    
    - Also implemented wait for warmup
    Fixed restore shutdown
    
    - Some parts of the code were still waiting for restore to finish
    Moved stop_benchmark from global to ShoreEnv
    Webserver: Adding single root page failure
    There is a new routine in the webserver API, which changes the LSN of a root page to 1,0. Such change makes the page invalid so it should be recovered by the system.
    Webserver: adding media failure option.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Added asyncCommit option to Kits client threads
    Webserver: Adding a new option 'no_stop' to run benchmarks. This option is used to run a benchmark with no limit of time, transactions, or log size. The only way to stop the benchmark is by calling the function set_stop_benchmark(true) from kits_cmd. Webserver was updated with this option.
    Webserver: Adding option to crash the database
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Fixed initialization of sm_options in kits_cmd
    Fixed db_fetch warmup and index scan bug
    Performing kits warmup using db_fetch instead of WarmupThread
    WEBSERVER: JSON response with counters
    The system prepares a JSON response with the counters in every second
    that the benchmark is running. This response is prepared by a thread
    that starts together with the benchmark and makes a call to the method
    gatherstats_sm every second.
    Simmplified Kits warmup to simply run WarmupThread instead of benchmark
    Options to truncate log archive and run benchmark for a given log volume
    Supporting restore simulation in kits, obsoleting restore_cmd
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Updated application tools: kits, propstats, and stress_cleaner
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Unified all truncate/reformat options into single sm_format
    Removed size arguments from kits_cmd
    
    - All size arguments passed directly as sm_* options, most of which in
    MB
    Fixed crashDelay sleeping time
    
    - Function sleep of sthread_t uses milliseconds, while standard
    library's ::sleep uses seconds.
    Added crashDelay option to kits
    
    - Thread is forked and calls abort() after the given number of seconds
    Fixed option sm_logsize
    
    - Now given in MB rather than KB
    - Removed redundant --logsize in kits
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Moved stop_benchmark from global to ShoreEnv
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Webserver: Adding a new option 'no_stop' to run benchmarks. This option is used to run a benchmark with no limit of time, transactions, or log size. The only way to stop the benchmark is by calling the function set_stop_benchmark(true) from kits_cmd. Webserver was updated with this option.
    Options to truncate log archive and run benchmark for a given log volume
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Simplified kits "skewer" and implemented shifting skew
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Kits now supports crash and recovery in the same execution
    
    - Also implemented wait for warmup
    Implemented undo progress and fixed restore progress
    Fixed redo progress
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Moved stop_benchmark from global to ShoreEnv
    Webserver: tracking media recovery progress
    Webserver: Tracking current status of redo and log analysis.
    Webserver: Adding single root page failure
    There is a new routine in the webserver API, which changes the LSN of a root page to 1,0. Such change makes the page invalid so it should be recovered by the system.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Fixed initialization of sm_options in kits_cmd
    Performing kits warmup using db_fetch instead of WarmupThread
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Simplified kits "skewer" and implemented shifting skew
    Kits crash delay starts counting before sm initialization
    Kits now supports crash and recovery in the same execution
    
    - Also implemented wait for warmup
    Moved stop_benchmark from global to ShoreEnv
    Webserver: Adding single root page failure
    There is a new routine in the webserver API, which changes the LSN of a root page to 1,0. Such change makes the page invalid so it should be recovered by the system.
    Webserver: adding media failure option.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Added asyncCommit option to Kits client threads
    Webserver: Adding a new option 'no_stop' to run benchmarks. This option is used to run a benchmark with no limit of time, transactions, or log size. The only way to stop the benchmark is by calling the function set_stop_benchmark(true) from kits_cmd. Webserver was updated with this option.
    Webserver: Adding option to crash the database
    WEBSERVER: JSON response with counters
    The system prepares a JSON response with the counters in every second
    that the benchmark is running. This response is prepared by a thread
    that starts together with the benchmark and makes a call to the method
    gatherstats_sm every second.
    Options to truncate log archive and run benchmark for a given log volume
    Supporting restore simulation in kits, obsoleting restore_cmd
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Removed size arguments from kits_cmd
    
    - All size arguments passed directly as sm_* options, most of which in
    MB
    Added crashDelay option to kits
    
    - Thread is forked and calls abort() after the given number of seconds
    Fixed option sm_logsize
    
    - Now given in MB rather than KB
    - Removed redundant --logsize in kits
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed 1thread mutex and xct dependency list
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed assert from tpcb that breaks the program when the benchmark is executed more than once without finish the program. Executed some tests and it does not seem to interfer with the system behavior.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed db_fetch warmup and index scan bug
    Performing kits warmup using db_fetch instead of WarmupThread
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Simplified kits "skewer" and implemented shifting skew
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Simplified kits "skewer" and implemented shifting skew
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed kits skew option
    Removed rand48.{h,cpp}
    Small changes to TPC-C transaction
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Removed unused CPU-core binding from Kits
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Spreading warehouses over threads in kits
    
    - New spread implementation allows threads to be assigned to a fixed set
    of warehouses, aallowing different skew configurations while eliminating
    lock contention.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Simplified kits "skewer" and implemented shifting skew
    Performing kits warmup using db_fetch instead of WarmupThread
    Fixed bug with unit distribution in TPCC loader
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Simplified kits "skewer" and implemented shifting skew
    Performing kits warmup using db_fetch instead of WarmupThread
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed order of key fields in TPCC history table
    
    - Timestamp should come first, otherwise every insert is random and
    highly likely to cause a page miss.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Implemented YCSB benchmark on Kits
    Fixed STUPID bug with key generation in YCSB
    Compilation fix for YCSB
    Fixed bug on YCSB key generation
    Implemented YCSB benchmark on Kits
    Implemented YCSB benchmark on Kits
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Fixed compilation errors in gcc6
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Fixed adding backups
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Replaced log "stub" calls with generic Logger
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Added loginspect command to print average xct latency
    Adding command agglog to webserver
    Now, after start a benchmark, the webserver returns JSON calls with the
    results of the agglog command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Updated loganalysis command
    Taking checkpoint right after log analysis
    Made tid_t a simple uint instead of its own class
    Updated loganalysis command to inspect dirty pages
    
    - Whereas previously it would just look at active transactions
    Added loganalysis command
    
    - .. which performs log analysis and prints out results, also comparing
    the list of active transactions with one obtained from a full log scan
    for validation purposes.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added LogrecInfo command
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Added NoDBGen command
    
    - Generates log containing page-image log records of all pages in a
    database file
    Added LogrecInfo command
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added command to extract propagation stats from log
    
    - Propagation stats a.k.a. recovery backlog
    - Counts number of dirty pages and REDO length for each tick on the log
    Added NoDBGen command
    
    - Generates log containing page-image log records of all pages in a
    database file
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Added LogrecInfo command
    Removed old tests and commands that used sthread IO
    Added loginspect command tracerestore
    Added loginspect command to print average xct latency
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Removing reference to webserver in loginspect CMakeLists, due decoupling of webserver from ZAPPS
    Decoupling webserver from zapps and returning json counters on webserver
    Webserver runs now as an executable and not anymore as a command from
    zapps. Changes in shore_env were made in order to give different streams
    output to the command. Due such changes in ShoreEnv, it was easy to
    return its results in a json format by the webserver.
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Added command to extract propagation stats from log
    
    - Propagation stats a.k.a. recovery backlog
    - Counts number of dirty pages and REDO length for each tick on the log
    Added loganalysis command
    
    - .. which performs log analysis and prints out results, also comparing
    the list of active transactions with one obtained from a full log scan
    for validation purposes.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Adding command agglog to webserver
    Now, after start a benchmark, the webserver returns JSON calls with the
    results of the agglog command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added NoDBGen command
    
    - Generates log containing page-image log records of all pages in a
    database file
    Updated propstats and verifylog commands
    Cleaning up some compiler warnings
    Updated scanner and verifylog components
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Removed class ErrLog and replaced its uses with std::cerr
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Added loginspect command tracerestore
    Added loginspect command to print average xct latency
    Added loginspect command tracerestore
    Adding command agglog to webserver
    Now, after start a benchmark, the webserver returns JSON calls with the
    results of the agglog command.
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Removed class ErrLog and replaced its uses with std::cerr
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated dbscan to filter a single pid
    Updated DBScan command
    Fixed redo bookkeeping and vol_t shutdown
    Fixed dbscan
    Updated DBScan command
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Removed potentially dangerous keyword redefinition from non-test source file to avoid errors while parsing.
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Lightweight propstats using chkpt data
    Propstats now keeps track of static-store pages
    Updated propstats
    Updated propstats and verifylog commands
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Fixed log analysis bug
    
    - Because we were using is_page_update() to track dirty pages,
    compensation log records were not being processed as dirtying updates,
    causing wrong PageLSN computation.
    Updated application tools: kits, propstats, and stress_cleaner
    Fixed propstats: min_rec_lsn doesn't work with forward scan
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Counting consecutive page writes in propstats command
    Added command to extract propagation stats from log
    
    - Propagation stats a.k.a. recovery backlog
    - Counts number of dirty pages and REDO length for each tick on the log
    Updated TruncateLog command
    Updated truncatelog command for temporary hack
    truncate_log now deletes truncated log partitions
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated propstats and verifylog commands
    Updated scanner and verifylog components
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated dbscan to filter a single pid
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Fixed ARIES restart with proper alloc & stnode logging
    Updated loganalysis command
    Taking checkpoint right after log analysis
    Updated LogAnlysis command output
    Made tid_t a simple uint instead of its own class
    Fixed log analysis bug
    
    - Because we were using is_page_update() to track dirty pages,
    compensation log records were not being processed as dirtying updates,
    causing wrong PageLSN computation.
    Solving minor issue in loganalysis
    New Handler mechanism in zapps loginspect
    
    - Scanner now uses a single list of handlers
    - Handlers can customize the output to a file rather than std::cout
    only. This allows a scanner with multiple handles, where each outputs to
    a different file.
    - Used new mechanism to produce two outputs in propstats command.
    Updated loganalysis command to inspect dirty pages
    
    - Whereas previously it would just look at active transactions
    Small update on zapps loganalysis command
    Added loganalysis command
    
    - .. which performs log analysis and prints out results, also comparing
    the list of active transactions with one obtained from a full log scan
    for validation purposes.
    Updated truncatelog command for temporary hack
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Parametrized bucket size in mergeruns
    (Re)Implemented log archive run merging
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Replaced uses of ArchiveScanner with new ArchiveScan
    Fixed & optimized log archive with bucket size 1
    
    - Using buckets of size 1 yields 100% lookup accuracy without Bloom
    filters, and index blocks still use less than 0.5% of the run size.
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Parametrized bucket size in mergeruns
    Fixed BlockAssembly init in mergeruns
    Unified classes ArchiveIndex and ArchiveDirectory
    Fixed archive merging and implemented merger daemon
    Moved nested classes out of LogArchiver
    (Re)Implemented log archive run merging
    Using boost filesystem in log archiver directory
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated genarchive command
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Updated zapps scanner and genarchive command
    Updated genarchive command
    Unified classes ArchiveIndex and ArchiveDirectory
    Removed deprecated store ID on chkpt_buf_tab
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Moved zapps codebase into here
    
    All files stored in src folder "cmd"
    Merged folders common, sthread, fc, latches, and Lintel
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Bug fixes for page rebalance full logging.  The very basic full logging is working but Still have more issues to investigate, the feature is not fully functional at this point.
    Modified test code so it is easier to merge with changed code from master.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Made lsn_t trivially copyable for use in atd::atomic
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Added is_null method to lsn and tid
    Whitespace changes
    Added convenience debug methods to lsn_t
    
    - Method str() returns the lsn as a string. Useful to look at the LSN
    form gdb
    - logrec_t has method lsn(), which does the same as lsn_ck() but is
    easier to type
    moved module comments
    more code comments
    generic_page_h -> fixable_page_h
    removed/changed incorrect/unneeded references to generic_page_h
    page_p -> generic_page_h
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed compilation errors in gcc6
    Fixed assertion in GcPoolForest
    
    - Generation numberwrap-around not being checked correctly
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    dbgout levels
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Small update on w_heap print method (+whitespace changes)
    Updated debug printing of w_heap
    refactoring in w_heap reverted
    deleted more
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Merged folders common, sthread, fc, latches, and Lintel
    Zero branch from subversion rev 11038
    Whitespace changes
    Removed more headers, fixing their previous uses
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Ported Consolidation Array
    Removed commented out code
    Addressed Harumi's/Alvin's comments:
    -Used LINTEL_REQUIRED_HEADER so that it won't fail silently if MUTrace is not there
    -Replace HAVE_MUTRACE_PROFILER_H with MUTRACE_ENABLED_H
    swizzling experiments: implemented bursty workload and fixed sliding window workload to slide at a fixed rate
    fixed some typos that slipped into the repository
    (1) Fixed race in TATAS implementation. (2) Scripts to run a mixed workload
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Fix 2 obvious (in retrospect) bugs introduced by conversion to lintel::Atomic
    Eliminate atomic_cas_[32|64]
    Replace membar-*() with atomic_thread_fence()
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Removed w_stream stuff
    Whitespace changes
    Removed vec_mkchunk.cpp
    Modified test code so it is easier to merge with changed code from master.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    [Shore Remnant] Another Solaris-specific code removed
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Fixed compilation in gcc5
    Whitespace changes
    Removed w_stream stuff
    Merged folders common, sthread, fc, latches, and Lintel
    dropping solaris support
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    bug fix for too many times looping tail recursive loop (tail recursive loops aren't optimized in debug mode)
    More detail in error message; clean up unintended debugging printf
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Eliminate atomic_cas_[32|64]
    Replace membar-*() with atomic_thread_fence()
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Removed w_stream stuff
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Updated debug messages in bf_tree_evict
    
    - Also redefined macro DBG2
    Removed class ErrLog and replaced its uses with std::cerr
    Removed old FUNC macro
    Merged folders common, sthread, fc, latches, and Lintel
    Whitespace changes
    Small improvements to debug features
    
    - Added shorter macros DBG1, DBG3, and DBG5
    - Added some info when printing out checkpoint log records
    - Tweaked CMake options for debug
    Changed debug message mechanism to work with debug flags (like old Shore-MT)
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    bunch of scripts to run swizzling experiments; some swizzling bug fixes: hierarchical clock didn't take refcount into account when selecting pages to unswizzle
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Fixed ARIES restart
    
    - Worker thread stuck at the end because there should be only one round
    Updated ReaderThread to derive log_worker_thread_t
    Bugfix: worker_thread round counter must be signed
    Fixed & generalized wait/notify behavior of worker_thread_t
    Removed most dependencies on sthread_t
    Adding wait/notify methods without predicates
    
    The comments explain the use cases.
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Merged folders common, sthread, fc, latches, and Lintel
    refactoring w_rc_t
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    switch to the new log buffer
    Fix dependent name lookup errors
    Zero branch from subversion rev 11038
    Moved latches to sm and fixed test compilation
    Removed sthread_stats
    Made tid_t a simple uint instead of its own class
    Removed rand48.{h,cpp}
    Moved w_findprime() into bf_tree.cpp
    Movet gethrtime() to vol.cpp
    Removed w_compat_strstream
    Removed vec_mkchunk.cpp
    common cleanup: removed some unused files
    Removed most dependencies on sthread_t
    Moved latch/mutex stuff out of sthread files
    Goodbye sthread IO!
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Removed class ErrLog and replaced its uses with std::cerr
    Removed old & unused "vtable" stuff
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Merged folders common, sthread, fc, latches, and Lintel
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Made vid_t a simple typedef and deleted volid_t
    Remove deadcode
    Removed regex package
    renamed:    src/common/FairRWLatch.hpp -> src/common/FairRWLatch.h
    changed name of spinlatch
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Fixes so that we can do a complete out of tree build.  Also
      other minor improvements.
    
    {examples,experiments,src/**,tests}/CMakeLists.txt: auto-generated file include paths
       Generate files in the binary directory only, and only generate them once rather
       than N different custom commands.
    
    experiments/experiments.h: move log/data stuff to /dev/shm
    
    experiments/random_inserts/select_only.cpp: improve usage message
    
    src/sthread/srwlock.cpp: add { } to eliminate compiler warning
    Zero branch from subversion rev 11038
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Merged folders common, sthread, fc, latches, and Lintel
    Fixed usage of debug macros
    prettier stacktrace
    refactoring w_rc_t
    Refactoring w_rc_t
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Add support for controlling location of log dir via a program option
      * Fix bug in mmap code that was resulting in unmapping pages that were not
        owned by the code, potentially unmapping thread code and stack pages leading
        to segmentation faults.
    
    CMakeLists.txt: find lintel
    
    experiments/CMakeLists.txt: include lintel, define experiment libraries variable
    
    experiments/*/CMakeLists.txt: link with standard set of experiment libraries
    
    experiments.h: add program option
    
    select_only.cpp: use program option
    
    dynarray.cpp: fix bug by not subtracting MM_PAGE_SIZE from align; if align == MM_PAGE_SIZE this
      results in additional alignment of 0, but kernel may mis-align by actual page size.  Also error
      out on mmap/munmap failures (thought this was the problem, it wasn't, but many callers aren't
      checking the return code)
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Zero branch from subversion rev 11038
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    unnecessary assert
    more testcases, backup folder option, bug fix
    merge with bufferpool change
    Typedef and constant value definition for bf_tree_m::find_page_id_slot
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    miscellaneous code cleanup
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Small worker thread fix
    Made thread_wrapper_t::join idempotent
    Reimplemented global thread list for aggregating smstats
    Small updates on latch_t (debugging)
    Cleaning up some compiler warnings
    Removed most dependencies on sthread_t
    Implemented std::thread wrapper to replace sthread_t
    
    - Used chkpt_thread_t as our first guinea pig
    Merged folders common, sthread, fc, latches, and Lintel
    debian's gcc needs stdint.h explicitly
    TPCC
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Made tid_t a simple uint instead of its own class
    Added is_null method to lsn and tid
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Remove indirection through atomic_templates.h
    Eliminate atomic_cas_[32|64]
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Zero branch from subversion rev 11038
    Cleaning up some compiler warnings
    Removed w_stream stuff
    Removed class ErrLog and replaced its uses with std::cerr
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Merged folders common, sthread, fc, latches, and Lintel
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    [Shore Remnant] Another Solaris-specific code removed
    dropping solaris support
    Zero branch from subversion rev 11038
    Small worker thread fix
    Fixed ARIES restart
    
    - Worker thread stuck at the end because there should be only one round
    Updated ReaderThread to derive log_worker_thread_t
    Bugfix: worker_thread round counter must be signed
    Fixed & generalized wait/notify behavior of worker_thread_t
    Removed most dependencies on sthread_t
    Minor formatting changes
    Adding wait/notify methods without predicates
    
    The comments explain the use cases.
    Fixing predicate bug in worker_thread_t
    
    Assume that there is a single thread (T1) calling wakeup() to a worker thread
    (TW). The worker thread is only awake externally, not proactivelly.
    
    TW starts waiting in the condition variable to be awaken.
    T1 calls wakeup(wait=true). No round was executed so far, so
    rounds_completed == 0.
    T1 sets this_round = 1 (rounds_completed+1). This means that the round assigned
    to T1 is 1.
    TW is not busy, so this_round is NOT incremented.
    At the end of wakeup(), T1 calls wait_for_round(2), i.e., this_round+1.
    
    This does not make any sense, T1 has to call wait_for_round(1). Otherwise the
    predicate will never be evaluated and T1 is going to wait forever or until
    the worker is activated again by some reason.
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Remove deadcode
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Merged folders common, sthread, fc, latches, and Lintel
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    added basic header
    Added debug function to print LSNs on gdb
    Whitespace changes
    Added convenience debug methods to lsn_t
    
    - Method str() returns the lsn as a string. Useful to look at the LSN
    form gdb
    - logrec_t has method lsn(), which does the same as lsn_ck() but is
    easier to type
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Whitespace changes
    Removed w_stream stuff
    Renamed macro 'align' to avoid naming conflict with C++11's std::align.
    Removed auto_delete stuff
    Merged folders common, sthread, fc, latches, and Lintel
    Added debug macro W_IFDEBUG5
    
    - We only had those until debug level 4
    [Shore Remnant] Another Solaris-specific code removed
    forgot about w_assert5()
    Conversion of more w_asserts to use if (false) when disabled.
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Get ELR experiments working again
    
    experiments.h, tpcb.h: Improved debugging messages
    
    experiments_env.h: move log directory away from data device
    
    tpcb_elr.cpp: switch to lintel:ProgramOptions for command line arguments
    
    w_base.h: add support for more useful assertion messages
    
    log_core.cpp: Make error message regarduing unexpected files in the logging directory actually
    understandable, & provide useful suggestion
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Zero branch from subversion rev 11038
    Removed more headers, fixing their previous uses
    Merged folders common, sthread, fc, latches, and Lintel
    dropping solaris support
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Zero branch from subversion rev 11038
    Fixed compilation errors in gcc6
    Merged folders common, sthread, fc, latches, and Lintel
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    incomplete code for RAW lock. not enabled
    Adding new error code
    This is thrown when the volume is failed and we want to read a page ignoring the restore.
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Merged folders common, sthread, fc, latches, and Lintel
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Added functionality to take backups
    
    vol_t now supports take_backup() operation. Its internal state keeps
    track of a path and file descriptor for a backup file currently being
    generated. It instantiates a RestoreMgr and reuses its functionality to
    generate a new backup file instead of a replacement device.
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Migrated error codes from Shore-Kits
    
    See comment block on the file
    Modified test code so it is easier to merge with changed code from master.
    Several bug fixes for 'Instant Restart' milestone 2.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    RAW-style lock manager
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Return value checks, conform to coding convention, etc
    check for null parent before kicking SPR
    crabbing from Q is now handled by fixable_page_t correctly
    SPR dumping feature, new testcase, and bug fix
    added code to test for valid Q to Q crabbing + new subtest for it
    (failing); uses new error code: ePARENTLATCHQFAIL
    added a new error code for Q mode failing
    re-flowed some comments to use new line limit
    made fix routines handle Q mode
    removal of unused error codes; bug fix to capitalization of all error messages
    improved formatting of error message list
    refactoring w_rc_t
    Merged folders common, sthread, fc, latches, and Lintel
    refactoring w_rc_t
    Refactoring w_rc_t
    fixed debian load-shared-library issue]
    fix for release-only crash in w_rc_t destructor
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Zero branch from subversion rev 11038
    Removed w_stream stuff
    common cleanup: removed some unused files
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed flag SM_LEVEL
    Some whitespace changes
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed regex package
    Delete dead codes
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Zero branch from subversion rev 11038
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Merged folders common, sthread, fc, latches, and Lintel
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    moved module comments
    more code comments
    another stdint.h include for debian
    Follow-up cleanings
    OKVL terminology change and optimizations
    Eliminate signed/unsigned comparison warnings.
    renamed w_okvl to ovkl_mode
    more comment
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    added basic header
    Removed dependencies to libnuma and valgrind
    Merged folders common, sthread, fc, latches, and Lintel
    Set std=c++11 and cleaned up some fc files
    bug fix on delegated-buffer-release
    Ported Consolidation Array
    [Shore Remnant] Another Solaris-specific code removed
    Delete dead codes
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Merged folders common, sthread, fc, latches, and Lintel
    Copied AtomicCounter.hpp from Lintel and removed dependency
    fix warning for old debian
    Ported Consolidation Array
    Zero branch from subversion rev 11038
    Whitespace changes
    Removed w_stream stuff
    Merged folders common, sthread, fc, latches, and Lintel
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Zero branch from subversion rev 11038
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Replaced log "stub" calls with generic Logger
    Removed 'undo' parameter from B-tree methods
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Fixed some assertion bugs
    
    - PageID 0 is actually a valid one, so cleaner should not assert that
    - sx_append_extent was switched to use sysevent instead, but the ssx
    object was still being created, leaving an open (chained) ssx in the xct
    state, which was causing a nasty bug when interting log records form the
    parent UX.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Added store number parameter to B-tree locking
    
    Since store number is not available in the page ID anymore, all B-tree
    locking methods (e.g., _ux_lock_key) must include the store number as
    an additional parameter.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Replaced all occurrences of volid+snum with stid_t
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Added a few primitive M3 test cases.  Also small change to Single Page Recovery record collection buffer allocation, give bigger buffer size if full logging.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Attemped to fix a full logging page rebalance bug but did not get anywhere, check in the current code although it is not completed.
    Clean up the restart code more for the 2nd M3 check-in, also fixed a few bugs in Log Analysis phase.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Fixed a bug on normal shutdown with transaction rollback where the transaction contains a page split through full logging.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Identified 'checkpoint' is causing failure in 6 'page rebalance' test cases, both minimal and full logging.
    1. Copy a test case to 'test_restart_bugs' for investigation purpose.
    2. Commented out 'checkpoint' in test_concurrent_restart for 6 test cases and enable them for regression testing purpose.  Once the 'checkpoint' issue has been fixed, will enable the checkpoint statement for thest 6 test cases.
    Bug fixes for page rebalance full logging.  The very basic full logging is working but Still have more issues to investigate, the feature is not fully functional at this point.
    Fixed bug on 'failed to generate log record' for deletion compensation (insert).
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Several bug fixes for 'Instant Restart' milestone 2.
    merged okvl branch
    New log type for b-tree insertion
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    replaced dat_leaf[_ref]
    converted some code to use _compare_key_noprefix
    new_search->search, replace search_leaf with search
    removed original search function (references) in favor of search_leaf
    and search_node as appropriate
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    working on removing references to slot_sz
    removed get_rec_size* functions in favor of new get_rec_space function
    based on item_space
    
    removed dead code page_usage
    modified reserve_ghost take element_length rather than record size
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    Many small changes to eliminate compiler warnings. Work-in-progress.
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Added put operation to zero.
    
    Added a put operation, which is essentially "update, or insert if didn't exist".
    
    src/sm/btree.* : add btre_m::put
    
    src/sm/btree_impl.* :
    
    Separated the traversal and getting if it was found/a ghost for insert and update into new function
    _ux_get_page_and_status.
    
    Split insert & update core functions into a head and a tail part; tail does the "heavy lifting" of
    modification, head does the searching.
    
    Use insert_core_tail and update_core_tail to implemetn _ux_put_core and _ux_put.
    Zero branch from subversion rev 11038
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed SM level 1
    Removed SM level 2
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Replaced all occurrences of volid+snum with stid_t
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Touch method to quickly pre-load tables
    New log type for b-tree insertion
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Added put operation to zero.
    
    Added a put operation, which is essentially "update, or insert if didn't exist".
    
    src/sm/btree.* : add btre_m::put
    
    src/sm/btree_impl.* :
    
    Separated the traversal and getting if it was found/a ghost for insert and update into new function
    _ux_get_page_and_status.
    
    Split insert & update core functions into a head and a tail part; tail does the "heavy lifting" of
    modification, head does the searching.
    
    Use insert_core_tail and update_core_tail to implemetn _ux_put_core and _ux_put.
    Zero branch from subversion rev 11038
    Some assertions and new default values for log archiver
    Fixed page-img logrec of stnode page
    Implemented page-img compression for non-btree pages
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Updated stnode_cache_t to use normal page fix
    Fixed initialization of bf_tree_m::_root_pages
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Moved latch/mutex stuff out of sthread files
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Fixed flushing of alloc/stnode pages on sm shutdown
    alloc_cache and stnode_page read directly from vol_t
    
    ... instead of fixing page in the buffer pool. This is done so that they
    don't leave a dangling page which is never updated, read, or cleaned.
    Fixing bf_tree_cleaner not flushing alloc and stnode
    
    force_volume() explicitly reads this pages from disk, triggering single page recovery, and then writes them back.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Fixed bugs with vol_t and stnode_cache
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed volume remount operation in mark_failed
    
    Isolated methods for initialization of metadata (stnode, bf_fixed, and
    alloc_cache) into their own methods, allowing the related objects to be
    reset during a media failure without explicit remounting and deadlock
    problems.
    
    Also fixed methods that rely on metadata information, so that they wait
    for restore if one is in progress.
    Fixed logging of volume operations
    
    Format volume operation is now properly logged and redone, and SSX
    behavior of other sx_* methods in vol_m was also fixed. Still need to
    implement logging for dismount_all though. Testing recovery fo volume
    operations is also to be done soon.
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Fixed REDO of store operations
    
    Store operations always generated log records, which is wrong in case of
    a REDO step. Updated the interface across all classes to include a
    "redo" boolean flag. If set to true, no log record is generated.
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    reviewer comments
    minimize includes
    fixed bug where code was incorrectly assuming a store was unallocated
    if it's root pid was 0
    fixed some shore includes
    converting to BOOST_STATIC_ASSERT
    new class generic_page_h that is the superclass of all page handle classes
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    more cleanup
    adding/updating comments to src/sm/stnode_page.h
    removed unused t_store_freeing_exts state of store_deleting_t enum
    added missing includes to sm_base.h
    more cleanup of stnode_page
    removed pragma interface/implementation
    stnode_cache_t now accesses _stnode_t's correctly using a stnode_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    stnode now using generic_page_header
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Made tid_t a simple uint instead of its own class
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Goodbye fileoff_t!
    Options to truncate log archive and run benchmark for a given log volume
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    truncate_log now deletes truncated log partitions
    Small preliminary clean-up of sm.h and sm.cpp
    Removed sm_du_stats
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed log truncation and clean shutdown
    
    - Truncation is only allowed when performing clean shutdown
    - Shutdown is now dirty by default
    Removed obsolete ArchiveMerger class
    Added convenience debug methods to lsn_t
    
    - Method str() returns the lsn as a string. Useful to look at the LSN
    form gdb
    - logrec_t has method lsn(), which does the same as lsn_ck() but is
    easier to type
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Removed SM level 3
    Removed SM level 4
    
    This begins a series of commits in which I'll attempt to remove the
    concept of "SM levels". The goal is to have independent components (bf,
    log, lock, io, etc.) which can be constructed independently, and a much
    "thiner" ss_m which simply orchestrates the components and delegates API
    calls to them.
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed raw device stuff and unused vhdr fields
    
    The distinction between raw and non-raw volumes does not make much
    sense, because nothing important was really done based on it. Also see
    comments.
    
    Removed fields quota and page_sz from volume header, since these are
    redundant.
    Some whitespace changes
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Made vid_t a simple typedef and deleted volid_t
    Moved some restart code in sm.cpp into own methods
    Removed device manager and its uses
    
    Shore/Zero always had the concept of a device, which was supposed to be
    composed of multiple volumes -- in the same way a linux device is
    composed of multiple partitions. However, this destinction was never
    really realized, and a device was always assumed to contain just one
    volume.
    
    In a refactoring which was supposed to be done many years ago, I removed
    the device manager and all its uses, delegating to volume operations
    where applicable. It seems like things will keep working as expected,
    but more tests will be required to see if anything is broken by this
    change.
    Added code to instantiate and activate log archiver
    Removed old index interface from Shore
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Implemented basic extensibility of xct for private logs
    switch to the new log buffer
    Fixed test cases.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Merge fixed for OKVL experiment
    Touch method to quickly pre-load tables
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Addressed Mark's code review feedbacks
    Ported Consolidation Array
    more testcases, backup folder option, bug fix
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    moved module comments
    more code comments
    bb
    Making a small change so that I can publish a change to this branch.
    Making a small change so that I can publish a change to this branch.
    Removed regex package
    Delete dead codes
    fix for max_entry_size accounting issue
    Making a small change so that I can publish a change to this branch.
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    generic_page_h -> fixable_page_h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    enable/disable statistics at runtime
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    implement ss_m::put_assoc()
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    Changes for benchmark build
    
    Changed cmakelists.txt such that inlining works better (less debugging/asserts)
    Removed unneeded wrok from bf_tree_inline.h
    
    pin.h, scan.cpp, sm.h, and smfile.cpp got fixes to supress warnings in stubbed functions.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Alloc pages should themselves be considered allocated
    Fixed ARIES restart with proper alloc & stnode logging
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    converting to BOOST_STATIC_ASSERT
    pulled up generic page formatting
    new class generic_page_h that is the superclass of all page handle classes
    more cleanup of stnode_page
    improved readability of code
    off by one error
    page_s -> generic_page
    alloc_p-> alloc_page_h
    renamed:    src/sm/alloc_p.h -> src/sm/alloc_page.h
    alloc_p now has two constructors, one which formats a new page and one
    which takes an existing page
    pulled in implementation of bitmap into alloc_page class.
    Allowing sm_options to be overwritten if exists
    deleted more files.
    oops, forgot to git add
    evict_page logrec now has ppage LSN at time of eviction
    Propstats now keeps track of static-store pages
    Added fetch_page log records for debugging
    Logging page evictions for debug
    Renamed logrec type page_evict to update_emlsn
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Fixed ARIES restart with proper alloc & stnode logging
    Detecting warmup based on hit ratio & other updates
    Fixed adding backups
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Updated stnode_cache_t to use normal page fix
    Properly logging initialization of stnode_cache
    
    - Log record must be generated when an empty stnode cache is created in
    order to format the stnode page correctly.
    - This fixes some related bugs in some unit tests.
    Fixed compilation of tests
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Removed deprecated page deletion stuff
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Bugfix: properly constructing logrecs with type and cat fields
    Moved classes around and cleaned up logdef_gen.h
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Cleaned up includes of logrec.h
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Implemented page-img compression for non-btree pages
    Stats to keep track of page-img compression & small fix
    
    - Stats will help us evaluate exactly how much space is saved (or
    perhaps even wasted with page-image compression)
    - Log volume counter on page CB should be reset before and after
    generating page image.
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Deleted deprecated method XctLogger::log_page_chain
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Removed logrec category field
    
    - Category can be derived statically from type, so I removed the field
    in the logrec header and converted get_logrec_cat into a constexpr
    function. The logrec_t::cat() function now calls it using the _type
    field.
    - Removed the undoable_clr stuff, which seemed to be some deprecated
    stuff from old Shore times.
    - Left the byte in the logrec header to tell if logrec is a CLR. I.e.,
    the t_cpsn category flag was the only one that could change at runtime.
    Ideally, it would also not be needed if there is a dedicated CLR logrec
    type which just points to the LSN being undone.
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    Fixed XctLogger::log_page_chain
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Fixed logrec TID assignment transaction rollback
    
    - Critical bug introduced with new XctLogger
    Fixed compilation of tests
    Got rid of LOG_INSERT macro in chkpt.cpp
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed old&unused xct_log_t
    Moved log record buffer from xct_t into smthread_t::tcb_t
    Moved some logging logic from xct_t to XctLogger
    Replaced log "stub" calls with generic Logger
    New templated function to replace log "stubs"
    Replaced uses of ArchiveScanner with new ArchiveScan
    Some assertions and new default values for log archiver
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Removed virtual methods from archiver workspace memory manager
    Fixed log archiver shutdown
    
    - Reader thread now uses worker_thread
    - Shutting down consumer first so that we can exit before current log
    archive activation loop finishes
    Decoupled BlockAssembly from log_core with compression option
    Unified classes ArchiveIndex and ArchiveDirectory
    Fixed archive merging and implemented merger daemon
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved nested classes out of LogArchiver
    Fixed ArchiveDirectory block appends for multiple levels
    Removed buggy and deprecated archive mode without buckets
    (Re)Implemented log archive run merging
    Fixed multi-level run management
    Implemented multi-level log archive
    Added level number to log archive run file name
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Goodbye fileoff_t!
    Assorted bugfixes to restore code
    Options to truncate log archive and run benchmark for a given log volume
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Using boost filesystem in log archiver directory
    Supporting reformat flag in log archiver
    
    - Log folder is emptied using boost filesystem when reformat==true
    Fixed log archiver run counting
    
    - Using centralized typedef run_number_t, which is now 32 bits to avoid
    any overflow or cast problems
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Adding ignore flag to LogConsumer()
    LogConsumer constructor was initializing an ignore-list of log records to be ignored during the log scan.
    While this behavior is default for the LogArchiver, it is not desired if we are going to use the LogConsumer to scan the log for log_analysis _and/or chkpt.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Eliminated multseg restore techniques
    
    - New "preemptive" technique is much simpler and achieves the same goal
    - Updated log archive probes to not use min/max read and segment size
    Implemented preemptive adaptive restore technique
    
    - Every segment restore by default opens a log archive scan until EOF,
    and multiple adjacent segments are restored until a new request pops up
    in the scheduler.
    - The goal is to restore one segment at a time during the initial phase
    of restore, prioritizing latency. As the working set is restored in the
    buffer, the algorithm then behaves more like single-pass restore,
    achieving higher bandwidth.
    - This simple and effective technique should replace our complicated
    multiple-segment technique. Thanks to Goetz for suggesting it.
    Fixed block reads with varying LA read size
    Updated run scanner to use arbitrary read sizes
    
    - Now that log archive runs contain contiguous log records (like
    partitions in the transaction log), we are not restricted to reading the
    log archive using the block size that was used when it was built.
    - This give much better I/O performance, since we can actually control
    the read size on the log archive using the maxReadSize option; instead
    of only controlling the number of segments to restore at once.
    Updated backup prefetcher
    
    - Prefetching now controlled by RestoreMgr instead of scheduler
    - Changed how prefetching is performed in the restore logic. Got simpler
    code and better performance
    First implementation of asynchronous merge daemon
    
    - Currently only supporting a very restrictive use case of the restore
    experiments, mostly due to the complex and unflexible coordination
    between the various log archive components (directory, block assembly,
    and writer thread)
    New log archive file format
    
    - Log records are not stored contiguously in runs, with a skip log
    record determining the EOF. I.e., the same format as log files. The only
    difference is that index blocks are stored at the end.
    - The old format kept log record in blocks in the same format as
    produced by BlockAssembly. However, the format is not beneficial for
    scans on the log archive, since unless opening a file at the exact
    beginning of a block, I/O sizes will be smaller than a block. The block
    format was maintained for index blocks, however.
    - The log archive generation methods (mostly in the WriterThread) had to
    be changed. For RunScanner, a LogScanner object is required to parse the
    continuous stream of log records.
    Removed old methods probeFirst and probeNext
    Fixed log archive scan to use correct segment borders
    
    - For the first segment which overlaps with metadata, special treatment
    is required on the restore part. In a previous commit, I made it ignore
    the first pages by opening the scan directly on the first data pid.
    However, this broke the scan because the end of the scan (previously
    given by segmentSize) was not adjusted accordingly.
    - Other than adjusting both the begin and end boundaries, these must be
    independent from the "segment size" parameter of the scan, which is used
    only to expand the length of the scan into multiple segments. To fix
    that, I reintroduced the endPID argument. Now, startPid-endPid tell
    where the scan must begin and finish. If multiple-segment scanning is
    desired, then the segmentSize parameter tells which valid values can be
    assumed by endPID.
    Changed output of MergeHeapEntry for better readability
    Fixed race condition in ArchiveDirectory
    
    - For a brief period of time, writer thread closed the current run
    before it opens a new one. If during this time window, a flush request
    (from archiver thread) tries to close the current run, it will throw a
    file not found error.
    - Fixed by implementing an atomic closeCurrentRun method which uses a
    mutex and closes and opens a new run in the same method.
    New archive index probe method and multiple-segment restore
    
    - Whole probing/scanning mechanism of log archive was updated and is
    much simpler now, also supporting multiple-segment restore.
    - Open method now takes a start pid and the number of page ids to be
    scanned (segment size), as well as a min and a max read size.
    - Probe method returns a list of probe result objects, which simply
    contain a start offset and an end page ID on which to stop scanning.
    In order to achive reads greater than the given min size, the end pid
    is adjusted based on neighboring segments, but going no further than the
    max read size.
    - After initial probe, open method readjusts endPid of all run scanners
    based on the maximum value collected.
    - Restore manager was also updated to work with the new mechanism.
    Fixed generation of archive index buckets
    
    - Bucket list must be initialized before producing blocks, in order to
    keep track of correct offsets and page IDs. Moved "run switch" logic
    from finish to start method of BlockAssembly to fix it.
    Fixed bucket tracking on log archive index
    
    - The variable bucket mode, where index entries contain fixed ranges of
    page id with variable amount of log records in it, was not being computed
    correctly. Fixed now.
    New multiple-segment restore scheme
    
    - Mechanism is now incorporated into the log archive scan, which
    recieves minReadSize and maxReadSize as parameters. When probing on
    eachr run, the end of the scan is then adjusted so that the read size
    fits within the given boundaries.
    Removed multiseg restore code (new one coming up)
    Fixed bug on log archiver
    
    - Global lastLSN variable, which was kept in the archiver index to
    determine the filename of the last run, was subject to a race condition
    in which a concurrent probe on the last finished run could get the wrong
    LSN boundaries. Added redundant lastLSN field to RunInfo objects to fix.
    Extended LA index code for future improvements
    
    - Extensions below were implemented, but they don't change the behavior
    of restore or archiving yet. I am hoping they will facilitate future
    improvements that I'm planning.
    - Opening an archive scan actually creates a list of ProbeResult objects
    before constructing a heap. This will allow us to adjust the number of
    segments to restore before opening any run file, based solely on index
    information.
    - For the same reasons as above, also extended ProbeResult to include
    the offset and PID of the end of the scan, and extended the probeInRun
    method accordingly.
    - Binary search in findEntry now returns the index of the entry on the
    entry array, instead of the offset directly.
    - Field ioUnit was added to ArchiveScanner, but it's not used so far.
    Add skip log record to the end of log archive blocks
    
    - Instead of relying on the actual block size on the block header, the
    scanner now stops when it reaches a skip log record.
    - This mechanism provides a cleaner way to open a scan on an arbitrary
    file offset and scan forward from there, without having to zero-out
    blocks.
    Removed obsolete ArchiveMerger class
    Implemented variable-bucket log archive index
    
    - This new index is used if a parameter bucketSize > 0 is passed to the
    cosntructor. If it works really well we may make it the default and
    remove code exclusive to the "old" index.
    - Instead of keeping entries in the index with offsets in fixed
    increments of the block size and the first PID which happens to occur in
    each block (i.e., just like a B-tree), this new index records the first
    page ID of each logical "bucket" and whatever arbitrary offset this page
    ID occurs in the file. A bucket is a set of page IDs belonging to fixed
    logical ranges (e.g., page IDs 0-99, then 100-199, and so on). For use
    with instant restore, a bucket should be the same size of a segment.
    - The advantage of the new index is that only the amount of log required
    to restore a segment is read from the log archive. In the old
    implementation, segments with few updates caused reads of a whole block
    (e.g., 1MB) where actually only a few bytes where used. The
    multiple-segment technique implemented in an earlier commit did not work
    very well for many runs. We hope this new index will achieve the goal of
    better read efficiency reagrdless of the number of runs.
    - In essence, this index is superior because it allows us to jump
    directly to the offset of a segment.
    Fixed bug on multiple-segment restore
    
    - End PID of log scan must be set before advancing the heap to the first
    PID
    - Added a bunch of debug messages which helped debugging this error.
    Reuse one log archive scan to restore multiple segments
    
    - Implemented a technique taht checks when opening a scan if multiple
    segments can be restored based on the page IDs contained in the first
    block read from each run.
    - The technique required a new restoreSegment method, which is more
    generic and can now be reused for the single-pass loop and, later, for a
    generic log replay class.
    Fixed series of bugs on log archiver
    
    - Mostly related to log truncation, which creates a lot of special cases
    - Fixing these bugs was a painful process, so in retrospect, such
    truncation features were probably not very useful.
    Fixed sharp backup taking
    
    - To make sure that a sharp backup is taken from the current tail of the
    recovery log, a stronger version of log archive flushing was
    implemented, in which not only we wait for all log records to be
    consumed and written out to archive blocks, but also forcibly close the
    currenr run and create a new one. This also makes sure that the new run
    has the requested LSN as its upper boundary.
    Fixed logrec duplication in log archiver
    
    - Multi-page log records such as btree_split neeed to be duplicated in
    the log archiver so that they can be reached when retoring either page
    independently.
    - The previous code had a bug in which the duplicated copy could end up
    in a different run, meaning that its LSN would be below the low boundary
    of the new run.
    - To fix that, duplication is now handled directly in the ArchiverHeap
    code, and we guarantee that both log records are added as an indivisible
    unit to the same run.
    Fixed BackupPrefetcher to wake up on prefetch requests
    
    - The prefetcher now waits for a prefetch signal, which is emitted by
    the prefetch() method when a request is placed on the queue. This should
    be invoked by the restore scheduler.
    - Waiting for a signal guarantees that the prefetcher will not try to
    "prefetch nothing", which is what happens when it consumes from the
    request queue eagerly and without waits (i.e., the previous buggy
    behavior)
    Pruning log archive probes based on first PID in runs
    
    - If there is a correlation between PID and LSN, which is typical in
      OLTP workloads, then recent runs most likely only apply to the highest
      segments. In that case, the last PID in the segment will be lower than
      the first PID in the run.
    - Combined with the last commit, this shoud provide effective pruning
      for typical workloads such as TPC-C.
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Fixed small bug on log archiver
    
    - When reading a skip log record which causes a truncation, log scanner
    must be reset properly.
    Fixed embarassing bug on log archiver
    
    - The end boundary of a run file was being generated as simply the LSN
    of the last log record in the last block, which makes absolutely no
    sense. The boundary should be the *maximum* LSN within that run. To fix
    that, I changed the BlockAssembly behavior to keep track of the max LSN
    in each block (instead of the last), and the WriterThread to keep track
    of the maxLSN among all blocks of the current run.
    
    (I guess the bug hasn't been detected yet because all my tests used ony
    one run)
    Fixed small bugs on log archiver
    
    - Correctly consuming from end of a partition to the next one (blockPos
    must be reset to zero and we must verify that log scanner is not in the
    middle of a truncated log record)
    - Log archiver thread must shutdown and join before consumer and block
    assembly shutdown.
    Fixed log archiver and log truncation to work together
    
    - A truncated log introduces a bunch of special conditions in the log
    archiving process:
      - It must generate empty runs to account for the hole beteen the
      truncated LSN and the next partition.
      - It must tolerate empty runs.
      - It must support manually unsetting the eager flag and activating
      until an LSN larger than the current log LSN.
    
    These and other tricks were implemented to make log truncation work with
    log archiving and vice-versa.
    Redesigned restore/archiver synchronization mechanism
    
    - When a volume is marked as failure, restore now simply invokes a flush
    request (synchronously), which causes the whole heap to be written out
    into run files. This must be done after the failure LSN has been
    consumed.
    - The previous mechanism was wrong because we cannot simply start a new
    run at will. This causes all following runs to be smaller than the
    workspace capacity.
    - This also has the implication that the log archiver does not need to
    treat "restore_begin" log records differently. In fact, they can be
    ignored now.
    - The flushing mechanism itself is also simpler now. We simply consume
    the whole heap and wait until the write buffer is empty -- no need to
    shutdown the writer thread.
    - Furthermore, the logic of the `run()` method in the log archiver was
    broken down into smaller, self-contained methods, making the code more
    readable and modular.
    Implemented mechanism to read only whole blocks in archiver
    
    - When the option to read only whole blocks is set, the log archiver
    only activates if there is at least one block worth of log to be read.
    Furthermore, it adjusts the endLSN parameter passed to the consumer so
    that it is always at a block boundary, such that only whole blocks are
    read instead of partial ones.
    - This eliminates the assumption that endLSN is always a valid log
    record. Thus, the consumer and scanner had to be adapted to handle that
    case. The scanner now returns a length parameter, which helps the
    consumer decide whether it should request a new block or not.
    - However, there are cases where the log is either growing too slow or
    it has stopped altogether. To avoid the log archiver getting stuck
    because it only reads whole blocks, a wait mechanism was implemented. If
    the activation window is too small, the archiver waits a certain grace
    period. If after that, the current durable_lsn of the log is still equal
    than the current activation's endLSN, then the log is growing too slow,
    and the consumer proceeds with partial blocks. This happens at least at
    the end of an experiment, where transactions have finished and we are
    waiting for the archiver to complete.
    - Added a stat to count how often this "log too slow" situation
    happens. The grace period, which is an SM option, should be increased if
    it happens too often.
    Fixed bugs on log archiver consumer
    
    Previous mechanism was not working when the (fake) skip log record
    spanned two neighboring blocks. Changed the whole mechanism to not rely
    on fake skip log records but solely on nextLSN, which is what I should
    have implemented from the start.
    
    - Reader does not insert fake skip; it simply stops readin when the
    endLSN is contained in the block just read (or if it's the first byte of
    the next block).
    - LogScanner does not treat skip log record in any special way. It is up
    to the caller to see that it got a skip and stop invoking the scanner on
    the same block.
    - Also fixed nasty little bug when a log record ignored by the log
    scanner fits exactly at the end of a block (such that toSkip ==
    remaining in the code)
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Fixed in-block position handling in archiver
    
    - Eliminated unnecessary (and buggy) prevPos variable from reader thread
    - Fixed initialization of pos to start in middle of block in LogConsumer
    constructor
    - Other minor clean-ups and debug messages
    Fixed archive index building and loading
    
    - Changed building mechanism to support multiple runs being indexed
    while writer thread only writes out one at a time. The previous
    assumption that the last run entry on the index was always the one being
    (1) appended to by BlockAssembly and (2) written out by WriterThread was
    completely wrong, since both threads run independently without
    synchronization. New mechanism makes use of a "lastFinished" array
    index, which points to the last entry already serialized by the writer
    thread. All entries up to this one can be probed -- the remaining ones
    were created by BlockAssembly but not serialized yet. (Fixes #5)
    
    - Removed filter mechanism of RunInfo objects. The goal was to eliminate
    runs that are known to not contain a given PID from a probe. However, the
    strategy proved not very effective in practice, and no one was
    working on it. Without filter information, RunInfo is much leaner and
    easy to serialize/deserialize.
    
    - Fixed serialization and deserialization of the archive index,
    following the new design.
    Renamed log archiver shutdown method
    
    start_shutdown implies an asynchronous shutdown, but since we changed
    the shutdown mechanism to be synchronous, the method should be called
    simply "shutdown()"
    Several bug fixes on eager log archiver
    
    - Reader thread cannot run eagerly, because endLSN must be in sync with
    log archiver. This is because log consumer expects a skip log record on
    the endLSN position, and it must be artificially inserted by reader.
    - Reader activation fixed to use a single signal instead of a loop.
    Thanks to proper lock acquisition, we guarantee that the signal is
    always caught.
    - Reader correctly fetches partial blocks across activation cycles,
    i.e., if then endLSN is in the middle of a block, following read will
    fetch data into the rest of the block, so that scanner continues from
    the same offset where it left off.
    - LogArchiver keeps track of the endLSN of the last activation, to avoid
    being activated on a region which was already covered before. This is
    important for cases when the archiver runs faster than the log grows.
    - Shutdown of log archiver is synchronous now, i.e., it sends
    synchronous shutdown to all sub-components and joins on all threads.
    - Writer thread forked from the beginning rather than on demand.
    Eliminated writerForked flag and fixed shutdown.
    - Small fix on heap workspace deallocation (array delete was wrong)
    - Added log archiver shutdown to SM destructor.
    Implemented non-instant restore and eager archiving
    
    - Added "instant" flag to restore manager. On-demand requests are only
    satisfied if the segment is restored AND the flag is true. This allows
    us to run experiments with traditional restore.
    
    - Eager archiving means that the reader thread and the sorter thread of
    the log archiver keep running indefinitely in a loop until shutdown. The
    lazy behavior (old one, current default) means that these threads must
    wait for an activation signal.
    Whitespace / format changes
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Applied changes from llesrch/archindex
    
    Changes to Log Archive Index:
    - New bit vector to filter page IDs within a run
    - Implemented deserialization
    - New tests for serialization
    - Improved log factory
    - Bugfixes
    Duplicating multi-page logrecs on log archiver
    
    Multi-page log records are replayed once for each page involved. In the
    case of Restart and Single-page recovery, this is achieved by merges and
    bifurcations in the per-page log chain. For Restore, however, we must
    replicate the log record so that is replayed for each page involved.
    Updated log archiver and restore for new PID
    
    Comparisons between lpid_t values are now valid.
    Fixed bugs on log archiver
    
    - Shutdown of consumer and block assembly should only occur after the
      archiver main loop has emptied the current heap (i.e., right before
      the run() method returns)
    - MergeHeapEntry does not need extra parameter for the PID -- it's
      contained in the given RunScanner
    - findEntry should not return an error if first entry on a run has PID
      greater than the one being queried
    - Added methods for restore interfacing: getDirectory() and
      getNextConsumedLSN()
    Fixed activate/shutdown behavior of LogArchiver
    
    To allow better control of log archiver execution, the activate method
    (if called with wait=true) now makes sure that archiver thread received
    the signal by using a 'listening' flag, which is set by
    waitForActivation(). Activation then only sets activate = true if
    listening is true. Thus, we can guarantee that return from an activate
    call actually kicked off the archiver thread.
    
    The other problem (at least for tests/experiments) is then how to wait
    for a certain LSN to be archived. This is fixed by monitoring the last
    LSN consumed and making sure that all consumed LSNs are archived before
    shutdown finishes. This is guaranteed because (1) selection empties the
    heap before the log archiver returns, and (2) writer thread consumes and
    writes out all pending blocks before exiting.
    Removed unused lastPID from BlockAssembly
    Fixed bugs in ArchiveIndex
    
    The whole probe logic was full of bugs. The binary search for entries
    within a run as well as the linear search for a single run were both
    wrong.
    Fixed RunScanner to deal with index blocks
    
    If an index is build during run generation, its data is stored at the
    end of the run file, in N blocks appended after the actual data blocks.
    This commit extends RunScanner to stop scanning when the index blocks
    are reached, by keeping track of the total number of data blocks. To
    that end, I implemented a simple method to read metadata from the last
    block of the file and, together with the file size, determine the number
    of data and index blocks.
    Fixed bugs on RunMerger
    
    - Fixed run boundaries so that end is exclusive and begin is inclusive
    - Fixed logic of advancing individual run scanners within the RunMerger heap
    LogArchiver: optional index creation and list files
    
    - Implemented method to list files in the log archive.
    - Added boolean option to ArchiveDirectory constructor to make index
    building optional (useful for tests at least)
    Fixed compilation errors on prev commit (sorry!)
    Added doxygen comments to LogArchiver components
    
    Added overall documentation about each sub-component/class in
    logarchiver.h. The comments provide a high-level explanation of how each
    component works. More deailed documentation should come later on for
    each important method.
    Moved implementations from logarchiver.h to cpp
    
    The logarchiver.h header is getting very large, especially with all
    methods implemented inline. Moved some of them to the cpp file.
    Removed "returnRC" mechanism from log archiver
    
    The threads used in the log archiver make use of a "returnRC" flag to
    store any error codes encountered during execution. The idea was to
    detect errors on asynchronous threads without interrupting the execution
    of the main thread. However, the mechanism didn't make much sense, since
    we only checked for such errors when the thread exited, and we used the
    W_COERCE macro for that. This means that early detection of such errors
    was not being useful in any way. Therefore, I removed the returnRC
    mechanism and errors are thrown immediately using W_COERCE. Since our
    project is more experimental/research prototype, we don't have to be so
    worried about catching errors early on in the hope of fixing them.
    Fixed bugs in log archiver
    
    - Added missing destructors vor ArchiveScanner and RunMerger
    - Added method "isIgnored" to LogScanner -- used in tests
    Made RunScanner public
    Implemented basic ArchiveScanner [untested]
    
    Implemented basic archive scanning functionality, with all related
    classes:
    - RunScanner is a basic scanner of log records of a single run
    - RunMerger manages a heap of RunScanner objects, also providing a
    log record iterator interface. This provides a single sorted stream from
    a collection of archive runs.
    - ArchiveScanner is the main entry point and the orchestrator of these
    two sub-components. It provides an open-next-close interface and takes
    care of (1) querying the archive index to know which runs and blocks to
    read, (2) constructing RunScanner objects and positioning them in the
    correct log record, and (3) adding these objects to the heap and
    executing heap operations upon each "next" invocation.
    
    These classes have not been tested yet. Individual tests for each
    component (index, run scanner, run merger, and archive scanner) will be
    implemented soon.
    Small fix on log archiver
    
    Made parseLSN a public method, since it is used in loginspect. Also
    removed some comments about certain methods being used only for tests.
    Removed FactoryThread from LogArchiver
    Small bugfixes on log archiver
    
    - Fixed behavior of ArchiveIndex, which must know its startLSN at startup.
    - Fixed closing of current run on ArchiveDirectory
    - Fixed small bug on BlockAssembly (not using "dest" member properly)
    Fixed shutdown on LogArchiver
    
    Added mfence on shutdown method to make sure finished flag is
    propagated. Added "selfManaged" flag which, depending on how LogArchiver
    was constructed, deletes the sub-modules (dir, heap, consumer, assembly)
    as well during its desctruction.
    Updated log archiver constructors
    
    Constructors now rely on sm_options to initialize their state.
    Additionally, LogArchiver can be constructed by passing instances of
    ArchiveDirectory, LogConsumer, ArchiverHeap, and BlockAssembly. This
    modularization will be useful for tests and experiments.
    Removed option to generate unsorted log archive
    
    The copy() method was used instead of replacement selection in the BTW
    paper to compare the overhead of partially-sorted with traditional log
    archiving. We probably won't be using it again, and it actually needs
    to be rewritten since the latest refactorngs, so I'm removing it for
    now.
    Removed dependency bet. ArchiverHeap and BlockAssembly
    
    Eliminated queueing mechanism on writer thread. Run boundaries now set
    by adding the last LSN of each block to the block header in the assembly
    process. When run file is closed, the writer thread then knows the run
    boundary by keeping track of the las LSN of the last written block.
    Isolated file system functionality of log archiver into its own class
    Decoupled LogConsumer from LogArchiver (untested)
    Isolated heap functionality from LogArchiver
    Implemented simplistic log archive index (untested)
    Abstracted log archiving output into class BlockAssembly
    Removed defragmentation code from log archiver
    Copied log archiver files from old plog branch
    Cleaned up CB and page header fields
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Added convenience debug methods to lsn_t
    
    - Method str() returns the lsn as a string. Useful to look at the LSN
    form gdb
    - logrec_t has method lsn(), which does the same as lsn_ck() but is
    easier to type
    Added operator<< into generic_page (for debugging)
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Made vid_t a simple typedef and deleted volid_t
    Updated handling of CLSN field of pages
    Added committed LSN field to page header (for clog)
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    reviewer comments
    converting to BOOST_STATIC_ASSERT
    changes from Alistair review feedback
    better class comments
    calculate checksum function is no longer inline
    cleaned up generic page header's fields
    pulled down some more B-tree fields
    removed unused private store page field
    moved down two B-tree fields
    removed no longer in use constants
    pulled up generic page formatting
    accessors from fixable_page_h to generic_page_h
    new class generic_page_h that is the superclass of all page handle classes
    created a btree_page_header class to avoid need for hardwired constants
    that must stay in sync
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    more cleanup
    removed pragma interface/implementation
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    pulled in implementation of bitmap into alloc_page class.
        Cleaned up checksum algorithm (better warning, removed bug where
    code would allow checksumming beyond the end of a page given different
    parameters.)
    initial pullout of page headers into a new type, generic_page_header
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed page-img-logrec nonsense from decoupled cleaner
    Decoupled cleaner optimization with page-img log records
    Decoupled cleaner is back!
    Updated decoupled page cleaner
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Fixed B-tree verify
    
    - Using root PID instead of store ID to map pages into verification
    contexts.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed normal restart w/o redo
    Better defaults for page cleaner and eviction
    Decoupled cleaner is back!
    Removed old restore usage in vol_t
    Fixed more assertions
    Implemented cleaner without policy (no_policy)
    Updated use of refcount in page cleaner
    
    - Refcount is reset to zero after cleaning
    Updated cleaner default options
    
    - Interval is -1 by default now (don't run unless requested)
    - If no workspace size is given, take 1/128th of buffer pool size
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Cleaner LSN fixes
    Fixed CB pinning and its use in cleaner and eviction
    Not syncing every page flush in cleaner
    
    - Goal here is to exploit I/O parallelism, like in SSDs, to dramatically
    improve cleaner throughput.
    - To that end, a bunch of write calls are performed for multiple
    clusters of adjacent pages in the cleaner workspace, but fsync is
    invoked only once for the whole workspace.
    - Marking pages as clean and logging the page writes only happen after
    the fsync call.
    Correct recovery of dirty pages in nodb mode
    Cleaner should acquire latch before modifying cb
    Setting ignoreRestore on cleaner writes
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Updated decoupled page cleaner
    Added stress test for page cleaner
    Added cleaner option to only write large clusters of pages
    
    - Requires new logic in the bf_tree_cleaner::clean_candidates loop
    - Also added timer stats for cleaner
    Updated/fixed cleaner wakeup mechanism
    Small changes on some assertions
    Cleaner refactoring III: simplified bf_tree_cleaner
    
    - Cleaning process is now more modular and with fewer lines of
    code.
    Implemented STL allocator using posix_memalign
    
    - Using it in page_cleaner_base so far
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Updated decoupled cleaner to use a single volume
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Fixing deadlock in page cleaner
    Assume the buffer is full of dirty pages.
    We acquire the latches all the way from parent to leaf node.
    Then the cleaner kicks in. Cleans all the pages and flushes them to disk.
    After flushing it tries to mark the cb in the buffer pool as clean, so it has to acquire a latch.
    However, we are still holding the latch in the parent node, ans so cleaner gets stuck.
    We fixed that by making the cleaner try to latch, if it fails we leave the page as it is (dirty)
    We have to archive until durable_lsn, not curr_lsn
    curr_lsn may refer to the skip log record in the end of every log partition.
    If the archiver reaches this log record, it assume it partition is over and will wait for a new partition from now on.
    We decrement the dirty_page count only when the page was indeed dirty
    Activating a cleaner is now only a async signal
    In other words, it does not guarantee that the cleaner was awoken
    Adding in_real_hurry mode to page cleaner
    In case the buffer pool is 75% full of dirty pages and there is no archive file for the cleaner to use, the cleaner forces the log and the archive in order to be able to clean pages.
    Changing cleaner buffer from vector<generic_page> to generic_page*
    Now that vol_t::read_page() requires the buffer to be aligned, we made this change, because it was cumbersome to aling a vector<generic_page>
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding page_cleaner logic and concurrency control
    Adding page_cleaner source files and test files.
    Added option for single-pass restore
    Decoupled cleaner optimization with page-img log records
    Decoupled cleaner is back!
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Added pinned_for_restore field to bf_tree_cb_t
    Added small useful functions to bf_tree and fixable_page_h
    Bufferpool prefetch for instant restore
    Added buffer-pool infrastructure for new instant restore
    Small fix on GenericPageIterator
    Fixed some nobd bugs and default options
    
    - Fuzzy checkpoints do not scan buffer frames in nodb mode
    - chkpt_m::_use_log_archive must be set in nodb mode
    Added fetch_page log records for debugging
    Cleaner now has both async (dedicated thread) and sync (on-demand) modes
    Using shared_ptr to manage cleaner and evictioner
    Buffer-pool warm-up now configurable with sm options
    
    - Also starting background recovery in instant restart only after
    warm-up
    Switched to thread-local, single-allocation SprIterator
    Various fixes to traditional ARIES restart
    Brought back traditional fuzzy checkpoints
    Clean shutdown waits until all frames are clean
    Correct recovery of dirty pages in nodb mode
    Kits now supports crash and recovery in the same execution
    
    - Also implemented wait for warmup
    Detecting warmup based on hit ratio & other updates
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Removed small warning (initialization order)
    Fixed life-cycle of GenericPageIterator
    
    - Implemented proper copy constructor and assignment
    Cleaner tolerates invalid parent in some cases
    
    - Added write elision option
    - If write elision is on and pointer is unswizzled, page cleaner is now
    free to evict page without a valid parent pointer
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Bugfix: worker_thread round counter must be signed
    Fixed & generalized wait/notify behavior of worker_thread_t
    Constructing evictor eagerly with bf_tree_m
    Fixed truncation with no-db mode
    Fixed initialization of bf_tree_m::_root_pages
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Adding GCLOCK evict policy
    
    Two options control que policy used:
    1. "sm_evict_policy" = "latched" | "gclock"
    
    In case of "gclock", there is an option "sm_bufferpool_gclock_k" that is an int
    indicating the GCLOCK k parameter (every time a frame is referenced, the count
    is set to K).
    Minor formatting changes
    Replace old eviction method for call to new thread
    
    Whenever a new free frame is required, we wake up the page evictioner and wait
    on a condvar. For every frame freed, the evictioner will wakeup someone waiting
    on the condvar. This way, the evictioner thread free many frames per round, but
    wakes up a waiting-thread every time a frame is freed.
    Adding initialization points of evictioner thread
    
    The page evictioner is not being called yet. The old eviction routine is still
    the one being called.
    Adding initial file for evictioner thread
    Removing obsolete code in bf_tree.h
    
    The code removed was not being used or referenced anywhere else in the code.
    Moving #defines to proper file
    
    Defining variable in the source files might generate unpredictable bugs if
    dependency between compilation units change.
    
    For example, #define BP_ALTERNATE_CB_LATCH was done in bf_tree.h, but used
    also in bf_tree_cb.h. If someone else included bf_tree_cb.h without #define,
    weird behaviors would happen.
    Assorted bugfixes to restore code
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 3]
    
    - Fixed eviction and unswizzling
    - Still having trouble with eviction getting stuck due to invalid parent
    pointers though. Need to fix that next...
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    Bringing back swizzling [part 1]
    
    - Unswizzling for eviction currently not implemented
    - First attempt -- not tested yet
    bf_tree cleanup: removed unused methods and flags
    Removed uses of SIMULATE_MAINMEMORYDB and SIMULATE_NO_SWIZZLING
    Replaced occurrences of "shpid" with "pid"
    
    - Also renamed _fix_nonswizzled to fix, in preparation for next steps
    bringing back swizzling
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Fixed shutdown of log, vol, and bf_tree
    
    - Added shutdown method to bf_tree
    - Invoking shutdowns in correct order
    Added ref_count_ex on bf_tree_cb to count only X-latch acquires
    
    - Also see comment on bf_tree.h: we should reuse the mechanism in
    latch_t to count references and get rid of counters in the control block
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Removed legacy LATCH_Q mode
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Initializing cleaner lazily & fixed log_truncate option
    
    - Log truncation should be off by default, and it has nothing to do with
    sm_format
    - Cleaner should only be initialized if it's ever used, i.e., if
    get_cleaner is called
    - This makes for quicker startup & shutdown during test cases
    Page cleaner acessed directly with bf_tree::get_cleaner
    Removed support for careful write ordering
    
    ... which never really worked and breaks instant restore, so we don't
    really need it.
    Removed unused and unecessary header files
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Introducing page_cleaner_base generic class
    
    - virtual class for page cleaner (bf_tree_cleaner now inherits from this class)
    - join_cleaner(timeout_t) replaced for simple join(), since timeout_t seems not to be working anymore
    - request_stop_cleaner() and join() unified into new shutdown() method
    - take_interval() and interval_millisec_min/max removed. Cleaner now wakes up every fixed time and clean pages, even if no implicit request was made
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding page_cleaner logic and concurrency control
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Implemented simple warmup thread for buffer pool
    
    - Currently just traverses all Btrees in depth-first order and fetches
    pages until buffer is full or all trees are traversed.
    - A better warm-up solution would be nice, e.g., using a fetcher daemon
    and taking log data into consideration.
    Fixed cleaner bug by comparing page LSNs
    
    - Before marking a page as clean, the cleaner must check if the page LSN
    did not change since the written copy was taken. Furthermore, it must
    properly latch the page.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Reorganized fix method for better comprehension
    
    - Removed/adjusted the long comments
    - Removed unnecessary code
    - Restructured control logic for easier readability
    More updates on new eviction algorithm
    
    - Removed all the "clockhand" stuff from the old algorithm
    - Changed the eviction lock from TATAS to pthread mutex
    - Added some comments
    Deleted all code related to old eviction
    
    - All methods of hierarchical eviction deleted
    - Also deleted everything related to "imprecise" bf_hashtable lookups,
    which existed only for the old eviciton.
    Properly setting parent pointer on btree operations
    
    - Any operation that changes the parent of a note (adoption, split, and
    growth) must update the hashtable to reflect the changes. Otherwise, the
    eviction algorithm cannot find parents and therefore cannot evict.
    Removed stuff related to maintaining CB parent pointer
    
    - Basically deleted all parts of the code using the flag
    BP_MAINTAIN_PARENT_PTR and all the swizzled_lru stuff, which was
    commented anyway.
    Updated bf_hashtable to use pair of bf_idx
    
    - Every entry now contains a pair of bf_idx values, which we can use to
    store the parent cb index.
    - Also updated the find methods to return bool and pass the return value
    as argument.
    Turned bf_hashtable into a template
    
    - Goal is to allow storing two bf_idx in the buffer hash table: one for
    the CB of the page itself, and one for the CB of its parent.
    Basis for new eviction algorithm
    
    - Gave up on "hierarchical traversal" idea because it is simply broken.
    A B-tree cannot be properly traversed without acquiring latches --
    otherwise we could apply the same latch-free mechanism of eviction to
    normal traversals! I was getting all kinds of inconsistencies, and tried
    to fix them for a while, but the mechanism will always be unreliable.
    - New approach simply sweeps through the control blocks sequentially and
    tries to latch a page and its parent (in reverse order). If the latching
    succeeds (done conditionally) and the page is a leaf, then it is
    selected for eviction.
    - In terms of locality and hit ratio, we don't expect this to work
    better than LRU or clock, but it should still be better than random.
    - This approach is still not really working, because parent pointer is
    hard to maintain, and so we quickly come to the situation where all
    pages in buffer are unavailable for replacement.
    - New approach comming in the next commits!
    Removed occurrences of eviction-policy variable
    Enabled parent cb pointer on buffer
    
    - Control blocks used to hold a pointer to the parent when swizzling is
    activated. I turned this back on with the BP_MAINTAIN_PARENT_PTR flag.
    - My goal is to use the parent pointer on the new eviction algorithm.
    - Also commented out all stuff related to the swizzled_lru list.
    Moved EvictionContext into bf_tree_evict.cpp
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Removed MAX_VOL_COUNT and fixed bf_cleaner volume mgmt
    
    All places that ask for the maximum number of mounted volumes now access
    vol_m::MAX_VOLS instead of the constant MAX_VOL_COUNT. However, this
    behavior is not entirely correct, since we need to distinguish between
    the maximum number of mounted volumes (MAX_VOLS) and the maximum number
    of volumes that can ever be created (MAX_VID). Right now, the two are
    undistinguishable, but we may want to fix that in the future.
    
    Simplified volume management in the buffer cleaner. Cleaner thread is
    assigned to volume based on a simple mod operation and reserved slot 0
    for "no volume" was eliminated from certain arrays, since it was not
    used (at least one cleaner thread must always exist).
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Refactored bf_tree constructor to use sm_options
    
    Instead of parsing/gathering options in sm.cpp and invoking the
    bf_tree_t constructor with a bunch of parameters, the cosntructor now
    takes the sm_options as parameter directly. We should have all
    "managers" be initialized this way.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Modified test code so it is easier to merge with changed code from master.
    More bug fixes for Instant Restart milestone 2.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    fixed typo comments
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    addressed Mark's comments
    moved child_emlsn code to handle class
    Incremental check-in for the work in Checkpoint and Log Analysis.
    hierarchical eviction in bufferpool
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    more testcases, backup folder option, bug fix
    Bug fixes
    SSX chaining
    merge with bufferpool change
    Typedef and constant value definition for bf_tree_m::find_page_id_slot
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    updated emlsn on eviction
    crabbing from Q is now handled by fixable_page_t correctly
    removed unnecessary quick check that page was correct as crabbing will
    detect any problems
    pass back success state via ticket rather than separate boolean for bf_tree_m::fix_with_Q_nonroot
    added basic Q ticket plumbing
    added comments for new methods
    new fix_with_Q_nonroot method
    initial version of fix_with_Q_root
    more uses of _is_valid_idx
    fixed concurrency errors in fix_nonroot and fix_root
    new function _is_valid_idx that does not require holding the latch as a precondition
    fix spelling mistake
    simple spelling fix; committing so can change branches
    removed unused print_slot function that was violating encapsulation
    move B-tree specific headers (as marked) from generic page header to
    btree_page
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    enable the alternative latch layout for all configurations including no-swizzling. it looks like it helps there as well
    Bufferpool keeps track the number of swizzled pointers per inner node. If an inner node has no swizzled pointers then its a candidate for replacement. This is useful when the bufferpool runs low in memory. Also we have seen a case where cold inner nodes touched by a burst stay in the bufferpool and cause hot data pages to be evicted instead.
    Removed commented out code
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Addressed issues raised in review request 10:
    -added comment explaining why we have the new layout
    -fixed the blockcnt + 1
    -made maximum value of refcount a parameter
    Encapsulated access to control block table and latches behind buffer pool API. This gives us flexibility in implementing layout of control blocks and latches without having to make drastic code changes. I implemented a new allocation scheme that alternates control blocks and latches in this fashion: |CB0|L0|L1|CB1|CB2|L2|L3|...
    This schme helps removing a pathology that I believe is related to the L2 spatial prefetcher. See Jira Issue 119
    Macro flag to enable/disable inner-node page replacement
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    bunch of scripts to run swizzling experiments; some swizzling bug fixes: hierarchical clock didn't take refcount into account when selecting pages to unswizzle
    Build multiple targets (libraries) for the three difference cases we are interested in: swizzling, no swizzling, and in-memory
    Picking up more changes from the merge with the Hideaki 2012 branch.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Added fetch_page log records for debugging
    Logging page evictions for debug
    Renamed logrec type page_evict to update_emlsn
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Fixed ARIES restart with proper alloc & stnode logging
    Detecting warmup based on hit ratio & other updates
    Fixed adding backups
    Compressing btree split logrecs when archiving
    
    - Instead of simply duplicating the logrec on both pids involved, we
    eliminate the redundant information for each pid.
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Bugfix: add_backup is an SSX
    Fixed compilation in gcc5
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Removed logrec category field
    
    - Category can be derived statically from type, so I removed the field
    in the logrec header and converted get_logrec_cat into a constexpr
    function. The logrec_t::cat() function now calls it using the _type
    field.
    - Removed the undoable_clr stuff, which seemed to be some deprecated
    stuff from old Shore times.
    - Left the byte in the logrec header to tell if logrec is a CLR. I.e.,
    the t_cpsn category flag was the only one that could change at runtime.
    Ideally, it would also not be needed if there is a dedicated CLR logrec
    type which just points to the LSN being undone.
    Removed t_rollback flag from log records
    
    - It didn't seem to be used for anything at all
    Fixed compilation on gcc 4.9
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    Properly logging initialization of stnode_cache
    
    - Log record must be generated when an empty stnode cache is created in
    order to format the stnode page correctly.
    - This fixes some related bugs in some unit tests.
    Fixed logrec TID assignment transaction rollback
    
    - Critical bug introduced with new XctLogger
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Made tid_t a simple uint instead of its own class
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Removed deprecated page deletion stuff
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Got rid of old "plog" stuff
    Cleaned up includes of logrec.h
    Forgot to delete logtype_gen.h
    Moved some logging logic from xct_t to XctLogger
    Replaced log "stub" calls with generic Logger
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Fixed log analysis bug
    
    - Because we were using is_page_update() to track dirty pages,
    compensation log records were not being processed as dirtying updates,
    causing wrong PageLSN computation.
    Updated stress_cleaner program
    
    - Allows reading page accesses from a trace file or generate them
    randomly
    - Optimized candidate handling
    Removed deprecated store ID on chkpt_buf_tab
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Fixed some restart bugs & general clean-up
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Added chkpt_t test and fixed bugs found so far
    Clean-up of the log analysis mechanism [part 2]
    
    - Simplified and fixed behavior of functions used to mark tx as active
    and page as dirty. The logic assumes a backward scan only.
    - Simplified the logic of processing bf, xct, and lock tables, so that
    the methods could be removed and the code inlined in the big log scan
    loop.
    - Removed some unnecessary stuff (e.g., undo_nxt in tx table)
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Changing constructors of chkpt dev and backup table
    Modified these constructors so they match the pattern followed by the other contructors.
    Removing empty constructors.
    These empty constructors for the checkpoint tables classes were added before to allow instantiating these types as part of the new checkpoint infrastructure. Design decisions were made. Long story short, the new checkpoint infrastructure is going to use plain vectors instead of the table structures already defined.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Assorted small fixes
    
    - Converted an ERROUT into DBG
    - Updated log archiver tests for last commit
    - Fixed logrec null_pid() method
    Fixed undefined reference on logrec_t::type_str()
    
    - Inline methods must be on header file.
    Added logrec fill method with just page ID as parameter
    
    - Useful for operations such as alloc_a_page, which do not actually use
    a fixed page image, but still refer to a page id.
    - Currently, only volume is set, but in the future, once we fix the
    metadata recovery stuff, the ID of the affected alloc page should be
    used.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Fixed bug on backup tab serialization
    
    - Deserializing strings using the >> operator requires each string to
    be followed by a newline character
    - Structures such as the chkpt_backup_tab_t must be aligned, otherwise
    their sizeof does not match the sum of their components' sizeof. This I
    learned recently from Stroutroup's book and luckily I realized that when
    debugging this.
    Added convenience debug methods to lsn_t
    
    - Method str() returns the lsn as a string. Useful to look at the LSN
    form gdb
    - logrec_t has method lsn(), which does the same as lsn_ck() but is
    easier to type
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Fixed bug on btree split log record
    
    - Prev pointers were switched (prev2 pointing to previous update on
    page1 and vice-versa). Fixed constructor method and its invocaiton to
    produce the correct assignment.
    
    - Aldo fixed log archiver to correctly set previous pointer on
    duplicated multi-page logrec.
    Added static get_type_str() to logrec_t
    
    - Allows getting the name of a given kind_t value.
    Adding the initial chkpt_t infrastructure.
    We are re-using existing types defined in logrec.h for the checkpoint tables.
    Empty constructors were added to these table types.
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Implemented checkpoint and restart for vol backups
    
    Added a chkpt_backup_tab log record, similar to chkpt_dev_tab. It keeps
    track of the paths for the backup files of each volume. During restart,
    the log records are simply replayed. Since we don't have delete_backup
    operations so far, there is no need to replay them in reverse order, as
    done for mounts/dismounts.
    
    (Untested)
    Removed SM level 1
    Duplicating multi-page logrecs on log archiver
    
    Multi-page log records are replayed once for each page involved. In the
    case of Restart and Single-page recovery, this is achieved by merges and
    bifurcations in the per-page log chain. For Restore, however, we must
    replicate the log record so that is replayed for each page involved.
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Added store number to logrec header
    
    Same idea as in page header: operations that need the store number must
    get it from an extra header field.
    
    Also updated the fill() method and added other fill() variants for
    convenience.
    Changed valid_header() to accept lsn_t::null as parameter.
    New generic allocation mechanism for xct_t and related classes
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Modified test code so it is easier to merge with changed code from master.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    moved module comments
    more code comments
    SPR dumping feature, new testcase, and bug fix
    merged with master
    Added SPR APIs
    Added SPR APIs
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    Fixing includes
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    generic_page_h -> fixable_page_h
    Put in BOOST_STATIC_ASSERT (with help from Haris -- thank you, Haris!).
    Put back in the _page_prv fields that got lost when merging with Mark's changes.
    Still need to fix asserts.
    Added assert that xidheader is 16 bytes.
    Added an assert to verify size of the structure.
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    page_p -> generic_page_h
    page_s -> generic_page
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    In preparation for adding _page_prv, added "xct" to:
          logrec.h:    lsn_t               _xct_prv;
          logrec.h:logrec_t::xct_prev() const
          logrec.h:logrec_t::set_xct_prev(const lsn_t &lsn)
          log.h:    bool xct_next(lsn_t& lsn, logrec_t*& r);
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Fixed some tests
    Fixed B-tree verify
    
    - Using root PID instead of store ID to map pages into verification
    contexts.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Page cleaner acessed directly with bf_tree::get_cleaner
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Removed old & unused "pmap" stuff
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Replaced all occurrences of volid+snum with stid_t
    More bug fixes for Instant Restart milestone 2.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    *_key's -> get_key
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    cleaned up documentation of assignment operator for fixable_page_h
    changes from Alistair review feedback
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_s -> generic_page
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Decoupled cleaner is back!
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Not syncing every page flush in cleaner
    
    - Goal here is to exploit I/O parallelism, like in SSDs, to dramatically
    improve cleaner throughput.
    - To that end, a bunch of write calls are performed for multiple
    clusters of adjacent pages in the cleaner workspace, but fsync is
    invoked only once for the whole workspace.
    - Marking pages as clean and logging the page writes only happen after
    the fsync call.
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Added cleaner option to only write large clusters of pages
    
    - Requires new logic in the bf_tree_cleaner::clean_candidates loop
    - Also added timer stats for cleaner
    Updated/fixed cleaner wakeup mechanism
    Implemented STL allocator using posix_memalign
    
    - Using it in page_cleaner_base so far
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Updated decoupled cleaner to use a single volume
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Changing cleaner buffer from vector<generic_page> to generic_page*
    Now that vol_t::read_page() requires the buffer to be aligned, we made this change, because it was cumbersome to aling a vector<generic_page>
    Removing old commentary
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding page_cleaner logic and concurrency control
    Adding page_cleaner source files and test files.
    Removed virtual methods from archiver workspace memory manager
    Added a bunch of assertions to log archiver code
    
    - Also wrote new mem_mgmt test
    Fixed mem_mgt for larger blocks
    
    - Page-img compression results in log records larger than 8192 bytes,
    which requires larger max size in the class fixed_lists_t.
    - Larger max size cause a small bug that was fixed.
    Fixed bug in archiver workspace
    
    - Memory manager msut use a buffer size which is multiple of the maximum
    block size. Otherwise neighbor calculations and coalescence will fail.
    Fixed some leaks and valgrind errors
    Fixed bug on archiver memory manager
    Added destructor for archiver memory manager
    Copied log archiver files from old plog branch
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Removed "robust" b-tree methods
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Replaced log "stub" calls with generic Logger
    Make sure full_logging is always false in format_steal
    
    - Further clean it up later
    Trying to make smthread_t fully static (huge commit from hell)
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Renamed macro 'align' to avoid naming conflict with C++11's std::align.
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Bringing back swizzling [part 3]
    
    - Fixed eviction and unswizzling
    - Still having trouble with eviction getting stuck due to invalid parent
    pointers though. Need to fix that next...
    Replaced occurrences of "shpid" with "pid"
    
    - Also renamed _fix_nonswizzled to fix, in preparation for next steps
    bringing back swizzling
    Cleaned up CB and page header fields
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed sm_du_stats
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Bug fix (Issue #11).
    Whitespace changes
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Fixed btree_page::delete_range
    
    Basically, my understanding of memmove() was all wrong and the deletion
    of item bodies was inconsistend.
    
    Adapted method to perform memmove correctly and delete item head and bodies
    together one by one. This may not deliver the best performance, but it
    should be robust enough with random insertion orders.
    Whitespace changes
    Fixed B-tree split by deleting body space
    
    B-tree items consist of a head, which is a fixed-length header stored in
    the head array from left to right, and a body, which can be
    variable-length (but multiple of sizeof(item_body)) and is stored right
    to left.
    
    The previous split operation only deleted entries from the head array,
    without properly deleting the associated bodies.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Updated handling of CLSN field of pages
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Attemped to fix a full logging page rebalance bug but did not get anywhere, check in the current code although it is not completed.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Fixed a bug on normal shutdown with transaction rollback where the transaction contains a page split through full logging.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Bug fixes for page rebalance full logging.  The very basic full logging is working but Still have more issues to investigate, the feature is not fully functional at this point.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Minor change.
    Initial implementation of full logging for page balance operation, code is not tested at this point.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    Updated the milestone 1 design document, also a few minor code changes.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    fixed bad assertions that assumed LSN's are always valid (not true when logging is not enabled)
    New log type for b-tree insertion
    moved child_emlsn code to handle class
    complex testcases for SPR and bug fixes
    removed unneeded function, init_as_empty_child, in favor of existing format_steal
    removed bad assertion in format_steal that assumed prior page was a
    B-tree page
    added a new_lsn argument to format_steal (previously it kept whatever the
    page's LSN previously was)
    removed init_fix_steal function in favor of calling fixed then format
    (we are separating fixing from formatting for more needed flexibility)
    merge with bufferpool change
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    addressed code review feedbacks
    SPR dumping feature, new testcase, and bug fix
    trivial bug fix
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    pulled out in-line definitions to end of file
    made helper check space for insert private
    more cleanup of private record accessors
    pulled in key length, poor man's key types and constructors into class itself
    both robust and non-robust search are now separate methods rather than
    one being #ifdef'd out
    making two versions of search more parallel
    forgot to bump copyright year
    fast path is also now robust
    new robust version of search (currently replacing old one via #if's for
    testing)
    fast path is completely robust now but slow path needs work
    length of key for leaf items no longer includes prefix length
    refactoring w_rc_t
    got rid of get leaf fields
    new pack functions for packing records
    more uses of predict leaf data length
    clarified that get_rec_space does not take -1 as an argument
    removed need for rec_leaf
    replaced dat_leaf[_ref]
    new element accessors, element and copy_element
    removed need for rec_node
    new internal record accessor, _element_offset
    *_key's -> get_key
    pulling unpacking of keys code into *_key methods
    rearranging functions
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    converted some code to use _compare_key_noprefix
    put back code for optimizing search for leftmost key but ifdef'd out to
    prevent software rot before we decide what to do with it
    very minor refactoring preparation for making robust_search
    unified _compare_{leaf,node}_key_noprefix into one function
    fix for max_entry_size accounting issue
    cleaned up helper function
    updated comments for search_node
    fixed a couple of uses of search_node to better use new orthogonal interface
    new_search->search, replace search_leaf with search
    removed original search function (references) in favor of search_leaf
    and search_node as appropriate
    removed optimization for inserting in reversed order per Goetz
    Merged two versions of search using (for the moment) a new routine new_search
    new version of search_node
    initial revised version of search_leaf
    removed sequential scan version of search_node (#ifdef POORMKEY_SEQ_SEARCH)
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    bug fixes: assert not being called in release mode, klen going out of
    scope when used in a cvec_t
    more cleanup
    commented all item API functions
    renamed fixed length item fields
    adding comments
    more interface cleanup
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    working on removing references to slot_sz
    removed get_rec_size* functions in favor of new get_rec_space function
    based on item_space
    
    removed dead code page_usage
    introduced predict_item_space
    removed use of old interface (e.g., slot_addr)
    removed insert_slot
    modified reserve_ghost take element_length rather than record size
    delete_slot -> delete_item
    finished converting resize_slot to resize_item
    replace_el_nolog now using item API
    new item_resize function
    fence packing now excludes length
    removed some now dead code
    made non-debug mode compile again (unused variables)
    inlined _insert_expand_no_log, removed another occurrence of insert_slot
    bugs fixes to item code
    replace another occurrence of slot_insert
    introduced insert_item, replaced one usage of insert_slot
    now should be using packing function for all fence slots
    introduced a packing function for the fence slot
    fixed slot length definition for slot 0
    clarified difference between truncated key length and normal key length
    hold together node field access code
    pulled together common code for accessing leaf item fields
    made an accessor for the poor man's key, _poor
    new API for items; beginning to switch code to it
    cleaned up set/unset_ghost asserts
    converted compaction routine
    removed unused popping feature of defrag
    converted slot consistency checker
    replaced _append_nolog with calls to slot_insert
    changed another piece of code to use slot_insert
    added insert_slot
    code for marking slots as ghost/non-ghost, resizing slots
    pulled out btree_page_h class
    removed data array
    delete_slot pulled out, added typedef's for slot_body
    replaced sinome used of casting
    minor code reformatting
    code reformatting
    un-inlining functions in page_bf_inline.h
    cleaned up generic page header's fields
    moved down two B-tree fields
    removed/changed incorrect/unneeded references to generic_page_h
    removed unused print_slot function that was violating encapsulation
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    removed pragma interface/implementation
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed more headers, fixing their previous uses
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Made vid_t a simple typedef and deleted volid_t
    merged okvl branch
    Private lock hashtable to quickly check if the lock is already taken
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    RAW-style lock manager
    Private lock hashtable to quickly check if the lock is already taken
    refactoring w_rc_t
    Follow-up cleanings
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    _check_compatible can now return a lsn to add to read_watermark if the
    lock is granted (because of control lock violation.)
    codified the unconventional access rules for some of the fields of
    lock_queue_entry_t; this allowed moving several operations to SAFE via
    some asserts checking which thread was doing the work
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Made alloc_cache constants constexpr
    Fixed ARIES restart with proper alloc & stnode logging
    Added option for store clustering
    
    - Also fixed metadata initialization without clustering.
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Added stress test for page cleaner
    Implemented alloc_cache_t::write_dirty_pages
    
    - Since our alloc cache does not maintain bitmpas within page images,
    relying instead on its internal data structures, a special method is
    required to flush these pages in the page cleaner.
    - The method simply reads an old page image and replays updates on it
    with single-page recovery, but it does this only for pages which were
    actually updated since a given LSN.
    Fixing bf_tree_cleaner not flushing alloc and stnode
    
    force_volume() explicitly reads this pages from disk, triggering single page recovery, and then writes them back.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed unused vol field from alloc_cache
    
    - Volume was only used in a single assertion, so it was not required as
    a member variable. Data is accessed indirectly through bf_fixed, which
    also supports a null volume, as long as no flushes are performed (i.e.,
    read-only mode). This is possible because the constructor directly takes
    a file descriptor as parameter.
    - This functionality was implemented to extend the dbinspect command of
    zapps with allocation information. We basically need to load the
    alloc_cache of aa volume without creating or mounting a vol_t object.
    Restore goes only to last used page ID
    
    - Information is extracted from alloc_cache, which is expected to be
    consistent by the time the device is marked failed. Furthermore, no
    allocations can occur once failed is set, so there are no "lost
    allocations"
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Added comments and error messages to alloc_cache_t
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    alloc_p-> alloc_page_h
    renamed:    src/sm/alloc_p.h -> src/sm/alloc_page.h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed 'undo' parameter from B-tree methods
    Removed sm_du_stats
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Several bug fixes for 'Instant Restart' milestone 2.
    Touch method to quickly pre-load tables
    removed magic numbers with max_entry_size checking
    fix for max_entry_size accounting issue
    working on removing references to slot_sz
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Added put operation to zero.
    
    Added a put operation, which is essentially "update, or insert if didn't exist".
    
    src/sm/btree.* : add btre_m::put
    
    src/sm/btree_impl.* :
    
    Separated the traversal and getting if it was found/a ghost for insert and update into new function
    _ux_get_page_and_status.
    
    Split insert & update core functions into a head and a tail part; tail does the "heavy lifting" of
    modification, head does the searching.
    
    Use insert_core_tail and update_core_tail to implemetn _ux_put_core and _ux_put.
    Zero branch from subversion rev 11038
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Added latency measurements to transaction commit
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Introducing vol_t::read_many_pages()
    in analogy to vol_t::write_many_page()
    Change shpid_t to lpid_t in event logs.
    Change shpid_t to lpid_t in event logs.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Moved definition of sysevent epoch to its own cpp file
    Fixed memory leak on sysevent log records
    
    - Missing "delete" invocation after allocating object with "new"
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Removing erroneous assertion (fixes #22 ... again)
    Fixed CArray concurrency bug (issue #22)
    parameterize carray active slot count
    bug fix on delegated-buffer-release
    Added MCS_EXPOSE options
    Ported Consolidation Array
    Implemented multi-level log archive
    Got rid of old "plog" stuff
    Cleaner refactoring III: simplified bf_tree_cleaner
    
    - Cleaning process is now more modular and with fewer lines of
    code.
    Implemented STL allocator using posix_memalign
    
    - Using it in page_cleaner_base so far
    Fixed some compiler warnings
    Plog implementation with dynamically growing memory
    New generic allocation mechanism for xct_t and related classes
    Implemented get_byte_distance for two LSNs
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Goodbye fileoff_t!
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Recycling chkpt files regardless of log-file recycling
    Chkpt serialization to file (initial code from Lucas)
    
    - Checkpoint data is now serialized to a serparate file instead of as
    embedded *_tab log records.
    Added delete_old_partitions option to log_storage
    truncate_log now deletes truncated log partitions
    Fixed log manager destruction
    
    - delete log was not being invoked at SM destruction
    - Fixed shutdown of recycler thread; moved condvar & mutex inside its
    class
    Cleaned up messy calculations of partition_size
    Added best-effort partition recycling mechanism
    
    - Support for sm_log_max_partitions options, which limits the number of
    partition files in the log directory. At each partition creation, old
    partitions are deleted proactively. If the limit is reached, a forced
    deletion is attempted, but it only works if the min active LSN collected
    on the last checkpoint allow it -- hence the best-effort approach.
    - A true recycling mechanism is only possible with log reservations,
    which we removed because they were messy and not fully effective
    (required "fudge factors").
    Managing partition_t lifecycle with shared_ptr & latching
    
    - All methods now return shared_ptr, which allows automatic control of
    ownership and destruction of partition_t objects
    - All accesses to the partition_t map now acquire a latch.
    - Removed old partition lock
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Refactoring partition_t & removed peek function
    
    - Peek is only necessary to determine the position of the skip log
      record, but it was too cumbersome. The only use of knowing this
      position (i.e., the partition size) is to determine the last LSN in a
      partition for a backward log scan. For now, we disabled it, but a
      better way to achieve that must be implemented
    - Simplified partition_t object by removing many unnecessary fields and
      methods.
    - prime() method of log_storage also reuses partition_t::read
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Whitespace changes
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Made log_storage::_version_major and log_storage::_version_minor public.
    This was need to access the current version from other classes for compatibility purposes.
    Similar members were also made public.
    Since all these members were declared as static const, making them public should not have unexpected side-effects
    Fixed bugs in logbuf_core (tests passing now -- except for TSTAT issues)
    Log refactoring: fixed prime mechanism so logbuf_core can be initialized independently
    Log refactoring: pulled log reservation logic into class log_resv
    Updated/reorganized prime methods in log manager code
    Minor change on log_storage::find_partition
    Fixed fetch method in log_core
    Fixed some of the bugs resulting from log refactoring
    Log refactoring: pulled out log_storage into its own class
    Removed w_stream stuff
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    Follow-up cleanings
    OKVL terminology change and optimizations
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Added documentation to lock_queue_t class on what fields are protected
    by what latches.  Renamed locks to latches when they were actually
    latches.
    
    ifdef'd out _dump(-) as it wasn't being used and was unsafe.
    more cleanup of lock_queue_entry_t:
      added documentation of how field access is supposed to be protected
      Added // UNSAFE's to accesses breaking the rules
    
    fixed so no warnings about unused parameters
    cleaning up lock_queue_entry_t:
      fixed access control to not be public for changeable fields
      changed fields that are initialized at constructor time and never
        changed thereafter to references
      no longer passing in pointers to others that are always NULL in practice
      changes elsewhere are simplest consequences of these changes
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed more headers, fixing their previous uses
    Removed sm_du_stats
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Removed SM level 3
    Removed SM level 4
    
    This begins a series of commits in which I'll attempt to remove the
    concept of "SM levels". The goal is to have independent components (bf,
    log, lock, io, etc.) which can be constructed independently, and a much
    "thiner" ss_m which simply orchestrates the components and delegates API
    calls to them.
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Replaced all occurrences of volid+snum with stid_t
    Removed old index interface from Shore
    Touch method to quickly pre-load tables
    [Shore remnant] Added no-lock option for io_m::get_root()
    Delete dead codes
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    implement ss_m::put_assoc()
    Fixup warnings about unused variables in stubbed out functions
    
    We have several files which stub a LOT of API functionality w/assert(0);
    I've gone through and tried to suppress all of these warnings.
    
    There still are some, but these warnings seem to be actually unused
    variables, rather than warnings related to bits of API we've only stubbed.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Moving #defines to proper file
    
    Defining variable in the source files might generate unpredictable bugs if
    dependency between compilation units change.
    
    For example, #define BP_ALTERNATE_CB_LATCH was done in bf_tree.h, but used
    also in bf_tree_cb.h. If someone else included bf_tree_cb.h without #define,
    weird behaviors would happen.
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    More comments
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    incomplete code for RAW lock. not enabled
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Replaced all occurrences of volid+snum with stid_t
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed more headers, fixing their previous uses
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed includes of bf_hashtable template
    Deleted all code related to old eviction
    
    - All methods of hierarchical eviction deleted
    - Also deleted everything related to "imprecise" bf_hashtable lookups,
    which existed only for the old eviciton.
    Updated bf_hashtable to use pair of bf_idx
    
    - Every entry now contains a pair of bf_idx values, which we can use to
    store the parent cb index.
    - Also updated the find methods to return bool and pass the return value
    as argument.
    Turned bf_hashtable into a template
    
    - Goal is to allow storing two bf_idx in the buffer hash table: one for
    the CB of the page itself, and one for the CB of its parent.
    Added update operation to bf_hashtable
    
    - Will be used by B-tree adoption when parent cb pointer is stored in
    the hash table as well
    addressed Harumi's comments
    hierarchical eviction in bufferpool
    Partial commit of changes necessary to remove volatile modifiers. See https://jira.hpl.hp.com/browse/ZERO-116
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Changed GC pool forest default settings
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Fixed some restart bugs & general clean-up
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Create global 'itoa' function and eliminate the local copies.
    Check in the partically implemented performance test code, so I can check in the rest of the M3 code.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    Added a few primitive M3 test cases.  Also small change to Single Page Recovery record collection buffer allocation, give bigger buffer size if full logging.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    dbgout levels
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    incomplete code for RAW lock. not enabled
    Got rid of old "plog" stuff
    Fixed some compiler warnings
    Plog implementation with dynamically growing memory
    New generic allocation mechanism for xct_t and related classes
    Better defaults for page cleaner and eviction
    Added option for single-pass restore
    Restore: made some stuff static thread_local for performance
    Multi-segment restore + using backupLSN as log replay bound
    Fixed destruction of background restorer
    Deleted gclock evictioner
    
    - Base cleaner can be configured to behave like GCLOCK, so there's no
    need
    Decoupled cleaner is back!
    Fixed wait for restore to be done
    Fixed descturction of BackgroundRestorer
    Fixed deadlock on BackgroundRestorer destruction
    Backup now guarantees zeroed contents when fetching unallocated pages
    
    - With help of new class backup_alloc_cache_t
    vol_t::read_backup now returns void
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Added pinned_for_restore field to bf_tree_cb_t
    Added small useful functions to bf_tree and fixable_page_h
    Fixed initialization of control blocks
    Bufferpool prefetch for instant restore
    Added buffer-pool infrastructure for new instant restore
    Propstats now keeps track of static-store pages
    Removing unnecessary calls to wakeup_cleaner
    Updated use of refcount in page cleaner
    
    - Refcount is reset to zero after cleaning
    Some assertions and new default values for log archiver
    Fixed some nobd bugs and default options
    
    - Fuzzy checkpoints do not scan buffer frames in nodb mode
    - chkpt_m::_use_log_archive must be set in nodb mode
    Added fetch_page log records for debugging
    Logging duration of eviction calls into a file
    Cleaner can't be initialized lazily because there is no concurrency control
    Renamed logrec type page_evict to update_emlsn
    Default eviction is now a simple CLOCK
    Cleaner now has both async (dedicated thread) and sync (on-demand) modes
    Using shared_ptr to manage cleaner and evictioner
    Not calling wakeup_cleaner from restart thread
    
    - but from bf_tree instead, when setting warmup_done
    Various restart fixes
    Buffer-pool warm-up now configurable with sm options
    
    - Also starting background recovery in instant restart only after
    warm-up
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Kick-off cleaner only after recovery is done
    
    - Sumstantial improvement to restart times!
    Switched to thread-local, single-allocation SprIterator
    Fixed control block initialization and race conditions
    Bugfix: bf fix using cb.is_in_use() right
    Fixed use of fuzzy checkpoints with nodb
    Various fixes to traditional ARIES restart
    Fixed CB pinning and concurrency operations for checkpoints
    Fixed fuzzy checkpoints and added assertions
    Brought back traditional fuzzy checkpoints
    Fixed CB pinning and its use in cleaner and eviction
    Clean shutdown waits until all frames are clean
    Fixed recovery in bf_tree_m with nodb==false
    Added _maintain_emlsn option
    Correct recovery of dirty pages in nodb mode
    Detecting warmup based on hit ratio & other updates
    Brought back old comment to clarify code
    Various bugfixes
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Added timer for batch warmup waits
    Cleaner tolerates invalid parent in some cases
    
    - Added write elision option
    - If write elision is on and pointer is unswizzled, page cleaner is now
    free to evict page without a valid parent pointer
    Update parent CB pointer if it's wrong on fix
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Removed bf_tree_evict.cpp
    
    - Method definitions moved to bf_tree.cpp
    Fixed & generalized wait/notify behavior of worker_thread_t
    Constructing evictor eagerly with bf_tree_m
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    Fixed initialization of bf_tree_m::_root_pages
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Bugfix: cleaner initialization in bf_tree_m
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Moved w_findprime() into bf_tree.cpp
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Replaced log "stub" calls with generic Logger
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Adding GCLOCK evict policy
    
    Two options control que policy used:
    1. "sm_evict_policy" = "latched" | "gclock"
    
    In case of "gclock", there is an option "sm_bufferpool_gclock_k" that is an int
    indicating the GCLOCK k parameter (every time a frame is referenced, the count
    is set to K).
    Minor formatting changes
    Adding initialization points of evictioner thread
    
    The page evictioner is not being called yet. The old eviction routine is still
    the one being called.
    Removing #define BP_ALTERNATE_CB_LATCH
    
    Alternate control blocks and latches in the bufferpool is now the one and only
    behavior supported by Zero. We are not supporting older layout anymore.
    Updated & fixed some tests
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    Update bf_tree.cpp
    Removing sleep inside bf_tree::fix()
    
    The thread was sleeping for 10ms, which is an absurd!
    
    Furthermore, even sleeping for a shorter time is just arbitrary.
    Either we do busy-waiting or we implement this properly with condvars, no more
    sleeps. Make Zero great again!
    Fixing manual increment of cb ref count
    
    Let's make it consistent and only increment using the appropriate method.
    Swizzling always enabled for root pages
    
    - Otherwise performance drops significantly
    - TODO: add separate config option to enable swizzling for roots only
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Trying to fix WarmupThread
    Small fix on swizzling
    
    - Generalized condition under which slot is not found on parent page
    when swizzling -- can happen if same pointer is swizzled concurrently.
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 3]
    
    - Fixed eviction and unswizzling
    - Still having trouble with eviction getting stuck due to invalid parent
    pointers though. Need to fix that next...
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    Bringing back swizzling [part 1]
    
    - Unswizzling for eviction currently not implemented
    - First attempt -- not tested yet
    bf_tree cleanup: removed unused methods and flags
    Removed uses of SIMULATE_MAINMEMORYDB and SIMULATE_NO_SWIZZLING
    Replaced occurrences of "shpid" with "pid"
    
    - Also renamed _fix_nonswizzled to fix, in preparation for next steps
    bringing back swizzling
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Added some debug msgs and assertiosn to rollback code
    
    - Hope is to fix bug of per-page chain inconsistency when using instant
    restart.
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Tweaked cleaner initialization
    
    - Moved eager initialization to SM constructor
    - Cleaner has dependency not only on a valid vol object, but also on its
    alloc and stnode caches -- added method caches_ready() for that purpose.
    Fixed shutdown of log, vol, and bf_tree
    
    - Added shutdown method to bf_tree
    - Invoking shutdowns in correct order
    Added ref_count_ex on bf_tree_cb to count only X-latch acquires
    
    - Also see comment on bf_tree.h: we should reuse the mechanism in
    latch_t to count references and get rid of counters in the control block
    Fixed cleaner and bf initialization
    
    - Buffer must be initialized after volume if cleaner starts running
    eagerly
    - Properly initializing eager cleaner and destroying it on shutdown
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Cleaned up CB and page header fields
    Removed legacy LATCH_Q mode
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Initializing cleaner lazily & fixed log_truncate option
    
    - Log truncation should be off by default, and it has nothing to do with
    sm_format
    - Cleaner should only be initialized if it's ever used, i.e., if
    get_cleaner is called
    - This makes for quicker startup & shutdown during test cases
    Page cleaner acessed directly with bf_tree::get_cleaner
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed support for careful write ordering
    
    ... which never really worked and breaks instant restore, so we don't
    really need it.
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Removed class ErrLog and replaced its uses with std::cerr
    Removed size arguments from kits_cmd
    
    - All size arguments passed directly as sm_* options, most of which in
    MB
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Refactored classical page cleaner
    
    Page cleaner now is a single class, no more master-slave.
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Updated decoupled cleaner to use a single volume
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Removing unnecessary calls to cleaner
    Cleaner should flush the buffer ONLY during clean shutdown. In all other occurences it should only make a meaningless request for flushing pages by waking up a cleaner thread.
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed unnecessary force_volume call from uninstall_volume
    Implemented simple warmup thread for buffer pool
    
    - Currently just traverses all Btrees in depth-first order and fetches
    pages until buffer is full or all trees are traversed.
    - A better warm-up solution would be nice, e.g., using a fetcher daemon
    and taking log data into consideration.
    Fixed buffer fixes so that  only one thread attempts read
    
    - Insert into hash table prior to reading page, to guarantee that only
    one thread performs the read of a given page at a time.
    Fixed cleaner bug by comparing page LSNs
    
    - Before marking a page as clean, the cleaner must check if the page LSN
    did not change since the written copy was taken. Furthermore, it must
    properly latch the page.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Reorganized fix method for better comprehension
    
    - Removed/adjusted the long comments
    - Removed unnecessary code
    - Restructured control logic for easier readability
    Acquiring EX latch to read page into a frame
    
    - The _fix_nonswizzled method always latches the frame in the mode
    requested by the caller. However, if the mode is SH and the page must be
    fetched from disk, two threads may attempt to read different pages
    simultaneously into the same frame. Sure, it could be handled by
    verifying and allowing only one read to succeed, but it is simpler and
    more error prone to acquire an EX latch regardless of the requested
    mode. If SH was requested, a downgrade is performed once the read is
    completed and the frame is properly initialized.
    Fixed bugs in fix methods
    
    - Volume install and preload of root page must also latch the page,
    even theough it should not run concurrently -- just following the
    protocol to not have any trouble.
    - Also fixed handling of the case where a page is evicted right before
    acquiring the latch.
    More updates on new eviction algorithm
    
    - Removed all the "clockhand" stuff from the old algorithm
    - Changed the eviction lock from TATAS to pthread mutex
    - Added some comments
    Small fixes for new eviction algorithm
    
    - Unpin for refix does not always hold a latch, so assertion was false.
    Not sure if that's how it's supposed to be. It sucks because it breaks
    our assumption that pin count is only updated when latched. I need to
    study the btcursor code to understand this better.
    - Fixed small bug with cleaner getting an invalid page (vol == 0)
    - Added some comments and debug messages.
    Deleted all code related to old eviction
    
    - All methods of hierarchical eviction deleted
    - Also deleted everything related to "imprecise" bf_hashtable lookups,
    which existed only for the old eviciton.
    Properly setting parent pointer on btree operations
    
    - Any operation that changes the parent of a note (adoption, split, and
    growth) must update the hashtable to reflect the changes. Otherwise, the
    eviction algorithm cannot find parents and therefore cannot evict.
    Removed stuff related to maintaining CB parent pointer
    
    - Basically deleted all parts of the code using the flag
    BP_MAINTAIN_PARENT_PTR and all the swizzled_lru stuff, which was
    commented anyway.
    Fixed pin mechanism and latching on fix calls
    
    - Updated bf_tree_cb_t interface to have a simple pair of pin/unpin
    methods, which perform atomic increment/decrement.
    - My last change to the pin mechanism introduced a stupid (but painful
    to debug) bug in which threads with an SH latch would update the pin
    count in a non-atomic manner, which obviously causes races.
    - Fixed the various fix methods of the buffer pool to latch pages
    correctly and only update the control block once latch is successfully
    acquired.
    - Hopefully, the buffer pool is thread safe now.
    Updated bf_hashtable to use pair of bf_idx
    
    - Every entry now contains a pair of bf_idx values, which we can use to
    store the parent cb index.
    - Also updated the find methods to return bool and pass the return value
    as argument.
    Turned bf_hashtable into a template
    
    - Goal is to allow storing two bf_idx in the buffer hash table: one for
    the CB of the page itself, and one for the CB of its parent.
    Basis for new eviction algorithm
    
    - Gave up on "hierarchical traversal" idea because it is simply broken.
    A B-tree cannot be properly traversed without acquiring latches --
    otherwise we could apply the same latch-free mechanism of eviction to
    normal traversals! I was getting all kinds of inconsistencies, and tried
    to fix them for a while, but the mechanism will always be unreliable.
    - New approach simply sweeps through the control blocks sequentially and
    tries to latch a page and its parent (in reverse order). If the latching
    succeeds (done conditionally) and the page is a leaf, then it is
    selected for eviction.
    - In terms of locality and hit ratio, we don't expect this to work
    better than LRU or clock, but it should still be better than random.
    - This approach is still not really working, because parent pointer is
    hard to maintain, and so we quickly come to the situation where all
    pages in buffer are unavailable for replacement.
    - New approach comming in the next commits!
    Disabled page pinning mechanism
    
    - Pinning mechanism is supposed to allow latch-free operations on pages,
    but it was basically broken. It was used only for page eviction, which
    resulted in many inconsitencies and deadlocks (which is why I am
    currently fixing the eviction algorithm). Therefore, I simply disabled
    it for now.
    - The pin count itself is still used, so that an evicted page is not
    latched and used by mistake -- even though this should not be necessary
    with a better design. However, it is not updated with a CAS anymore,
    requiring instead a latch on the page prior to every access.
    - Also removed some methods related to write-order dependency, which is
    also broken.
    Removed occurrences of eviction-policy variable
    Removed checks for is_swizzling_enabled
    
    - The parts of the code that deal with maintenance of the parent pointer
    in a control block only work if swizzling is enabled.
    - It should be enabled by default, so the check should return true,
    which it isn't doing. But that's not the point...
    - I don't see why we should only maintain a parent pointer if swizzling
    is enabled. (Well, when you think about it, with swizzling disabled,
    there is no need for eviction to do something with the parent, so indeed
    the pointer is not needed. But I'm leaving it like this for now. Proper
    fix should come with new eviction algorithm)
    Enabled parent cb pointer on buffer
    
    - Control blocks used to hold a pointer to the parent when swizzling is
    activated. I turned this back on with the BP_MAINTAIN_PARENT_PTR flag.
    - My goal is to use the parent pointer on the new eviction algorithm.
    - Also commented out all stuff related to the swizzled_lru list.
    Converted eviction into single-thread process
    
    - The eviction code had some thread-safety bug which I could not track
    down. The list of free blocks was becoming inconsistent for some reason,
    so that assertions would fail.
    - Rather than fixing the current code, I decided to make eviction
    single-threaded, which is much more effective and simply makes more
    sense. Preliminary tests show that it works, but it is not very
    efficient. This code needs some refactoring for that.
    Add skip log record to the end of log archive blocks
    
    - Instead of relying on the actual block size on the block header, the
    scanner now stops when it reaches a skip log record.
    - This mechanism provides a cleaner way to open a scan on an arbitrary
    file offset and scan forward from there, without having to zero-out
    blocks.
    Little fix on bf_tree_m::get_rec_lsn
    
    - Removed line that assigned last mount LSN when encountering a page
    with rec_lsn == null
    Fixed and simplified single-page recovery
    
    - Single-page recovery was using the log fetch buffer incorrectly.
      (Fixes issue #17)
    - Simplified collection of log records by simply copying into a (now
    automatically expanding) buffer and replaying directly from this buffer.
    This eliminates the need for a separate list of log record pointers.
    - Added some assertions to replay process.
    - Removed "actual_emlsn" parameter which was never false. If it's to be
    implemented in the future, the same condition can be simulated with
    `emlsn == lsn_t::null`
    Zeroing out virgin pages
    
    - Fixes issue #16 on GitHub
    Using stat to count SPR invocations
    
    - Incrementing a tstat every time single-page recovery is invoked
    instead of printing to the std error output. The stat basically says how
    often a stale page was read from the disk.
    Yet another fix on page replacement
    
    - bufidx_pathway was not being initialized correctly after continuing
    from a previous clockhand
    Moved page eviction code into bf_tree_evict.cpp
    Small fix on buffer replacement
    
    - Frame scan of clock algorithm did not consider the case of a
    single-page B-tree, i.e., where the root itself is also a leaf page.
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Fixed some restore bugs
    
    - Installing volume on demand, by loading root pages as they get fixed
    (in the long run, this technique replaces the method install_volume)
    
    - Do not force volume during buffer uninstall if restore is going on
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    Removed MAX_VOL_COUNT and fixed bf_cleaner volume mgmt
    
    All places that ask for the maximum number of mounted volumes now access
    vol_m::MAX_VOLS instead of the constant MAX_VOL_COUNT. However, this
    behavior is not entirely correct, since we need to distinguish between
    the maximum number of mounted volumes (MAX_VOLS) and the maximum number
    of volumes that can ever be created (MAX_VID). Right now, the two are
    undistinguishable, but we may want to fix that in the future.
    
    Simplified volume management in the buffer cleaner. Cleaner thread is
    assigned to volume based on a simple mod operation and reserved slot 0
    for "no volume" was eliminated from certain arrays, since it was not
    used (at least one cleaner thread must always exist).
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Refactored bf_tree constructor to use sm_options
    
    Instead of parsing/gathering options in sm.cpp and invoking the
    bf_tree_t constructor with a bunch of parameters, the cosntructor now
    takes the sm_options as parameter directly. We should have all
    "managers" be initialized this way.
    Bugfix on setting page LSN in ACP
    Bug fixing, during checkpoint, if an 'used' page did not have rec_lsn (first dirty LSN), most likely the page was allocated but not formatted at this point when the checkpoint was taking, therefore nothing to recovery if system crashed after this checkpoint.  In such case do not record the page in checkpoint therefore Restart process will not mark this page as in_doubt because there is nothing to recover for an unformatted page.  If the page was formatted and updated after the checkpoint, then proper log record(s) would be generated and the page will be marked as in_doubt by Log Analysis phase accordingly.
    Temporary fix for double device mounting (see ticket #3)
    Added some debug messages
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Added uncommitted counter to bf_tree_cb
    Removed old bf_m code
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Bug fixes, also addressed the test break issues in test_logbuf and test_logbuf_scan.
    Moved SPR methods out of log_m and into restart_m
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    Enabled concurrent transaction page loading of in_doubt page, this is for on-demand REDO operation where the user transaction triggers REDO operation in M3, no blocking.
    The M2 behavior was that user transaction is not allowed to load in_doubt page and an error was raised to rollback the user transaction.
    Fixed issue in test code for multi-thread access.
    Fixed an infinite loop bug, also update the 'known issues' list in Recovery.docx to track the I/O layer issues discovered by Caetano.
    Fixed a regression bug from implementing backward scan.
    Also changed the buffer pool flush code so it does not flush in_doubt pages.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Renamed from 'doomed' to 'loser' transaction.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Multiple bug fixes, also draft design doc for milestone 3.
    More bug fixes for Instant Restart milestone 2.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Minor chage in bf_tree.cpp
    Draft design document for milestone 2
    Updated design document for test plan (work-in-progress)
    Modifications based on Goetz's code review comments, also initial test plan.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    SPR experiments
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    RAW-style lock manager
    fixed typo comments
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    addressed Harumi's comments
    log_page_evict to update parent page LSN without EX latch
    stupid set_to_be_deleted flag non-initialized bug fix
    Addressed Mark's code review feedbacks
    complex testcases for SPR and bug fixes
    Incremental check-in for the work in Checkpoint and Log Analysis.
    hierarchical eviction in bufferpool
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Minor changes in checkpoint area, also added synch checkpoint to Recovery, one at the end of Log Analysis, and one at the end of UNDO phase.
    more testcases, backup folder option, bug fix
    bugfix
    Bug fixes
    SSX chaining
    [Bufferpool] Fixed shady testcase code that doesn't create pages correctly
    merge with bufferpool change
    Typedef and constant value definition for bf_tree_m::find_page_id_slot
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    dropped code to explicitly allocate buffer pool on a remote node as this can be done by simply changing the memory policy from within the experiments
    check for null parent before kicking SPR
    updated emlsn on eviction
    bufferpool change
    bufferpool change
    added comments explaining numa allocator
    trivial comment changes only
    more uses of _is_valid_idx
    fixed concurrency errors in fix_nonroot and fix_root
    changed numa_free to my_numa_free to avoid confusion with numa_free defined in numa.h; cmake makefile to build memlat
    added comments to describe when we increment refbit_approximate and counter_approximate
    fix spelling mistake
    buffer pool can use numa allocation routines to allocate memory to specific node
    refactoring w_rc_t
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    replaced sinome used of casting
    move last of buffer manager's direct dependence on btree_page_h
    introduced use of child slot indirection layer
    still have a few level()'s to remove/deal with
    Beginning to install child slot interface between fixable_page_h and the
    buffer manager
    miscellaneous code cleanup
    fixed bug where code was incorrectly assuming a store was unallocated
    if it's root pid was 0
    fixed some shore includes
    Many small changes to eliminate compiler warnings. Work-in-progress.
    moved down two B-tree fields
    removed/changed incorrect/unneeded references to generic_page_h
    removed unused print_slot function that was violating encapsulation
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
    page_p -> generic_page_h
    Assertion check (!is_swizzling_enabled() || parent != NULL) under fix_nonswizzled happens only when child-to-parent pointers are enabled
    more cleanup of stnode_page
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Bufferpool keeps track the number of swizzled pointers per inner node. If an inner node has no swizzled pointers then its a candidate for replacement. This is useful when the bufferpool runs low in memory. Also we have seen a case where cold inner nodes touched by a burst stay in the bufferpool and cause hot data pages to be evicted instead.
    swizzling experiments: implemented bursty workload and fixed sliding window workload to slide at a fixed rate
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Addressed issues raised in review request 10:
    -added comment explaining why we have the new layout
    -fixed the blockcnt + 1
    -made maximum value of refcount a parameter
    Some comments to explain the allocation scheme
    Encapsulated access to control block table and latches behind buffer pool API. This gives us flexibility in implementing layout of control blocks and latches without having to make drastic code changes. I implemented a new allocation scheme that alternates control blocks and latches in this fashion: |CB0|L0|L1|CB1|CB2|L2|L3|...
    This schme helps removing a pathology that I believe is related to the L2 spatial prefetcher. See Jira Issue 119
    Macro flag to enable/disable inner-node page replacement
    -modified experiment select_only to switch on/off oprofile to profile code section
    -identified scalability bottlenecks in statistics collection
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    (1) Fixed race in TATAS implementation. (2) Scripts to run a mixed workload
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    bunch of scripts to run swizzling experiments; some swizzling bug fixes: hierarchical clock didn't take refcount into account when selecting pages to unswizzle
    Disabled the code that collects how many times we swizzle as my quick-and-dirty implementation based on a shared counter will most likely affect any performance results we're trying to get. Need to implement this using Shore's profiling support
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    Accidentally stepped on Oleg's removal of atomic_templates.h when merging in Hideaki 2012 updates (sorry, Oleg!).
    Re-removed it from bf_tree.cpp .
    Picking up more changes from the merge with the Hideaki 2012 branch.
    three tests fail:  39 test_btree_merge, 45 test_crash, 52 test_insert_many
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    - don't install deleted atomic_templates.h
    - remove references to atomic_templates.h from unused files
    Convert arithmetic atomics from legacy to lintel::Atomic
    Eliminate atomic_cas_[32|64]
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed class ErrLog and replaced its uses with std::cerr
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Made vid_t a simple typedef and deleted volid_t
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    RAW-style lock manager
    Private lock hashtable to quickly check if the lock is already taken
    refactoring w_rc_t
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    new function, lock_m::give_permission_to_violate, that a transaction may
    use to give permission to other transactions to violate its locks.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Replaced uses of ArchiveScanner with new ArchiveScan
    Restore small bugfix
    Multi-segment restore + using backupLSN as log replay bound
    No more need to work around garbage pages in restore
    Removed old restore code (farewell part 1)
    
    - Goodbye, old friend. It hurts me deeply to do this after years of hard
    work, but it had to be done. The old must make way for the new. It's
    been a pleasure.
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Bufferpool prefetch for instant restore
    Fixed log replayer for new restore
    Added buffer-pool infrastructure for new instant restore
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Removed readSize parameter from ArchiveScanner::open
    Fixed bug with incorrect log archive read size
    Correct recovery of dirty pages in nodb mode
    Interrupting waitUntilRestored during shutdown
    Some restore fixes
    Disable restore writes while we dont figure out bug
    
    - Bug happens when cleaner flushes a new version of a page and then
    restore later flushes an old one.
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Interrupting restore when performing shutdown
    Support for mixed restart and restore; cleaned up chkpt
    Using 32k read size in nodb batch restore
    Updated stats for log archive and restore
    Restore bitmap using std::atomic, no global critical section
    Fixed use of restore_segment_log
    
    - Logrec is t_system, so we must use log_sys method
    Using shared_ptr to manage archive scans
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Unified classes ArchiveIndex and ArchiveDirectory
    Moved nested classes out of LogArchiver
    Fixed DummyBackupReader for multi-threaded restore
    Replaced log "stub" calls with generic Logger
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Including <random> for gcc 6
    Extended restore scheduler with thread-specific calls
    
    - Just temporatily trying out a partitioned scheduler
    New tstats for analyzing restore behavior
    Changed behavior of random restore scheduler
    
    - Initializing random seed once for better randomness and using a
    interval interpolation kind of thing.
    Adapted BackupOnDemandReader for multiple threads
    
    - Also using it as default for now. With multi-threaded restore,
    BackupPrefetcher should be less significant and will probably be removed
    later on (if multi-threaded restore works well enough on HDDs)
    Updated restore scheduler
    
    - Only onte thread attempts single pass; others pick a segment at random
    between firstNotRestored and lastUsedPid
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Fixed restore manager shutdown
    
    - Fixed pin behavior
    - check_restore_finished() does not block waiting for restore
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed restore shutdown with pin mechanism
    
    - Pin mechanism avoids deletion and destruction of restore manager while
    threads may still be accessing it. New shutdown method only proceeds
    once it manages to set the pin count from 0 to -1
    Removed random-order restore and singlePassLoop
    
    - Current instant restore implementation can perform single-pass restore
    without a separate loop method
    - Random restore did not show any benefit in practice, so I removed it
    to keep the codebase lean
    Eliminated multseg restore techniques
    
    - New "preemptive" technique is much simpler and achieves the same goal
    - Updated log archive probes to not use min/max read and segment size
    Fixed prefetching for on-demand restore
    Small bugfix with replayed segments bitmap
    
    - On restore loop, checks must be made against replayedSegments
    bitmap, and not for segments already restored, i.e., already written out.
    Fixed restore scheduler stat increments
    
    - Should not increment if on peak mode
    Fixed restore activation and finishing
    
    - LA activation not invoked properly without eager archiving
    - Logging of restore_segment moved to restore.cpp
    - Removed redo argument from check_restore_finished (TODO)
    Implemented preemptive adaptive restore technique
    
    - Every segment restore by default opens a log archive scan until EOF,
    and multiple adjacent segments are restored until a new request pops up
    in the scheduler.
    - The goal is to restore one segment at a time during the initial phase
    of restore, prioritizing latency. As the working set is restored in the
    buffer, the algorithm then behaves more like single-pass restore,
    achieving higher bandwidth.
    - This simple and effective technique should replace our complicated
    multiple-segment technique. Thanks to Goetz for suggesting it.
    Assorted fixes and cleanups
    
    - Fixed doMerge function to process whole input archive
    - Deleted old code
    - Added W_DO to mount redo
    Fixed small bug on restore
    
    - Writes should always be the same size as the segment, otherwise pages
    at the end of the segment for which no replay occurred are not restored
    correctly
    Fixed block reads with varying LA read size
    Fixed prefetch behavior on single-pass offline restore
    
    - Avoid thrashing condition during evictions and other fixes
    Updated backup prefetcher
    
    - Prefetching now controlled by RestoreMgr instead of scheduler
    - Changed how prefetching is performed in the restore logic. Got simpler
    code and better performance
    Fixed random order restore
    
    - Minor tricks on the scheduler logic and restore loop.
    Restore considers last used PID as end of device
    
    - ..instead of the maximum page ID given the quota of the disk.
    - Remvoed the variable numPages and replaced it with lastUsedPid.
    - Control of restore progress as well as bitmaps are now based on
    lastUsedPid, which makes for smaller memory footprint.
    - Also a good idea because I plan to get rid of the disk quota soon.
    Fixed tiny bug on restore
    
    - Calculation of the amount of pages written for a segment was wrong.
    Some bugfixes on restore
    
    - Separate bitmap for replayed but not written-back segments must be
    kept in the object state, so that mlutiple-segment restores also set it
    correctly.
    - Prefetching only one segment on every singlePassLoop iteration
    - Making sure finishSegment inbetween a multiple-segment restore never
    passes a page count larger than the segment size when writing.
    Updated backup-taking method to use single-pass restore
    
    - Instead of taking a backup (through restore) of the device in
    segments, it is more efficient to used single-pass restore by setting
    the "instant" parameter of the restore manager to false.
    Fixed log archive scan to use correct segment borders
    
    - For the first segment which overlaps with metadata, special treatment
    is required on the restore part. In a previous commit, I made it ignore
    the first pages by opening the scan directly on the first data pid.
    However, this broke the scan because the end of the scan (previously
    given by segmentSize) was not adjusted accordingly.
    - Other than adjusting both the begin and end boundaries, these must be
    independent from the "segment size" parameter of the scan, which is used
    only to expand the length of the scan into multiple segments. To fix
    that, I reintroduced the endPID argument. Now, startPid-endPid tell
    where the scan must begin and finish. If multiple-segment scanning is
    desired, then the segmentSize parameter tells which valid values can be
    assumed by endPID.
    New archive index probe method and multiple-segment restore
    
    - Whole probing/scanning mechanism of log archive was updated and is
    much simpler now, also supporting multiple-segment restore.
    - Open method now takes a start pid and the number of page ids to be
    scanned (segment size), as well as a min and a max read size.
    - Probe method returns a list of probe result objects, which simply
    contain a start offset and an end page ID on which to stop scanning.
    In order to achive reads greater than the given min size, the end pid
    is adjusted based on neighboring segments, but going no further than the
    max read size.
    - After initial probe, open method readjusts endPid of all run scanners
    based on the maximum value collected.
    - Restore manager was also updated to work with the new mechanism.
    Removed multiseg restore code (new one coming up)
    Fexed restore to write the checksum of pages
    
    - Due to the restore loop logic, the checksum was not calculated for the
    last page on each segment.
    Fixed restore loop
    
    - If asynchronous writer is used, a separate bigmap must be used to
    control which segments were already replayed (but not necessarily
    written back yet).
    - Fixed control of segments which contain metadata (i.e., pages lower
    than the first data page id). These must not be written by the restore
    loop, but by a separate metadata restore process.
    Small fixes on single-pass restore
    
    - Fixed prefetching on single-pass restore
    - Adjusted segment borders to start at page ID 0
    Add skip log record to the end of log archive blocks
    
    - Instead of relying on the actual block size on the block header, the
    scanner now stops when it reaches a skip log record.
    - This mechanism provides a cleaner way to open a scan on an arbitrary
    file offset and scan forward from there, without having to zero-out
    blocks.
    Implemented variable-bucket log archive index
    
    - This new index is used if a parameter bucketSize > 0 is passed to the
    cosntructor. If it works really well we may make it the default and
    remove code exclusive to the "old" index.
    - Instead of keeping entries in the index with offsets in fixed
    increments of the block size and the first PID which happens to occur in
    each block (i.e., just like a B-tree), this new index records the first
    page ID of each logical "bucket" and whatever arbitrary offset this page
    ID occurs in the file. A bucket is a set of page IDs belonging to fixed
    logical ranges (e.g., page IDs 0-99, then 100-199, and so on). For use
    with instant restore, a bucket should be the same size of a segment.
    - The advantage of the new index is that only the amount of log required
    to restore a segment is read from the log archive. In the old
    implementation, segments with few updates caused reads of a whole block
    (e.g., 1MB) where actually only a few bytes where used. The
    multiple-segment technique implemented in an earlier commit did not work
    very well for many runs. We hope this new index will achieve the goal of
    better read efficiency reagrdless of the number of runs.
    - In essence, this index is superior because it allows us to jump
    directly to the offset of a segment.
    Added tryMultipleSegments as an option
    Added restore prefetch window as an SM option
    Single-pass restore reusing the same restore method
    
    - Both on-demand and single-pass restore now use the new restoreSegment
    method
    Fixed bug on multiple-segment restore
    
    - End PID of log scan must be set before advancing the heap to the first
    PID
    - Added a bunch of debug messages which helped debugging this error.
    Reuse one log archive scan to restore multiple segments
    
    - Implemented a technique taht checks when opening a scan if multiple
    segments can be restored based on the page IDs contained in the first
    block read from each run.
    - The technique required a new restoreSegment method, which is more
    generic and can now be reused for the single-pass loop and, later, for a
    generic log replay class.
    Fixed single-pass restore loop
    
    - Now properly handling page increments, segment borders, and
    finalization. Single-pass restore finally working.
    Fixed usage of mutexes on restore threads
    
    - Mutex objects were not being properly initialized and destroyed
    - Async writer had a redundant infinite loop which would only run once
    Fixed some weird assertions in log_storage
    
    - Assertions in the sanity check of log_storage were failing. One of
    them I still didn't figure out why, but the other is related to a deeper
    bug for which I opened a issue on GitHub.
    Added stat restore_log_volume
    
    - Counts the total log volume (in bytes) which was processed by a
    restore log replay, including skipped log records.
    - The goal is to compare this to the numer of log blocks read. Ideally,
    the latter (multiplied by the block size) should not be much greater
    than the former.
    Fixed small bug on backup reader
    
    - Make sure that a fix attempt which was not preceded by a prefetch adds
    its request to the queue when the queue is empty.
    - Other minor fixes
    Implemented true single pass restore
    
    - Added another version of a restore loop which performs one pass over
    the whole log archive as well as one pass over the backup
    - This restore loop is used if the option "sm_restore_instant" is false
    Reorganized flushSegment method
    
    - Spinlock is only acquired if reuseRestoreBuffer is set
    Updated restore async writer to use a queue of requests
    
    - Now, arbitrarily many segment write requests may be pending in a queue
    while the current write is being performed. The old implementation only
    allowed one request at a time, which means placing requests required
    waiting for the current write to finish.
    Using restore timers not only on debug
    Incorporated prefetching on restore manager
    
    - Invoking backup prefetching on restore scheduler and on-demand request
    enqueueing.
    - Proper shutdown of async writer and prefetcher threads.
    - Fixed bug with inline methods (code not compiling on release build)
    Bugfix: forking async writer and prefetcher
    Restore manager using async writer
    
    - Adapted restore manager methods to use asynchronous writer when the
    corresponding option is set.
    - Now there are three methods involved in finishing up a restored
    segment: finishSegment, writeSegment, and markSegmentRestored. They are
    called in this order, but orchestrated differently if we are using an
    asynchronous writer.
    Implemented asynchronous writer thread for restore
    
    - Class SegmentWriter (declared and defined in restore.cpp) is used to
    write restored segments asynchronously.
    - This commit simply introduces the class, which is not being used yet.
    Reorganized restore methods
    
    - restoreLoop was too large, so I moved the logic to perform log replay
    on a single segment into the new method restoreSegment.
    - Flushing log buffer when marking segment restored (useful for offline
    restore experiments)
    - Assorted clean-ups on restore.cpp code
    Bugfixes and new timers on log archiver and restore
    
    - Added some tstat timers to log archiver to analyze its performance.
    - Added missing W_DO/W_COERCE wrappers to some method invocations.
    Pruning log archive probes based on first PID in runs
    
    - If there is a correlation between PID and LSN, which is typical in
      OLTP workloads, then recent runs most likely only apply to the highest
      segments. In that case, the last PID in the segment will be lower than
      the first PID in the run.
    - Combined with the last commit, this shoud provide effective pruning
      for typical workloads such as TPC-C.
    Added backup LSN
    
    - Each backup file is now equipped with an LSN which corresponds to the
    most recent update guaranteed to be reflected in its pages. It is
    extracted by looking at the archive last LSN before the backup is taken.
    - The purpose of this LSN is to prune runs which are not required during
    restore. If the backup was taken when N runs were available, and during
    restore there are M runs, at most M-N runs will be replayed for each
    segment.
    Fixed some bugs in restore
    
    - When reading from a backup file, segment must not be zeroed
    - Skipping assertions in write_many_pages if performing restore
    - Changed criterion for considering a page as virgin in restore loop
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Supporting on-demand and random order in restore
    
    - If on-demand is turned off, restore scheduler ignores all requests and
    performs a pure single-pass restore
    - If random order is enabled, single-pass restore happens in random
    order of segments, instead of the default sequential behavior.
    Fixed small restore bugs
    
    - Log replay should compare page LSN with log record before applying it
    (very basic stuff).
    - write_many_pages should tolerate empty pages when being used by
    restore
    Redesigned restore/archiver synchronization mechanism
    
    - When a volume is marked as failure, restore now simply invokes a flush
    request (synchronously), which causes the whole heap to be written out
    into run files. This must be done after the failure LSN has been
    consumed.
    - The previous mechanism was wrong because we cannot simply start a new
    run at will. This causes all following runs to be smaller than the
    workspace capacity.
    - This also has the implication that the log archiver does not need to
    treat "restore_begin" log records differently. In fact, they can be
    ignored now.
    - The flushing mechanism itself is also simpler now. We simply consume
    the whole heap and wait until the write buffer is empty -- no need to
    shutdown the writer thread.
    - Furthermore, the logic of the `run()` method in the log archiver was
    broken down into smaller, self-contained methods, making the code more
    readable and modular.
    Zeroing out workspace prior to segment restore
    
    - If the memory workspace used to restore a segment is reused from
    segment to segment, we may end up writing valid pages from an old
    segment into a new segment for which the same page position was not
    restored. This should not cause any serious bug, but it is best to avoid
    problems by keeping a clean database file.
    Fixed synchronization between restore and log archiver
    
    - Order of operations in the `mark_failed` method is crucial (See
    comments in the code). It turns out that the failure LSN cannot be set
    when restore manager is constructed, but only after the device is marked
    failure.
    - Also fixed the `check_restore_finished` condition, which had a race
    condition when some other thread unsets `failed` after one thread checks
    but before it grabs the mutex.
    Small change to restore DBG output
    Added stats to restore scheduler
    
    - Stats to count how many segments were restored based on the
    single-pass scheduler and how many based on on-demand scheduler
    Restore goes only to last used page ID
    
    - Information is extracted from alloc_cache, which is expected to be
    consistent by the time the device is marked failed. Furthermore, no
    allocations can occur once failed is set, so there are no "lost
    allocations"
    Added assertion to verify log replay on restore
    
    - Before applying a log record, the LSN on the page must be equal to the
    prev-page pointer of the log record.
    Restore buffer reusing defaults to false
    
    - When a page request arrives during restore, it goes into a request
    queue together with its buffer pool frame address. When the page is
    then finally restored, we try to reuse the restore workspace and copy
    the contents to the given frame, thus avoiding an extra I/O to read the
    restored page. However, this is not really working yet, so I am turning
    it off by default.
    - Extra checks and debug messages.
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Added debug messages and asserts to restore
    Fixed memory leaks in archiver scanner
    
    - RunScanner was not being deleted properly when it started off as
    inactive (i.e., when it does not contain the probed PID), since it was
    not added to the heap.
    
    - Fixed other minor memory leaks and deletes
    Implemented non-instant restore and eager archiving
    
    - Added "instant" flag to restore manager. On-demand requests are only
    satisfied if the segment is restored AND the flag is true. This allows
    us to run experiments with traditional restore.
    
    - Eager archiving means that the reader thread and the sorter thread of
    the log archiver keep running indefinitely in a loop until shutdown. The
    lazy behavior (old one, current default) means that these threads must
    wait for an activation signal.
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Several bugfixes on restore/volume code
    
    - Fixed fixedSegment checks on BackupReader
    - Correct initialization of restore bitmap
    - Memory leak with RunMerger in restore loop
    - Volume manager shutdown in correct order (sm.cpp)
    - Not cleaning volume metadata when marking as failed
      (Temporary fix! Must figure out how to keep allocated pages in the
      server state)
    - Correct log record for restore_begin
    - Close backup file on volume dismount
    - Handling short I/O on read_backup method
    Fixed backup generation
    
    - Flush bf_fixed to initialize metadata of backup, instead of writing it
    empty, as done in sx_format
    - Deadlocks removed
    - No restore logging when taking backup
    - Other minor bugs
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Added functionality to take backups
    
    vol_t now supports take_backup() operation. Its internal state keeps
    track of a path and file descriptor for a backup file currently being
    generated. It instantiates a RestoreMgr and reuses its functionality to
    generate a new backup file instead of a replacement device.
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    New (logged) sx_add_backup operation for volumes
    
    A volume now contains a list of FS paths to be used as backup files.
    These can be added with the vol_m::sx_add_backup method. The operation
    is part of persistent system state and thus it must be logged,
    checkpointed, and recovered. Logging and recovery are done,
    chekpointing will come next.
    Basic logging and recovery functionality for restore
    
    Implemented log records and their generations as SSX, their REDO
    operations, and required methods in vol_t and RestoreManager.
    Proper volume shutdown after restore merge
    
    Shutting down with ongoing restore requires waiting for the
    (single-pass) restore operation to complete, unless an "abrupt" flag is
    passed.
    Fixed restore bugs
    
    - Sending signal after restoring metadata
    - Treat any request to page IDs lower than firstDataPid as metadata
    (not only pid 0)
    Added options to tweak restore behavior
    
    - trySinglePass: if true, restore scheduler will return page IDs in
    sequential order if there are no requests available, meaning that
    single-pass restore is performed together with on-demand restore.
    - reuseRequestBuffer: if true, read requests from the volume manager
    may reuse the restore buffer and copy requested page contents into the
    target frame in the buffer pool after restore. This avoids an additional
    read of a page which was just recently on main memory.
    
    These two behaviors used to be on by default
    Fixed restore bugs
    
    - Releasing latch on requests and marking a segment as restored can only
    be done after segment is written, otherwise readers will proceed and
    likely read garbage.
    - Added ignoreRestore flag to write_many_pages(), otherwise deadlock
    would occur
    Small fixes on restore code
    
    - After redo, adjust page fields such as LSN and checksum
    - Correctly set store parameter on store_operation log records (not
    required for now, but it could lead to bugs later)
    RestoreMgr now keeping track of volume metadata
    
    Log records belonging to shpid 0 must be restored first, since they
    rebuild the volume metadata (stnode cache) by replaying store
    operations. RestoreMgr now has a special restoreMetadata() function
    which is called before restoring any data page. Accordingly, methods
    accessing such metadata (such as vol_t::get_store_root()) must wait
    until it is restored. A mechanism to achieve this was also implemented
    witha simple flag 'metadataRestored'.
    
    This commit fixes complements the previous one.
    Fixed restore manager
    
    - Fixed archive scan boundary cases (first PID or LSN, beyond end, etc.)
    - Fixed restore progress control to handle non-used segments (no log
    replay)
    - Restore ignoring/forbidding requests on first pages of the volume
    (i.e., alloc pages, volume descriptor, etc.)
    - Sending restore signal after each segment to waiting threads
    Duplicating multi-page logrecs on log archiver
    
    Multi-page log records are replayed once for each page involved. In the
    case of Restart and Single-page recovery, this is achieved by merges and
    bifurcations in the per-page log chain. For Restore, however, we must
    replicate the log record so that is replayed for each page involved.
    Updated log archiver and restore for new PID
    
    Comparisons between lpid_t values are now valid.
    Reverted method fixable_page_h::setup_for_restore
    
    Previous implementation would initialize page with metadata from the log
    record, but this should not be required, because correct log replay must
    guarantee that the page state is compatible to what each log record
    expects. Method now only sets the page pointer (_pp) of the handle.
    Updated setup_for_restore on fixable_page_h
    
    Passing whole log record to setup_for_restore in order to initialize
    all attributes of the page correctly.
    
    NOTE: This shouldn't actually be necessary, since the page state should
    have been already correct from previous redo operations. Even in the
    backup-less case, proper formatting and initialization should ensure the
    correct state. This hack was required to work with B-tree splits and
    merges, but it still seems to be broken. This commit may get removed in
    the future, once I understand initialization and splits/merges better.
    Fixed restore loop and vol_t integration
    
    - Wait for device to be marked failed in restore loop
    - Keep track of previous page in restore loop
    - Added vol_t::remount_from_backup to remount volume when marking as
      failed, thus resetting the metadata (header, store, and alloc pages)
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Started implementation of Restore Manager
    
    Sketched the basic API and added a simple bitmap implementation.
    Cleaned up CB and page header fields
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed bugs on B-tree split
    
    - Range deletion was not processing ghost records correctly
    - Strange bug with _ux_assure_fence_low_entry. Commented out for now
    since I don't really understand why this method is required.
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Fixed btree_page::delete_range
    
    Basically, my understanding of memmove() was all wrong and the deletion
    of item bodies was inconsistend.
    
    Adapted method to perform memmove correctly and delete item head and bodies
    together one by one. This may not deliver the best performance, but it
    should be robust enough with random insertion orders.
    Fixed B-tree split by deleting body space
    
    B-tree items consist of a head, which is a fixed-length header stored in
    the head array from left to right, and a body, which can be
    variable-length (but multiple of sizeof(item_body)) and is stored right
    to left.
    
    The previous split operation only deleted entries from the head array,
    without properly deleting the associated bodies.
    Whitespace changes
    Added test for vol_t::take_backup method
    
    Test generates a backup and uses utility function verifyVolumesEqual to
    varify that logical content of backup and original DB file is the same.
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Attemped to fix a full logging page rebalance bug but did not get anywhere, check in the current code although it is not completed.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    moved child_emlsn code to handle class
    Applied Mark's page layout suggestion
    merge with bufferpool change
    improvements identified by Hideaki in btree_page
    finished cleaning up implementation
    removed previous helper functions
    working on better implementation helper functions
    missed a align, conversion to # of *bodies*
    switching using a local version of align
    added some overall implementation comments
    committing so can switch branches
    missed some spots dealing with item 0's format
    starting cleanup of implementation
    item 0 now has the same format as other items in a page
    bug fixes: assert not being called in release mode, klen going out of
    scope when used in a cvec_t
    more cleanup
    commented all item API functions
    renamed fixed length item fields
    adding comments
    rearranged classes to provide better access control flexibility
    some cleanup
    more interface cleanup
    interface cleanup
    removed get_rec_size* functions in favor of new get_rec_space function
    based on item_space
    
    removed dead code page_usage
    introduced predict_item_space
    introduced unused_part call to pull representation details out of
    page_img_format_log
    removed insert_slot
    delete_slot -> delete_item
    finished converting resize_slot to resize_item
    replace_el_nolog now using item API
    new item_resize function
    fence packing now excludes length
    bugs fixes to item code
    replace another occurrence of slot_insert
    introduced insert_item, replaced one usage of insert_slot
    fixed slot length definition for slot 0
    pulled together common code for accessing leaf item fields
    made an accessor for the poor man's key, _poor
    cleaned up set/unset_ghost asserts
    beginning to turn slots into items
    converted compaction routine
    converted slot consistency checker
    replaced _append_nolog with calls to slot_insert
    added insert_slot
    code for marking slots as ghost/non-ghost, resizing slots
    cleanup includes
    pulled out btree_page_h class
    removed data array
    delete_slot pulled out, added typedef's for slot_body
    replaced sinome used of casting
    minor code reformatting
    code reformatting
    un-inlining functions in page_bf_inline.h
    cleaned up generic page header's fields
    moved down two B-tree fields
    removed/changed incorrect/unneeded references to generic_page_h
    removed unused print_slot function that was violating encapsulation
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    removed pragma interface/implementation
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    RAW-style lock manager
    Fixed write elision and decoupled cleaner
    Deleted gclock evictioner
    
    - Base cleaner can be configured to behave like GCLOCK, so there's no
    need
    Made cleanee more flexible with attempt-based triggers
    Eviction loop incrementing idx with std::atomic
    Proper attempt count and cleaner wakeups during eviction
    Added missing <random> include
    Implemented random pick_vitcim and optional used of clock
    Logging page evictions for debug
    Default eviction is now a simple CLOCK
    Added option to flush dirty pages on eviction
    Cleaner now has both async (dedicated thread) and sync (on-demand) modes
    Eviction: ignoring EMLSN maintenance if required and fixed spelling
    Added _maintain_emlsn option
    Adding GCLOCK evict policy
    
    Two options control que policy used:
    1. "sm_evict_policy" = "latched" | "gclock"
    
    In case of "gclock", there is an option "sm_bufferpool_gclock_k" that is an int
    indicating the GCLOCK k parameter (every time a frame is referenced, the count
    is set to K).
    Minor formatting issues
    Separation of concerns inside evictioner thread
    
    We are splitting the previous funcionality of do_work() in 3 methods:
    void do_work()
    bf_idx pick_victim()
    bool unswizzle_and_update_emlsn(bf_idx idx)
    
    pick_victim is solely worried about selecting the best victim and returning
    its bf_idx with the CB latched in EX mode. New policies only have to worry
    about overriding this method.
    
    unswizzle_and_update_emlsn encapsulates a funcionality that is common every
    time a page is evicted, therefore it is implemented by the base class and
    cannot be overriden.
    
    do_work does a higher level management of calling pick_victim, unswizzle and
    update expected lsn on the parent, erasing victim from hashtable, releasing
    latches, etc
    Fixing wrong naming of parameters
    
    This was mistakenly introduced by a previous commit
    Adding initial file for evictioner thread
    Compressing btree split logrecs when archiving
    
    - Instead of simply duplicating the logrec on both pids involved, we
    eliminate the redundant information for each pid.
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Cleaning up some compiler warnings
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Bugfix: properly constructing logrecs with type and cat fields
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Moved classes around and cleaned up logdef_gen.h
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Trying to make smthread_t fully static (huge commit from hell)
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Fixed and simplified single-page recovery
    
    - Single-page recovery was using the log fetch buffer incorrectly.
      (Fixes issue #17)
    - Simplified collection of log records by simply copying into a (now
    automatically expanding) buffer and replaying directly from this buffer.
    This eliminates the need for a separate list of log record pointers.
    - Added some assertions to replay process.
    - Removed "actual_emlsn" parameter which was never false. If it's to be
    implemented in the future, the same condition can be simulated with
    `emlsn == lsn_t::null`
    Fixed bug on btree split log record
    
    - Prev pointers were switched (prev2 pointing to previous update on
    page1 and vice-versa). Fixed constructor method and its invocaiton to
    produce the correct assignment.
    
    - Aldo fixed log archiver to correctly set previous pointer on
    duplicated multi-page logrec.
    Fixed alignment bug on B-tree split logrec
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Fixed logging and recovery of B-tree split
    
    Serialization of split information (i.e., class bulk_delete_t) was
    completely wrong. Tests were only passing because memory contents were
    being reused, I guess. Implemented proper serialization now.
    Removed SM level 1
    Removed SM level 2
    Removed some trailing whitespace
    Fixed behavior of multi-page logrec REDO
    
    To determine which page is being replayed when calling the REDO method
    of a multi-page log record, we compare the PID of the given page image
    with the "pid2" field of the log record. Comparing with the main pid
    field (i.e., construct_pid()) is no longer valid because of the
    replication in the log archiver.
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to logrec header
    
    Same idea as in page header: operations that need the store number must
    get it from an extra header field.
    
    Also updated the fill() method and added other fill() variants for
    convenience.
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Updated handling of CLSN field of pages
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Moved SPR methods out of log_m and into restart_m
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Continue working on performance test.
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    This  check-in was not planned, it was forced in order to merge changes from master.
    Added a new test file for Restart performance test, no actual test case implementation with this check-in.
    Added some information to an existing bug.
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Attemped to fix a full logging page rebalance bug but did not get anywhere, check in the current code although it is not completed.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Fixed an infinite loop bug, also update the 'known issues' list in Recovery.docx to track the I/O layer issues discovered by Caetano.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Fixed a bug on normal shutdown with transaction rollback where the transaction contains a page split through full logging.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Bug fixes for page rebalance full logging.  The very basic full logging is working but Still have more issues to investigate, the feature is not fully functional at this point.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Initial implementation of full logging for page balance operation, code is not tested at this point.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Multiple bug fixes, also draft design doc for milestone 3.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    New log type for b-tree insertion
    bug fix
    Addressed Mark's code review feedbacks
    complex testcases for SPR and bug fixes
    removed unneeded function, init_as_empty_child, in favor of existing format_steal
    merge with bufferpool change
    removed unnecessary class scratch_btree_page_h
    moved module comments
    Added page_evict_t
    Added SPR APIs
    Added SPR APIs
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    replaced dat_leaf[_ref]
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    new_search->search, replace search_leaf with search
    removed original search function (references) in favor of search_leaf
    and search_node as appropriate
    Conversion of more w_asserts to use if (false) when disabled.
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    btree_page[_header] no longer all public
    modified reserve_ghost take element_length rather than record size
    delete_slot -> delete_item
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    moved down two B-tree fields
    generic_page_h -> fixable_page_h
    Put back in the _page_prv fields that got lost when merging with Mark's changes.
    Still need to fix asserts.
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    fixed extremely dubious casting between page handles by introducing a
    new class, borrowed_btree_page_h
    removed no longer necessary assertions of proper page type
    changed B-tree logging operations to take a btree_page_h rather than a
    generic_page_h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Replaced boost::regex with std::regex
    Implemented get_byte_distance for two LSNs
    Log recycler bugfix: only run if log already initialized
    Fixed deletion of log_core fetch buffer
    Fixed log partition recycling with fuzzy checkpoints
    chkpt_m now derives directly from worker_thread_t
    Unified classes ArchiveIndex and ArchiveDirectory
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed more headers, fixing their previous uses
    Moved logrec header initialization out of constructors
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Moved latch/mutex stuff out of sthread files
    Goodbye fileoff_t!
    Invoke chkpt proactively only if log partitions are limited
    
    - Otherwise, a chkpt interval of -1 means a checkpoint is never taken,
      which is useful for our experiments.
    Chkpt mgr keeps track of last chkpt LSN
    
    - which allows returning a meaningful min_active_lsn() when both
    min_xct_lsn and min_rec_lsn are null.
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Recycling chkpt files regardless of log-file recycling
    Using boost filesystem in log archiver directory
    Restore: removed faulty assertion and changed default arguments
    Chkpt serialization to file (initial code from Lucas)
    
    - Checkpoint data is now serialized to a serparate file instead of as
    embedded *_tab log records.
    Added delete_old_partitions option to log_storage
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Fixed log manager destruction
    
    - delete log was not being invoked at SM destruction
    - Fixed shutdown of recycler thread; moved condvar & mutex inside its
    class
    Cleaned up messy calculations of partition_size
    Added best-effort partition recycling mechanism
    
    - Support for sm_log_max_partitions options, which limits the number of
    partition files in the log directory. At each partition creation, old
    partitions are deleted proactively. If the limit is reached, a forced
    deletion is attempted, but it only works if the min active LSN collected
    on the last checkpoint allow it -- hence the best-effort approach.
    - A true recycling mechanism is only possible with log reservations,
    which we removed because they were messy and not fully effective
    (required "fudge factors").
    Managing partition_t lifecycle with shared_ptr & latching
    
    - All methods now return shared_ptr, which allows automatic control of
    ownership and destruction of partition_t objects
    - All accesses to the partition_t map now acquire a latch.
    - Removed old partition lock
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Replaced std::regex with boost::regex, since gcc doesnt support regex
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Refactoring partition_t & removed peek function
    
    - Peek is only necessary to determine the position of the skip log
      record, but it was too cumbersome. The only use of knowing this
      position (i.e., the partition size) is to determine the last LSN in a
      partition for a backward log scan. For now, we disabled it, but a
      better way to achieve that must be implemented
    - Simplified partition_t object by removing many unnecessary fields and
      methods.
    - prime() method of log_storage also reuses partition_t::read
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Removed class ErrLog and replaced its uses with std::cerr
    Removed auto_delete stuff
    Removed old FUNC macro
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Removing unnecessary calls to cleaner
    Cleaner should flush the buffer ONLY during clean shutdown. In all other occurences it should only make a meaningless request for flushing pages by waking up a cleaner thread.
    Removed apparently invalid calls to log_core::sanity_check
    
    - The sanity check assertion during fetches was failing. However, I
    don't think it's a bug with the log buffer (which is very well tested
    and stressed). Rather, it seems like sanity checks can only be invoked
    when the proper mutexes are held, to avoid invalid racy states.
    Fixed some weird assertions in log_storage
    
    - Assertions in the sanity check of log_storage were failing. One of
    them I still didn't figure out why, but the other is related to a deeper
    bug for which I opened a issue on GitHub.
    Removing dumb code
    This code would generate a checkpoint for no aparent good reason. Check the comment.
    Whitespace changes
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Refactored log manager to use sm_options
    
    Same thing as done for bf_tree_m on the previous commit, but now for log
    manager classes (log_core, log_common, logbuf_core). This was quite
    tricky to achieve due to the crazy dependencies in log manager
    initialization and the complete lack of reuse in logbuf_core.
    Made log_storage::_version_major and log_storage::_version_minor public.
    This was need to access the current version from other classes for compatibility purposes.
    Similar members were also made public.
    Since all these members were declared as static const, making them public should not have unexpected side-effects
    Removed some unused variable warnings
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Fixed small bug on log manager
    Fixed missing include
    Fixed bugs in logbuf_core (tests passing now -- except for TSTAT issues)
    Log refactoring: fixed prime mechanism so logbuf_core can be initialized independently
    Updated/reorganized prime methods in log manager code
    Minor change on log_storage::find_partition
    Fixed fetch method in log_core
    Fixed some of the bugs resulting from log refactoring
    Log refactoring: pulled out log_storage into its own class
    Log refactoring: made log_core and logbuf_core implementations of log_m
    Moved parts of log_core constructor (logdir scanning) into log_storage.cpp
    Moved log_core methods related to storage into file log_storage.cpp
    Restore: made some stuff static thread_local for performance
    Decoupled cleaner is back!
    Small bugfix on close_backup
    Backup now guarantees zeroed contents when fetching unallocated pages
    
    - With help of new class backup_alloc_cache_t
    vol_t::read_backup now returns void
    Removed old restore usage in vol_t
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Bufferpool prefetch for instant restore
    Kits using new restore (commented old one in vol_t)
    Fixed backup handling in vol_t
    Option cluster_stores set to true by default
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Switched to thread-local, single-allocation SprIterator
    Fixed ARIES restart with proper alloc & stnode logging
    Fixed non-instant restart modes
    Fuzzy chkpt fix: collecting dirty pages from vol_t table
    Not syncing every page flush in cleaner
    
    - Goal here is to exploit I/O parallelism, like in SSDs, to dramatically
    improve cleaner throughput.
    - To that end, a bunch of write calls are performed for multiple
    clusters of adjacent pages in the cleaner workspace, but fsync is
    invoked only once for the whole workspace.
    - Marking pages as clean and logging the page writes only happen after
    the fsync call.
    Correct recovery of dirty pages in nodb mode
    Fixed adding backups
    Archive prioritization during SPR off by default
    Some restore fixes
    Fixed redo bookkeeping and vol_t shutdown
    Fixed redo progress
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    WS: minor change in restore progress report
    Webserver: tracking media recovery progress
    Added option for store clustering
    
    - Also fixed metadata initialization without clustering.
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Bugfix: add_backup is an SSX
    Unified classes ArchiveIndex and ArchiveDirectory
    Implemented checkpoint-less no-db mode
    Added prioritize_archive option on vol_t
    
    - also deleted method restart_m::recover_single_page, since SprIterator
    is really easy to use and the method was only called from
    vol_t::read_page_verify
    Brought back backup-taking in vol_t
    Fixed restore_begin logging
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Fixed ridiculous bug in vol_t::get_num_pages()
    
    - After all these years...
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed w_stream stuff
    Movet gethrtime() to vol.cpp
    Replaced log "stub" calls with generic Logger
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Trying to make smthread_t fully static (huge commit from hell)
    Webserver: Fix bug. The function, which verifies if the database is executing or not, responded as not running during the load time.
    Removed uses of sthread IO in vol_t
    Updated restore scheduler
    
    - Only onte thread attempts single pass; others pick a segment at random
    between firstNotRestored and lastUsedPid
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Assorted bugfixes to restore code
    Enabling option to open volume without O_SYNC
    
    When opening with O_SYNC, any write to the file is guaranteed to be sync.
    When opening without O_SYNC, one would have to call sync() after a write to
    ensure persistence.
    
    By making persistent writes optional, we can compare Zero to other systems that
    offer the same guarantees (NoSQL systems, for example).
    
    The default option is still: "sm_vol_o_sync = true"
    Opening volume with O_DIRECT
    
    The vol_t::vol_t() is responsible for opening the dbfile.
    However the _use_o_direct options was being ignored here, the dbfile was always
    being open with O_DIRECT enabled.
    
    Disabling O_DIRECT for the dbfile is required if I want to place it in /dev/shm
    Fixed race conditions on testing _failed flag of vol_t
    
    - Using latch instead of memory fences -- it's easier, safer, and
    there's no critical performance impact.
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Restore: removed faulty assertion and changed default arguments
    Fixed flushing of alloc/stnode pages on sm shutdown
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Fixed restore manager shutdown
    
    - Fixed pin behavior
    - check_restore_finished() does not block waiting for restore
    Small fix: race in vol_t::delete_dirty_page
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Parametrizing use of O_DIRECT in vol_t
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed sm_du_stats
    Removed old & unused "vtable" stuff
    Unified all truncate/reformat options into single sm_format
    Flushing log after force volume & other small fixes
    Fixed segmentation fault in vol_t when there are no dirty pages
    Passing dirty page table to vol_t by copy instead of pointer
    
    - Table must be copied to avoid unexpected segmentation errors
    Added options to log page reads and writes
    Supporting read-only mode in vol_t
    
    - Write-page calls are simply ignored, meaning that write elision and
    single-page recovery are required for correct behavior.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Small bugfix
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Updated btree_test_env for single-volume infrastructure
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Fixing logic in vol_t::read_many_pages()
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Introducing vol_t::read_many_pages()
    in analogy to vol_t::write_many_page()
    Removing bf_uninstall flag from vol_t::dismount()
    The bf_fixed page of a volume is not recovered during restart. For now we keep this assumption and we must guarantee that the bf_fixed is flushed even during dirty_shutdown.
    Fixing sx_dismount bug
    sx_dismount() log the name of the device being dismounted. Before it would read the device name after the device was deleted[], which would provoke a read of wrong values sometimes.
    Change shpid_t to lpid_t in event logs.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Writes do not wait for restore manager
    Fixed restore shutdown with pin mechanism
    
    - Pin mechanism avoids deletion and destruction of restore manager while
    threads may still be accessing it. New shutdown method only proceeds
    once it manages to set the pin count from 0 to -1
    Fixed restore activation and finishing
    
    - LA activation not invoked properly without eager archiving
    - Logging of restore_segment moved to restore.cpp
    - Removed redo argument from check_restore_finished (TODO)
    Added bf_evict stats
    Opening volume with O_DIRECT
    
    - O_DIRECT is required for experiments to perform real page reads
    instead of those cached by the OS.
    Updated backup-taking method to use single-pass restore
    
    - Instead of taking a backup (through restore) of the device in
    segments, it is more efficient to used single-pass restore by setting
    the "instant" parameter of the restore manager to false.
    Removed unused vol field from alloc_cache
    
    - Volume was only used in a single assertion, so it was not required as
    a member variable. Data is accessed indirectly through bf_fixed, which
    also supports a null volume, as long as no flushes are performed (i.e.,
    read-only mode). This is possible because the constructor directly takes
    a file descriptor as parameter.
    - This functionality was implemented to extend the dbinspect command of
    zapps with allocation information. We basically need to load the
    alloc_cache of aa volume without creating or mounting a vol_t object.
    Added read-only flag to vol_t
    
    - If flag is set, all writes are ignored and method returns imediately
    (i.e., write elision).
    Reuse one log archive scan to restore multiple segments
    
    - Implemented a technique taht checks when opening a scan if multiple
    segments can be restored based on the page IDs contained in the first
    block read from each run.
    - The technique required a new restoreSegment method, which is more
    generic and can now be reused for the single-pass loop and, later, for a
    generic log replay class.
    Removed OPEN_EXCL from vol_t open calls
    
    - If a file already exists, opening it with O_EXCL causes a failure,
    which is not our desired behavior. An existing file may be opened and
    overwritten when loading a new database.
    Fixed sharp backup taking
    
    - To make sure that a sharp backup is taken from the current tail of the
    recovery log, a stronger version of log archive flushing was
    implemented, in which not only we wait for all log records to be
    consumed and written out to archive blocks, but also forcibly close the
    currenr run and create a new one. This also makes sure that the new run
    has the requested LSN as its upper boundary.
    Added option to flush log archiving when taking backup
    Restore manager using async writer
    
    - Adapted restore manager methods to use asynchronous writer when the
    corresponding option is set.
    - Now there are three methods involved in finishing up a restored
    segment: finishSegment, writeSegment, and markSegmentRestored. They are
    called in this order, but orchestrated differently if we are using an
    asynchronous writer.
    Restore now using direct I/O for reads
    
    - Reading backup segments and log archive blocks is now performed with
    direct I/O (O_DIRECT). This decision is not driven by performance but by
    the simple fact that we want our measurements to account for real I/O
    delays. Otherwise, it is likely that most reads will be served from the
    kernel page cache.
    Fixed backup bugs
    
    - Missing comma in vol header prolog was compiling but causing weird
    errors. That was hard to catch.
    - Fixed backup reader to star reading from the offset of the first data
    page.
    Added backup LSN
    
    - Each backup file is now equipped with an LSN which corresponds to the
    most recent update guaranteed to be reflected in its pages. It is
    extracted by looking at the archive last LSN before the backup is taken.
    - The purpose of this LSN is to prune runs which are not required during
    restore. If the backup was taken when N runs were available, and during
    restore there are M runs, at most M-N runs will be replayed for each
    segment.
    Fixing sx_dismount() bug
    The log record was refering vol->devname() after vol was already deleted. This was generating error in some cases.
    Fixed some bugs in restore
    
    - When reading from a backup file, segment must not be zeroed
    - Skipping assertions in write_many_pages if performing restore
    - Changed criterion for considering a page as virgin in restore loop
    Removed wrong assertion from vol backup code
    
    - Like done for normal writes some days ago, backup writes must also
    consider that virgin pages may be written as part of a segment. Thus, it
    is not valid to check the page IDs of every page in a bulk write.
    Added stats for page alloc and dealloc
    Fixed small restore bugs
    
    - Log replay should compare page LSN with log record before applying it
    (very basic stuff).
    - write_many_pages should tolerate empty pages when being used by
    restore
    Commented out calls to check_metadata_restored()
    
    - Since the server state is kept intact after a media failure -- and
    thus all metadata caches are maitained -- there should be no need to
    wati for metadata pages on disk to be restored. This only adds
    unecessary delay to crucial operations (like intention-locking a
    volume ID) which could proceed normally with pages in the buffer pool.
    Fixed synchronization between restore and log archiver
    
    - Order of operations in the `mark_failed` method is crucial (See
    comments in the code). It turns out that the failure LSN cannot be set
    when restore manager is constructed, but only after the device is marked
    failure.
    - Also fixed the `check_restore_finished` condition, which had a race
    condition when some other thread unsets `failed` after one thread checks
    but before it grabs the mutex.
    Restore goes only to last used page ID
    
    - Information is extracted from alloc_cache, which is expected to be
    consistent by the time the device is marked failed. Furthermore, no
    allocations can occur once failed is set, so there are no "lost
    allocations"
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Fixed bugs with backup handling
    
    - Removed deadlock in sx_add_backup
    - Short I/O check was wrong
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Small bugfix on vol.cpp
    
    - Volume object is not deleted when mounting already mounted device
    (caused assert to fail when checking that FD is -1)
    Several bug fixes on eager log archiver
    
    - Reader thread cannot run eagerly, because endLSN must be in sync with
    log archiver. This is because log consumer expects a skip log record on
    the endLSN position, and it must be artificially inserted by reader.
    - Reader activation fixed to use a single signal instead of a loop.
    Thanks to proper lock acquisition, we guarantee that the signal is
    always caught.
    - Reader correctly fetches partial blocks across activation cycles,
    i.e., if then endLSN is in the middle of a block, following read will
    fetch data into the rest of the block, so that scanner continues from
    the same offset where it left off.
    - LogArchiver keeps track of the endLSN of the last activation, to avoid
    being activated on a region which was already covered before. This is
    important for cases when the archiver runs faster than the log grows.
    - Shutdown of log archiver is synchronous now, i.e., it sends
    synchronous shutdown to all sub-components and joins on all threads.
    - Writer thread forked from the beginning rather than on demand.
    Eliminated writerForked flag and fixed shutdown.
    - Small fix on heap workspace deallocation (array delete was wrong)
    - Added log archiver shutdown to SM destructor.
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Small bugfix on closing backup file
    Several bugfixes on restore/volume code
    
    - Fixed fixedSegment checks on BackupReader
    - Correct initialization of restore bitmap
    - Memory leak with RunMerger in restore loop
    - Volume manager shutdown in correct order (sm.cpp)
    - Not cleaning volume metadata when marking as failed
      (Temporary fix! Must figure out how to keep allocated pages in the
      server state)
    - Correct log record for restore_begin
    - Close backup file on volume dismount
    - Handling short I/O on read_backup method
    Removed assertion which fails for some tests
    Fixed bug on btree split log record
    
    In order for page LSNs to be updated correctly, the constructor stub in
    logdef.dat must have its first two parameters named exactly "page" and
    "page" (weird, old Shore stuff...)
    Changed vol_m to index the volume array by vid
    Fixed backup generation
    
    - Flush bf_fixed to initialize metadata of backup, instead of writing it
    empty, as done in sx_format
    - Deadlocks removed
    - No restore logging when taking backup
    - Other minor bugs
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Added functionality to take backups
    
    vol_t now supports take_backup() operation. Its internal state keeps
    track of a path and file descriptor for a backup file currently being
    generated. It instantiates a RestoreMgr and reuses its functionality to
    generate a new backup file instead of a replacement device.
    Simplified vhdr and peristent vol metadata mgmt
    
    - Volume header only has to contain vid and total number of pages; all
    other fields were not necessary.
    
    - Isolated logic to write metadata pges (incl. volume header) so that it
    can be reused for taking backups.
    Fixed some leaks and valgrind errors
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    New (logged) sx_add_backup operation for volumes
    
    A volume now contains a list of FS paths to be used as backup files.
    These can be added with the vol_m::sx_add_backup method. The operation
    is part of persistent system state and thus it must be logged,
    checkpointed, and recovered. Logging and recovery are done,
    chekpointing will come next.
    Fixed volume remount operation in mark_failed
    
    Isolated methods for initialization of metadata (stnode, bf_fixed, and
    alloc_cache) into their own methods, allowing the related objects to be
    reset during a media failure without explicit remounting and deadlock
    problems.
    
    Also fixed methods that rely on metadata information, so that they wait
    for restore if one is in progress.
    Basic logging and recovery functionality for restore
    
    Implemented log records and their generations as SSX, their REDO
    operations, and required methods in vol_t and RestoreManager.
    Proper volume shutdown after restore merge
    
    Shutting down with ongoing restore requires waiting for the
    (single-pass) restore operation to complete, unless an "abrupt" flag is
    passed.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Implemented shutdown of volume manager
    
    When destroying ss_m, invoke shutdown on vol_m, which simply relays the
    call to all mounted vol_t. The shutdown procedure is essentially an
    unlogged dismount. If a restore is ongoing and an abrupt flag was not
    set, it should wait for restore to complete.
    Fixed restore bugs
    
    - Releasing latch on requests and marking a segment as restored can only
    be done after segment is written, otherwise readers will proceed and
    likely read garbage.
    - Added ignoreRestore flag to write_many_pages(), otherwise deadlock
    would occur
    Removed some trailing whitespace
    Added option to clear buffer pool during restore
    
    Method vol_t::mark_failed now has a boolean argument which is passed
    down to the remount operation to determine if the pages of the failed
    volume are to be evicted from the buffer pool or not. This is useful for
    testing
    RestoreMgr now keeping track of volume metadata
    
    Log records belonging to shpid 0 must be restored first, since they
    rebuild the volume metadata (stnode cache) by replaying store
    operations. RestoreMgr now has a special restoreMetadata() function
    which is called before restoring any data page. Accordingly, methods
    accessing such metadata (such as vol_t::get_store_root()) must wait
    until it is restored. A mechanism to achieve this was also implemented
    witha simple flag 'metadataRestored'.
    
    This commit fixes complements the previous one.
    Fixed restore loop and vol_t integration
    
    - Wait for device to be marked failed in restore loop
    - Keep track of previous page in restore loop
    - Added vol_t::remount_from_backup to remount volume when marking as
      failed, thus resetting the metadata (header, store, and alloc pages)
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    Fixed SSX's and thread safety of volume mgr
    
    - Added spinlock to protect operations on vol_t and vol_m
    - Fixed behavior of SSX -- log only after all operations completed in a
    method
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Fixed logging of volume operations
    
    Format volume operation is now properly logged and redone, and SSX
    behavior of other sx_* methods in vol_m was also fixed. Still need to
    implement logging for dismount_all though. Testing recovery fo volume
    operations is also to be done soon.
    Removed MAX_VOL_COUNT and fixed bf_cleaner volume mgmt
    
    All places that ask for the maximum number of mounted volumes now access
    vol_m::MAX_VOLS instead of the constant MAX_VOL_COUNT. However, this
    behavior is not entirely correct, since we need to distinguish between
    the maximum number of mounted volumes (MAX_VOLS) and the maximum number
    of volumes that can ever be created (MAX_VID). Right now, the two are
    undistinguishable, but we may want to fix that in the future.
    
    Simplified volume management in the buffer cleaner. Cleaner thread is
    assigned to volume based on a simple mod operation and reserved slot 0
    for "no volume" was eliminated from certain arrays, since it was not
    used (at least one cleaner thread must always exist).
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Implemented logging and recovery of volume ops
    
    Added logrecs with proper REDO and SSX for create, mount, and dismount
    of volumes. Recovery works by simply invoking redo() on them, including
    chkpt_dev_tab_log.
    Some whitespace changes
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed raw device stuff and unused vhdr fields
    
    The distinction between raw and non-raw volumes does not make much
    sense, because nothing important was really done based on it. Also see
    comments.
    
    Removed fields quota and page_sz from volume header, since these are
    redundant.
    Some whitespace changes
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Removed creation time from volume header
    
    It wasn't used for anything and probably will never be in our research
    prototype.
    Page allocation taking only lpid_t as argument
    
    Store number is not require to allocate a page, since it only involes a
    volume and a short page ID (i.e., position of the new page in the volume)
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Replaced l0 with lvid_t::null
    Made vid_t a simple typedef and deleted volid_t
    Fixed REDO of store operations
    
    Store operations always generated log records, which is wrong in case of
    a REDO step. Updated the interface across all classes to include a
    "redo" boolean flag. If set to true, no log record is generated.
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    addressed weys code review
    fixed bug in SPR test
    ctimne timestamp for backups and vols, test case not passing
    More bug fixes for Instant Restart milestone 2.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    complex testcases for SPR and bug fixes
    refactoring w_rc_t
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    fixed bug where code was incorrectly assuming a store was unallocated
    if it's root pid was 0
    fixed some shore includes
    st_bad -> st_unallocated
    removed some dead fix code
    code formatting changes
    Many small changes to eliminate compiler warnings. Work-in-progress.
    bf_fixed_m now uses checksums for the pages it manages
    accessors from fixable_page_h to generic_page_h
    more cleanup of stnode_page
    page_s -> generic_page
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    stnode now using generic_page_header
    alloc_p-> alloc_page_h
    alloc_p now has two constructors, one which formats a new page and one
    which takes an existing page
    alloc_p's _page member is now private
    all members of alloc_page are now private
    workin on pulling secrets of bitmap allocation into alloc_page class
    initial creation of alloc_page class
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Deleted old ArchiveScanner
    Replaced uses of ArchiveScanner with new ArchiveScan
    Multi-segment restore + using backupLSN as log replay bound
    Some fixes to ArchiveScan
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Initial support for mmap as a new MmapRunScanner
    
    - Relies on the same RunFile infrastructure as RunScanner
    - Not being used for now because RunMerger always uses RunScanner
    - Future commit should add template argument to RunMerger
    - Leaving it like this for now because performance was worse with mmap
    Extended log archve to use RunFile struct
    
    ... instead of file descriptors
    - This will facilitate the mmap implementation coming soon
    Removed readSize parameter from ArchiveScanner::open
    Fixed bug with incorrect log archive read size
    Using shared_ptr to manage archive scans
    Re-structured some code in log archive scanner
    Unified classes ArchiveIndex and ArchiveDirectory
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    refactoring w_rc_t
    OKVL terminology change and optimizations
    TPCC
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    dropping solaris support
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Replaced boost::regex with std::regex
    Removed old restore code (farewell part 1)
    
    - Goodbye, old friend. It hurts me deeply to do this after years of hard
    work, but it had to be done. The old must make way for the new. It's
    been a pleasure.
    Moved latches to sm and fixed test compilation
    Removed perl script that generated stats
    Removed htab stats
    Removed bf_tree_evict.cpp
    
    - Method definitions moved to bf_tree.cpp
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Removed log_spr.{h,cpp}
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Got rid of old "plog" stuff
    Replaced log "stub" calls with generic Logger
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Adding initial file for evictioner thread
    Removed dependencies to libnuma and valgrind
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Replaced std::regex with boost::regex, since gcc doesnt support regex
    Removed unused files log.{h,cpp}
    Moved boost linker flags to sm target
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Removed sm_du_stats
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed auto_delete stuff
    Removed unused class logbuf_core and associated files
    Removed old & unused "pmap" stuff
    Removed old & unused "vtable" stuff
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Removed old util libraries from some CMake files
    Adding page_cleaner source files and test files.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Moved page eviction code into bf_tree_evict.cpp
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Removed SM level 1
    Started implementation of Restore Manager
    
    Sketched the basic API and added a simple bitmap implementation.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed LID manager
    
    Class lid_m was only used to generate lvid for new volumes. I copied the
    method inside sm.cpp and deleted the class. One less "manager" to take
    care of...
    Removed device manager and its uses
    
    Shore/Zero always had the concept of a device, which was supposed to be
    composed of multiple volumes -- in the same way a linux device is
    composed of multiple partitions. However, this destinction was never
    really realized, and a device was always assumed to contain just one
    volume.
    
    In a refactoring which was supposed to be done many years ago, I removed
    the device manager and all its uses, delegating to volume operations
    where applicable. It seems like things will keep working as expected,
    but more tests will be required to see if anything is broken by this
    change.
    CMake compiling less stuff when calling "make"
    
    Calling "make" (or, equivalently, "make all") would cause all
    alternative versions of the SM to be build as well (e.g., no_swizzling,
    plog, etc.). It would also compile all test variations (such as
    no_swizzling).
    
    I modified the cmake setup to eliminate alternative SM targets using
    the EXCLUDE_FROM_ALL property. Alternative test setups are also
    commented for now.
    Fixed and updated LogFactory
    
    - max_page_id is incremented linearly instead of using a ratio growth.
    This is because (1) certain ratios cause a bug and the page ID never
    grows (i.e., 100 pages and growth 0.5%) and (2) a linear growth is more
    repredentative of real workloads.
    - Added "sorted" option to generate log records sorted by pageID (useful
    for testing log archive)
    - Updated CMake files to compile tests with logfactory as a library
    - Fixed compilation errors and warnings
    - Replaced some of the "uint_t" usages by plain "unsigned"
    Added log archiver files to CMake
    Brought back old cmake targets
    Modified cmake files to development of atomic commit protocol
    Removed allocator.cpp from compilation units -- bugfix
    Plog implementation with dynamically growing memory
    New generic allocation mechanism for xct_t and related classes
    Implemented basic extensibility of xct for private logs
    Log refactoring: pulled log reservation logic into class log_resv
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Moved log_core methods related to storage into file log_storage.cpp
    switch to the new log buffer
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    RAW-style lock manager
    header files, too
    remove from compilation to make sure
    More RAW Lock Manager stuff. Still not used
    incomplete code for RAW lock. not enabled
    Ported Consolidation Array
    dropped code to explicitly allocate buffer pool on a remote node as this can be done by simply changing the memory policy from within the experiments
    Private lock hashtable to quickly check if the lock is already taken
    backup module
    NUMA pinning for TPCC
    Added page_evict_t
    fixed cmake to build things that depende on libnuma only when numa.h exists
    build numa enabled shore-mt library; use numa library with techcon experiments; modified techcon script to use numa enabled experiment
    buffer pool can use numa allocation routines to allocate memory to specific node
    Refactoring w_rc_t part 2
    Delete dead codes
    pulled out btree_page_h class
    calculate checksum function is no longer inline
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    renamed:    src/sm/alloc_p.h -> src/sm/alloc_page.h
    pulled in implementation of bitmap into alloc_page class.
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    fix the makefile to properly build a target that simulates in-memory db
    Build multiple targets (libraries) for the three difference cases we are interested in: swizzling, no swizzling, and in-memory
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Implement atomic_ops in terms of lintel::Atomic<>.
    This 99% removes atomoc_ops directory. A bit is still temporarily left as physical, but not logical, artifact).
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Fixes so that we can do a complete out of tree build.  Also
      other minor improvements.
    
    {examples,experiments,src/**,tests}/CMakeLists.txt: auto-generated file include paths
       Generate files in the binary directory only, and only generate them once rather
       than N different custom commands.
    
    experiments/experiments.h: move log/data stuff to /dev/shm
    
    experiments/random_inserts/select_only.cpp: improve usage message
    
    src/sthread/srwlock.cpp: add { } to eliminate compiler warning
    Zero branch from subversion rev 11038
    Fixed cleaner default policy
    Decoupled cleaner is back!
    New cleaner policies: LRU and highest-density
    No-policy-cleaner and eviction bugfix: WAL rule
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    New mixed policy for cleaner
    Implemented cleaner without policy (no_policy)
    Setting cleaner num_candidates to workspace size by default
    Cleaner candidate vector now a normal member instead of pointer
    Got rid of async candidate collection in cleaner
    Updated use of refcount in page cleaner
    
    - Refcount is reset to zero after cleaning
    Cleaner can't be initialized lazily because there is no concurrency control
    Fixed deadlocks resulting from cleaner actions
    Cleaner bugfix: only unswizzle pointers if tag == t_btree_p
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Fixed CB pinning and concurrency operations for checkpoints
    Bugfix on cleaner policies
    
    - Comparison function used in heap operations was wrong
    - Now using rec_lsn in oldest_lsn policy -- makes more sense than
    using clean_lsn
    Cleaner LSN fixes
    Fixed CB pinning and its use in cleaner and eviction
    Not syncing every page flush in cleaner
    
    - Goal here is to exploit I/O parallelism, like in SSDs, to dramatically
    improve cleaner throughput.
    - To that end, a bunch of write calls are performed for multiple
    clusters of adjacent pages in the cleaner workspace, but fsync is
    invoked only once for the whole workspace.
    - Marking pages as clean and logging the page writes only happen after
    the fsync call.
    Fixed eviction bug (pin cnt was ignored)
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Updated stnode_cache_t to use normal page fix
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Fixed cleaner bug
    
    - When latch_and_copy fails on the first and only page of a cluster,
    loop would get stuck.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 3]
    
    - Fixed eviction and unswizzling
    - Still having trouble with eviction getting stuck due to invalid parent
    pointers though. Need to fix that next...
    New worker_thread_t class to unify control of dependent threads
    
    - So far used only in the cleaner, but it should be reusable for any
    dependent thread, such as checkpointer, log archiver, segment writer,
    etc.
    Fixed asynchronous candidate collection in cleaner
    
    - Separate thread can collect candidates asynchronously while other
    frames (collected in a previous invocation) are cleaned
    - Added option to activate this behavior
    Updated bf_tree_cleaner
    
    - New "mixed" policy
    - Loading candidate frames asynchronously in a separate thread
    - Fixed bug where cb latch was not being released
    Updated stress_cleaner program
    
    - Allows reading page accesses from a trace file or generate them
    randomly
    - Optimized candidate handling
    Added support for metadata pages to bf_tree_cleaner
    
    - If parameter sm_cleaner_ignore_metadata is false, each cleaner round
    will also flush dirty alloc and stnode pages.
    Added cleaner option to only write large clusters of pages
    
    - Requires new logic in the bf_tree_cleaner::clean_candidates loop
    - Also added timer stats for cleaner
    Fixed cleaner candidate collection
    
    - Heap was not actually being used, since no pop was performed
    Updated/fixed cleaner wakeup mechanism
    Cleaner refactoring IV: policy infrastructure
    
    - Added functionality to parametrize candidate selection in the cleaner
    according to a policy, which so far includes a type (enum class
    cleaner_policy) and a number of candidates to select (num_candidates)
    Cleaner refactoring III: simplified bf_tree_cleaner
    
    - Cleaning process is now more modular and with fewer lines of
    code.
    Implemented STL allocator using posix_memalign
    
    - Using it in page_cleaner_base so far
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Cleaned up CB and page header fields
    Small cleanup on page cleaners
    
    - Removed error_happened and is_dirty_shutdown stuff
    - Using std::atomic instead of lintel and manual fences
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Initializing cleaner lazily & fixed log_truncate option
    
    - Log truncation should be off by default, and it has nothing to do with
    sm_format
    - Cleaner should only be initialized if it's ever used, i.e., if
    get_cleaner is called
    - This makes for quicker startup & shutdown during test cases
    Page cleaner acessed directly with bf_tree::get_cleaner
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed support for careful write ordering
    
    ... which never really worked and breaks instant restore, so we don't
    really need it.
    Implemented alloc_cache_t::write_dirty_pages
    
    - Since our alloc cache does not maintain bitmpas within page images,
    relying instead on its internal data structures, a special method is
    required to flush these pages in the page cleaner.
    - The method simply reads an old page image and replays updates on it
    with single-page recovery, but it does this only for pages which were
    actually updated since a given LSN.
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Removed auto_delete stuff
    Flushing log after force volume & other small fixes
    Fixed bug on alloc_cache
    
    - Alloc page of the given pid in alloc and dealloc SSXs was being
    calcullated wrong, to that per-page chain was not correctly maintained.
    - Small fixes in bf_tree_cleaner
    Fixing bf_tree_cleaner not flushing alloc and stnode
    
    force_volume() explicitly reads this pages from disk, triggering single page recovery, and then writes them back.
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Introducing page_cleaner_base generic class
    
    - virtual class for page cleaner (bf_tree_cleaner now inherits from this class)
    - join_cleaner(timeout_t) replaced for simple join(), since timeout_t seems not to be working anymore
    - request_stop_cleaner() and join() unified into new shutdown() method
    - take_interval() and interval_millisec_min/max removed. Cleaner now wakes up every fixed time and clean pages, even if no implicit request was made
    Refactored classical page cleaner
    
    Page cleaner now is a single class, no more master-slave.
    Fixed some assertion bugs
    
    - PageID 0 is actually a valid one, so cleaner should not assert that
    - sx_append_extent was switched to use sysevent instead, but the ssx
    object was still being created, leaving an open (chained) ssx in the xct
    state, which was causing a nasty bug when interting log records form the
    parent UX.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Make cleaner force wait until all frames are clean
    
    - Depending on when exactly force_all get called prior to a shutdown, it
    could happen that there are further updates after the clean round
    starts, so that some frames will be flushed but not cleaned. In that
    case, a while loop should check if all frames are clean before exiting
    (in a fuzzy way -- no latches acquired)
    Fixed cleaner invocation on eviction
    
    - Eviction may now run for infinitely many rounds, until requested
    number of pages is evicted. On each round, cleaner is activated.
    - Cleaner now reports the number of pages cleaned on each round. This is
    useful for reporting/debugging. It only includes actually cleaned pages,
    and not simply written ones (page may be written but LSN changed on
    buffer -- thus not cleaned).
    - Simplified log flush to curr_lsn on each cleaner round.
    Fixed cleaner bug by comparing page LSNs
    
    - Before marking a page as clean, the cleaner must check if the page LSN
    did not change since the written copy was taken. Furthermore, it must
    properly latch the page.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Small fixes for new eviction algorithm
    
    - Unpin for refix does not always hold a latch, so assertion was false.
    Not sure if that's how it's supposed to be. It sucks because it breaks
    our assumption that pin count is only updated when latched. I need to
    study the btcursor code to understand this better.
    - Fixed small bug with cleaner getting an invalid page (vol == 0)
    - Added some comments and debug messages.
    Finally fixed cleaner force_all bug
    
    - Declared _requested_volumes volatile (not ideal solution, but works
    for now -- should switch to C++11's atomic later)
    - Changed <= into < on force_all for loop
    Further attempts to fix page cleaner
    
    - Added even more fences and extra wake-up signals
    - Still not working
    Added memory fences to cleaner daemon
    
    - Master and slave threads of cleaner daemon rely on several flags to
    control their execution, but no synchronization mechanism was in place
    to guarantee the visibility of updates made to such flags. This means
    that threads could come to a halt.
    - I added fences to all places where I think such visibility is
    required. The whole orchestraiton of such threads could actually be made
    simpler, but I'm guessing that all cases are covered for now.
    Updated debug messages in bf_tree_cleaner.cpp
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Removed MAX_VOL_COUNT and fixed bf_cleaner volume mgmt
    
    All places that ask for the maximum number of mounted volumes now access
    vol_m::MAX_VOLS instead of the constant MAX_VOL_COUNT. However, this
    behavior is not entirely correct, since we need to distinguish between
    the maximum number of mounted volumes (MAX_VOLS) and the maximum number
    of volumes that can ever be created (MAX_VID). Right now, the two are
    undistinguishable, but we may want to fix that in the future.
    
    Simplified volume management in the buffer cleaner. Cleaner thread is
    assigned to volume based on a simple mod operation and reserved slot 0
    for "no volume" was eliminated from certain arrays, since it was not
    used (at least one cleaner thread must always exist).
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Made vid_t a simple typedef and deleted volid_t
    Added a design-related comment to page cleaner code
    Added some debug messages
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Updated SM code to consider cmake flag USE_ATOMIC_COMMIT
    Updated handling of CLSN field of pages
    Added check on bf cleaner to only flush committed pages
    Removed old bf_m code
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Fixed a regression bug from implementing backward scan.
    Also changed the buffer pool flush code so it does not flush in_doubt pages.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    More bug fixes for Instant Restart milestone 2.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Write elision as ifdef
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Incremental check-in for the work in Checkpoint and Log Analysis.
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    refactoring w_rc_t
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    dropping solaris support
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    deleted:    src/sm/page_bf_inline.h
    Many small changes to eliminate compiler warnings. Work-in-progress.
    cleaned up generic page header's fields
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    generic_page_h -> fixable_page_h
    removed/changed incorrect/unneeded references to generic_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    Encapsulated access to control block table and latches behind buffer pool API. This gives us flexibility in implementing layout of control blocks and latches without having to make drastic code changes. I implemented a new allocation scheme that alternates control blocks and latches in this fashion: |CB0|L0|L1|CB1|CB2|L2|L3|...
    This schme helps removing a pathology that I believe is related to the L2 spatial prefetcher. See Jira Issue 119
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Fixed chkpt log scan bug
    Implemented get_byte_distance for two LSNs
    Fixed write elision and decoupled cleaner
    Lightweight propstats using chkpt data
    Fixed some nobd bugs and default options
    
    - Fuzzy checkpoints do not scan buffer frames in nodb mode
    - chkpt_m::_use_log_archive must be set in nodb mode
    Updating dirty page table during eviction in nodb mode
    Chkpt considers archived LSN to compute min_rec_lsn w/o nodb mode
    Implemented log analysis with mmap (direct fetch)
    
    - also downgraded log_core assertions
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Fixed use of fuzzy checkpoints with nodb
    Fixed log partition recycling with fuzzy checkpoints
    Fuzzy chkpt fix: collecting dirty pages from vol_t table
    Fuzzy chkpt fix: ignoring read-only transactions
    Taking checkpoint right after log analysis
    Brought back traditional fuzzy checkpoints
    chkpt_m now derives directly from worker_thread_t
    Chkpt using new block-wise BackwardLogScanner
    Optimized chkpt_t::scan_log
    
    - Replaced std::map with std::unordered_map
    - Reduced number of lookups per analyzed log record
    - Bandwidth improved 3x for in-memory log scan
    Fixed nodb checkpoints by using archived_lsn
    
    - Checkpoints now take log archive into account by not marking a page as
    dirty when the related update has an LSN below the last archived LSN.
    Correct recovery of dirty pages in nodb mode
    Detecting warmup based on hit ratio & other updates
    Fixed adding backups
    Chkpt fixes and adjustments
    Fixed redo bookkeeping and vol_t shutdown
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    Initializing chkpt_m correctly after log analysis (fixes #35)
    Implemented checkpoint-less no-db mode
    Little refactoring in chkpt_t
    Reverting all that chkpt_only_root_pages jazz
    Chkpt thread now derives from worker_thread_t
    Added (yet unused) option chkpt_only_root_pages
    
    - It's not as easy as I thought to keep track of root pages only in
    checkpoints, so I abandoned the project but left the option here for the
    future.
    Fixed compilation on gcc 4.9
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Got rid of LOG_INSERT macro in chkpt.cpp
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Made tid_t a simple uint instead of its own class
    Moved logrec header initialization out of constructors
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed 1thread mutex and xct dependency list
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Fixed bug on chkpt_thread_t
    
    - ss_m::chkpt is not necessarily initalized when the chkpt thread is
    forked.
    Implemented std::thread wrapper to replace sthread_t
    
    - Used chkpt_thread_t as our first guinea pig
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Chkpt mgr keeps track of last chkpt LSN
    
    - which allows returning a meaningful min_active_lsn() when both
    min_xct_lsn and min_rec_lsn are null.
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Fixed log analysis bug
    
    - Because we were using is_page_update() to track dirty pages,
    compensation log records were not being processed as dirtying updates,
    causing wrong PageLSN computation.
    Recycling chkpt files regardless of log-file recycling
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Chkpt serialization to file (initial code from Lucas)
    
    - Checkpoint data is now serialized to a serparate file instead of as
    embedded *_tab log records.
    Fixed critical chkpt bug: proper begin and end LSNs
    Fixed semantics of chkpt_m::get_min_active_lsn
    
    - When either min_rec_lsn or min_xct_lsn are null, method
    chkpt_m::get_min_active_lsn() should take special care -- see comments
    Removed deprecated store ID on chkpt_buf_tab
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Revised checkpoint wakeup mechanism & added cached min LSN values
    
    - If negative interval is given to chkpt thread, then it waits on a
    condition variable without a timeout, and it only runs when a signal is
    recieved. Signals are also handled properly with critical sections and a
    _wakeup flag.
    - min_rec_lsn and min_xct_lsn values of the latest checkpoint are now
    cached inside chkpt_m to allow retrieval without entering the critical
    section, i.e., without waiting for a currently running checkpoint.
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Removed auto_delete stuff
    Fixed deadlock in chkpt thread
    
    - awaken_lock should not be acquired when waking up a thread, since it
    may be invoked from code which is waiting for flush daemon, which may
    also be waiting for awaken lock (e.g., when opening a new partition)
    - Current solution is to simply send awake signal without locking. This
    should be fine because chkpt can handle missed signals.
    Passing dirty page table to vol_t by copy instead of pointer
    
    - Table must be copied to avoid unexpected segmentation errors
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Cleaned up some old restart code
    Fixed silly checkpoint bug
    
    - The log scan of a decoupled checkpoint must cover the range between
    the current chkpt_begin and the last one, so that the complete history
    of log records is captured in the latest checkpoint. For that to happen,
    the system must first write out a begin log record *and then* start
    scanning. Previous code was only inserting a begin after scanning, which
    means all log records inserted during the scan were ignored. Really
    dumb.
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Added chkpt_t test and fixed bugs found so far
    Clean-up of the log analysis mechanism [part 5]
    
    - Moved logic of backward log scanning and serialization into log
    records inside class chkpt_t.
    - Removed master_lsn and other parameters of log scan.
    Clean-up of the log analysis mechanism [part 4]
    
    - Removed lock table and integrated list of acquired locks into
    transaction table
    Clean-up of the log analysis mechanism [part 3]
    
    - Deleted old monstruous checkpoint method. Now relying solely on
    decoupled checkpoints.
    - TODO: clean-up all parts of the code that assumed a traditional
    checkpoint (e.g., concurrency control on xct table, buffer pool, etc.)
    Clean-up of the log analysis mechanism [part 2]
    
    - Simplified and fixed behavior of functions used to mark tx as active
    and page as dirty. The logic assumes a backward scan only.
    - Simplified the logic of processing bf, xct, and lock tables, so that
    the methods could be removed and the code inlined in the big log scan
    loop.
    - Removed some unnecessary stuff (e.g., undo_nxt in tx table)
    Clean-up of the log analysis mechanism [part 1]
    
    - Removed forward scan
    - Moved common logic of marking a page dirty, a transaction active,
    etc., into the chkpt_t class, making the code more modular and with less
    repetition.
    - Log analysis now has a more generic treatment of log records, without
    a lot of specific tasks executed depending on the logrec type. Actions
    such as acquiring a lock, marking a page dirty, and a transaction active
    do not depend on the logrec type -- they are executed for any logrec
    that represents an update.
    - Removed a lot of complexities and unnecessary optimizations (e.g., the
    "mapCLR" stuff)
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Fixing chkpt with msec logrec
    Adding checkpoint command line options
    Removing false assertion
    Removing vector<logrec_t> lock_tables in forward scan
    The chkpt records the lock tables before the transaction tables (to make backward scan easier).
    In forward scan, the work around was to save the lock tables log records to process them later (after processing the transaction tables).
    This is ugly because logrec_t is too big and it was causing SEGFAULT in lock_tables.push_back(*r), because the copy constructor would copy an entire size of logrec_t, while the actual log record could be way smaller.
    LogConsumer blocksize must be > sizeof(logrec_t)
    Maybe add an assertion to LogConsumer::LogConsumer()
    Replacing vector for map in chkpt_t
    vector is too slow for handling insert/delete operations.
    map is much faster, but we had to change the way chkpt_t is represented.
    Including stopwatch.h
    So we can test and measure bottlenecks in the code :)
    Adding forward_log_scan again.
    Thank you, Caetano.
    Deleting method not being used.
    Fixing bug with lock acquisition for t_page_img_format
    logrec_t::t_page_img_format is not supposed to acquire any locks, but it was being processed by chkpt_m::_analysis_acquire_lock_log() anyway.
    Error was ocurring because it was not matching any of the cases in the mentioned method.
    Since this type of log record was not expected, the default case was throwing an error.
    Fixing bug in chkpt_dev_tab
    Similar to the previous bug with chkpt_bf_tab. We have to consider the case where a device is listed in the chkpt_dev_tab, but it was dismounted between chkpt_begin and chkpt_dev_tab log records.
    Fixing bf_tab bug in log scan
    backward_scan_log() populates an object chkpt_t with the current server status.
    It scans the log backward, from the given lsn to the most recent completed checkpoint.
    A checkpoint has information about all log records that happened BEFORE its chkpt_begin log record.
    However, the checkpoint is currently split into multiple log records that might not be adjacent to each other.
    For this reason, when the find the chkpt_bf_tab log record, it has the pages that were in the buffer up to the point of the chkpt_begin log record.
    We have to consider the case there a page in the chkpt_bf_tab was flushed between the chkpt_begin and the chkpt_bf_tab log records.
    Fixing next_vid bug
    next_vid is always initialized to 1, so when reading next_vid from previous chkpt we must decrement this value by 1.
    Enabling dcpld_take() for checkpoints.
    Missing verification if a page was already flushed
    ... before inserting the page in the buffer table of a chkpt.
    Fixing xct_next() bug.
    The problem was that xct_next() was calling fetch(), which returns a pointer to the log record currently allocated in the log manager read buffer. xct_next() was returning the same pointer to the caller and releasing the log latch.
    If xct_next() is used isolated from other operations, this is not a problem, but if other running operations modify the log read buffer, the pointer returned might be invalid.
    The solution was to make xct_next() receive a log record buffer and make a copy to it before releasing the log latch.
    Fixing chkpt bug eOUTOFLOGSPACE
    When inserting chkpt log records, consume_chkpt_reservation() was being called to decrement log_resv::_space_resv_for_chkpt, but this value was never being incremented. In other words, there was nothing "reserving" space for the chkpt log records to come.
    log_resv::_space_resv_for_chkpt was initialized in the contructor only and never incremented again.
    If we want to guarantee that there is enough log space to complete the checkpoint before starting it, then we must call verify_chkpt_reservation() in the beginning of the chkpt_m::take() method.
    verify_chkpt_reservation() will check if there is already enough space reserved. If not, it will try to reserve space. If it fails to reserve space, then the conclusion is that the log is full.
    Minor fixes on dcpld_take() method.
    Just some minor changes to make it reflect the older take() method as much as possible.
    Considering lsn from log record t_store_operation
    The lsn of a log record t_store_operation must be considered for redo(), but t_store_operation is not adding a page to buffer table. Since no page is added, the lsn of these log records were not being considered before.
    Changing initialization of min_rec_lsn and min_xct_lsn
    min_rec_lsn is the minimum rec_lsn from all pages in the buffer table.
    min_xct_lsn is the minimum first_lsn from all transactions in the xct table.
    This values are used for redo() and undo(), respectively.
    If no pages were modified or no transactions were executed, the redo_lsn and undo_lsn should be the same as the begin_lsn for the current checkpoint object.
    Removing useless parameters from chkpt methods.
    Making life simples :)
    Writing log records for lock_table.
    Printing the lock table for DEBUG.
    Fixed assertion logic error.
    Fixed bug in lock table
    Entries in lock table were not being generated for each transaction (only for the ones that acquired locks).
    This would cause an error, since the index in the transaction table should be also used in the lock table.
    Fixed some points were transactions were removed from the table, but the lock entries were not.
    Changing constructors of chkpt dev and backup table
    Modified these constructors so they match the pattern followed by the other contructors.
    Code re-organization and handling big chkpt tables
    - Re-organized the code for dcpld_take().
    - Changed the constructor of chkpt_dev_tab_log (instead of receiving a vector reference, it receives a pointer. This is more flexible and follows the "pattern" of the other chkpt_log constructors.
    - The checkpoint tables that are bigger than the max_size of logrecord are now handled by inserting multiple log records.
    Cleaning code and removing warnings
    Warnings related to int-uint compararissons were removed.
    Removing forward scan_log()
    Since only the backward_scan_log() acquires locks, the forward scan is useless.
    Adding mutex to dcpld_take()
    Adding synchronization control to ensure that no interleaving checkpoints are generated at the same time.
    This behavior is already present in the standart take() method.
    Other minor details changed in the dcpld_take() method.
    Adding checkpoint backward scan and auxiliary methods.
    This was heavily based on the log analysis backward scan method.
    The backward scan handle the acquired locks from transactions.
    Cleaning chkpt.cpp code.
    Added methods for decoupled checkpoints.
    scan_log()
    dcpld_take()
    Replace the calls from original take() for dcpld_take().
    scan_log() now handles write_page log records.
    Keep track of all pages that were flushed and the last lsn of when it was flushed.
    At the end of scan_log(), remove from bf_table the pages that were flushed after their last update (page_lsn).
    Moving includes from .cpp to .h.
    Added methods for decoupled checkpoints.
    scan_log()
    dcpld_take()
    Replace the calls from original take() for dcpld_take().
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Removed some legacy chkpt reservation code
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Implemented checkpoint and restart for vol backups
    
    Added a chkpt_backup_tab log record, similar to chkpt_dev_tab. It keeps
    track of the paths for the backup files of each volume. During restart,
    the log records are simply replayed. Since we don't have delete_backup
    operations so far, there is no need to replay them in reverse order, as
    done for mounts/dismounts.
    
    (Untested)
    Moved lastMountLSN into log manager
    Decoupled chkpt_m from smlevel_0
    
    Class chkpt_m does not inherit from smlevel_0 anymore. Instead, the
    required members and methods (which are all static) are accessed through
    ss_m. Similar refactoring should follow for other classes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Implemented shutdown of volume manager
    
    When destroying ss_m, invoke shutdown on vol_m, which simply relays the
    call to all mounted vol_t. The shutdown procedure is essentially an
    unlogged dismount. If a restore is ongoing and an abrupt flag was not
    set, it should wait for restore to complete.
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Bugfix on setting page LSN in ACP
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    switch to the new log buffer
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Clean up the restart code more for the 2nd M3 check-in, also fixed a few bugs in Log Analysis phase.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Do set reset first_lsn in a loser transaction so it can be picked up by checkpoint.
    Renamed from 'doomed' to 'loser' transaction.
    Added test hooks and sm_external.h
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    Initial Recovery milestone 2 design doc (still work-in-progress), plus a few minor changes in code.
    Minor bug fix, updated documents and added initial (work-in-progress) design doc for milestone 2.
    Modifications based on Goetz's code review comments, also initial test plan.
    More bug fixes, all existing crahs and restart test cases (27 of them) are passing now.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Do not scaverge log space after checkpoint, single page recovery needs old log records.
    Incremental check-in for the work in Checkpoint and Log Analysis.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Minor changes in checkpoint area, also added synch checkpoint to Recovery, one at the end of Log Analysis, and one at the end of UNDO phase.
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    Fix for coding convertion style:
    1. Position of '{'
    2. local variable name
    Eliminate duplicate code into a shared function in test_restart.cpp
    Remove accidently added file
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Decoupled cleaner is back!
    New cleaner policies: LRU and highest-density
    New mixed policy for cleaner
    Implemented cleaner without policy (no_policy)
    Cleaner candidate vector now a normal member instead of pointer
    Got rid of async candidate collection in cleaner
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Bugfix on cleaner policies
    
    - Comparison function used in heap operations was wrong
    - Now using rec_lsn in oldest_lsn policy -- makes more sense than
    using clean_lsn
    Not syncing every page flush in cleaner
    
    - Goal here is to exploit I/O parallelism, like in SSDs, to dramatically
    improve cleaner throughput.
    - To that end, a bunch of write calls are performed for multiple
    clusters of adjacent pages in the cleaner workspace, but fsync is
    invoked only once for the whole workspace.
    - Marking pages as clean and logging the page writes only happen after
    the fsync call.
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Fixed asynchronous candidate collection in cleaner
    
    - Separate thread can collect candidates asynchronously while other
    frames (collected in a previous invocation) are cleaned
    - Added option to activate this behavior
    Updated bf_tree_cleaner
    
    - New "mixed" policy
    - Loading candidate frames asynchronously in a separate thread
    - Fixed bug where cb latch was not being released
    Added support for metadata pages to bf_tree_cleaner
    
    - If parameter sm_cleaner_ignore_metadata is false, each cleaner round
    will also flush dirty alloc and stnode pages.
    Added cleaner option to only write large clusters of pages
    
    - Requires new logic in the bf_tree_cleaner::clean_candidates loop
    - Also added timer stats for cleaner
    Added ref_count_ex on bf_tree_cb to count only X-latch acquires
    
    - Also see comment on bf_tree.h: we should reuse the mechanism in
    latch_t to count references and get rid of counters in the control block
    Cleaner refactoring IV: policy infrastructure
    
    - Added functionality to parametrize candidate selection in the cleaner
    according to a policy, which so far includes a type (enum class
    cleaner_policy) and a number of candidates to select (num_candidates)
    Cleaner refactoring III: simplified bf_tree_cleaner
    
    - Cleaning process is now more modular and with fewer lines of
    code.
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Small cleanup on page cleaners
    
    - Removed error_happened and is_dirty_shutdown stuff
    - Using std::atomic instead of lintel and manual fences
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Removed unused and unecessary header files
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Introducing page_cleaner_base generic class
    
    - virtual class for page cleaner (bf_tree_cleaner now inherits from this class)
    - join_cleaner(timeout_t) replaced for simple join(), since timeout_t seems not to be working anymore
    - request_stop_cleaner() and join() unified into new shutdown() method
    - take_interval() and interval_millisec_min/max removed. Cleaner now wakes up every fixed time and clean pages, even if no implicit request was made
    Refactored classical page cleaner
    
    Page cleaner now is a single class, no more master-slave.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Fixed cleaner invocation on eviction
    
    - Eviction may now run for infinitely many rounds, until requested
    number of pages is evicted. On each round, cleaner is activated.
    - Cleaner now reports the number of pages cleaned on each round. This is
    useful for reporting/debugging. It only includes actually cleaned pages,
    and not simply written ones (page may be written but LSN changed on
    buffer -- thus not cleaned).
    - Simplified log flush to curr_lsn on each cleaner round.
    Whitespace changes
    Finally fixed cleaner force_all bug
    
    - Declared _requested_volumes volatile (not ideal solution, but works
    for now -- should switch to C++11's atomic later)
    - Changed <= into < on force_all for loop
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed MAX_VOL_COUNT and fixed bf_cleaner volume mgmt
    
    All places that ask for the maximum number of mounted volumes now access
    vol_m::MAX_VOLS instead of the constant MAX_VOL_COUNT. However, this
    behavior is not entirely correct, since we need to distinguish between
    the maximum number of mounted volumes (MAX_VOLS) and the maximum number
    of volumes that can ever be created (MAX_VID). Right now, the two are
    undistinguishable, but we may want to fix that in the future.
    
    Simplified volume management in the buffer cleaner. Cleaner thread is
    assigned to volume based on a simple mod operation and reserved slot 0
    for "no volume" was eliminated from certain arrays, since it was not
    used (at least one cleaner thread must always exist).
    Made vid_t a simple typedef and deleted volid_t
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    page_s -> generic_page
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Removed "robust" b-tree methods
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Bringing back swizzling [part 3]
    
    - Fixed eviction and unswizzling
    - Still having trouble with eviction getting stuck due to invalid parent
    pointers though. Need to fix that next...
    Removed sm_du_stats
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Whitespace changes
    Fixed B-tree split by deleting body space
    
    B-tree items consist of a head, which is a fixed-length header stored in
    the head array from left to right, and a body, which can be
    variable-length (but multiple of sizeof(item_body)) and is stored right
    to left.
    
    The previous split operation only deleted entries from the head array,
    without properly deleting the associated bodies.
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Bug fixes for page rebalance full logging.  The very basic full logging is working but Still have more issues to investigate, the feature is not fully functional at this point.
    Modified test code so it is easier to merge with changed code from master.
    Initial implementation of full logging for page balance operation, code is not tested at this point.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    rename, comment changes
    New log type for b-tree insertion
    addressed Mark's comments
    moved child_emlsn code to handle class
    forgot to handle _bufferpool_managed properly in borrowed_btree_page_h
    removed unneeded function, init_as_empty_child, in favor of existing format_steal
    removed bad assertion in format_steal that assumed prior page was a
    B-tree page
    added a new_lsn argument to format_steal (previously it kept whatever the
    page's LSN previously was)
    removed init_fix_steal function in favor of calling fixed then format
    (we are separating fixing from formatting for more needed flexibility)
    bugfix
    merge with bufferpool change
    removed lying (outdated) comment
    removed unnecessary class scratch_btree_page_h
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    updated emlsn on eviction
    addressed code review feedbacks
    added basic Q ticket plumbing
    Added SPR APIs
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    extra ()s to make operation order clearer
    line wrapped a few functions
    pulled out in-line definitions to end of file
    made helper check space for insert private
    more cleanup of private record accessors
    updated class comment with results of refactoring
    pulled in key length, poor man's key types and constructors into class itself
    comments for packing members
    both robust and non-robust search are now separate methods rather than
    one being #ifdef'd out
    now fully uses robust methods (forgot two places)
    bug fix to robust_item_data
    added comments for robust interface
    on second thought, removed optimization for variable size data too
    small; too ugly for the speed savings
    forgot to bump copyright year
    optimization to avoid worrying about too small items in robust cases
    fast path is also now robust
    new robust version of search (currently replacing old one via #if's for
    testing)
    fast path is completely robust now but slow path needs work
    length of key for leaf items no longer includes prefix length
    got rid of get leaf fields
    new pack functions for packing records
    more uses of predict leaf data length
    clarified that get_rec_space does not take -1 as an argument
    cleaning up interface needed for swizzling
    removed need for rec_leaf
    replaced dat_leaf[_ref]
    new element accessors, element and copy_element
    removed need for rec_node
    new internal record accessor, _element_offset
    *_key's -> get_key
    pulling unpacking of keys code into *_key methods
    rearranging functions
    changing comment styles for one-liners; fixing comment indentation
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    removing dead code: get_key_len
    unified _compare_{leaf,node}_key_noprefix into one function
    removing dead code
    fix for max_entry_size accounting issue
    cleaned up helper function
    updated comments for search_node
    fixed a couple of uses of search_node to better use new orthogonal interface
    new_search->search, replace search_leaf with search
    removed original search function (references) in favor of search_leaf
    and search_node as appropriate
    Merged two versions of search using (for the moment) a new routine new_search
    initial revised version of search_leaf
    more cleanup
    renamed fixed length item fields
    adding comments
    rearranged classes to provide better access control flexibility
    some cleanup
    more interface cleanup
    more interface cleanup
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    working on removing references to slot_sz
    removed get_rec_size* functions in favor of new get_rec_space function
    based on item_space
    
    removed dead code page_usage
    introduced predict_item_space
    removed use of old interface (e.g., slot_addr)
    btree_page[_header] no longer all public
    modified reserve_ghost take element_length rather than record size
    delete_slot -> delete_item
    finished converting resize_slot to resize_item
    new item_resize function
    fence packing now excludes length
    inlined _insert_expand_no_log, removed another occurrence of insert_slot
    bugs fixes to item code
    replace another occurrence of slot_insert
    now should be using packing function for all fence slots
    introduced a packing function for the fence slot
    fixed slot length definition for slot 0
    fixed fence accessors
    clarified difference between truncated key length and normal key length
    hold together node field access code
    pulled together common code for accessing leaf item fields
    made an accessor for the poor man's key, _poor
    new API for items; beginning to switch code to it
    beginning to turn slots into items
    removed unused popping feature of defrag
    converted slot consistency checker
    replaced _append_nolog with calls to slot_insert
    pulled out btree_page_h class
    compute slot_length correctly for fence slots
    removed data array
    delete_slot pulled out, added typedef's for slot_body
    replaced sinome used of casting
    code reformatting
    deleted:    src/sm/page_bf_inline.h
    un-inlining functions in page_bf_inline.h
    cleanup includes, friends
    comment sections
    move last of buffer manager's direct dependence on btree_page_h
    mostly code reformatting
    converting to BOOST_STATIC_ASSERT
    cleaned up generic page header's fields
    pulled down some more B-tree fields
    removed unused private store page field
    moved down two B-tree fields
    accessors from fixable_page_h to generic_page_h
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    generic_page_h -> fixable_page_h
    created a btree_page_header class to avoid need for hardwired constants
    that must stay in sync
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    fixed extremely dubious casting between page handles by introducing a
    new class, borrowed_btree_page_h
    btree_page_h now checks page has correct tag a via assertion
    bug fix to one of the tests that did not set the tag correctly
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
    page_p -> generic_page_h
    removed pragma interface/implementation
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    Fixed a logic error in btree_p::compare_with_fence_high (const char* key, size_t key_len) that struck when the search key exactly matched the page prefix.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    common cleanup: removed some unused files
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Removed 'undo' parameter from B-tree methods
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Fixed some restart bugs & general clean-up
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Whitespace changes
    Fixed btree growth to free page if it fails
    
    - A Btree growth (i.e., creation of a new root) may fail because
    multiple threads can race and only one wins. In that case, the page
    initially allocated must be freed with an SSX.
    Removed SM level 1
    Removed SM level 2
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Added store number parameter to B-tree locking
    
    Since store number is not available in the page ID anymore, all B-tree
    locking methods (e.g., _ux_lock_key) must include the store number as
    an additional parameter.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Replaced all occurrences of volid+snum with stid_t
    Enabled concurrent transaction page loading of in_doubt page, this is for on-demand REDO operation where the user transaction triggers REDO operation in M3, no blocking.
    The M2 behavior was that user transaction is not allowed to load in_doubt page and an error was raised to rollback the user transaction.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Fixed an infinite loop bug, also update the 'known issues' list in Recovery.docx to track the I/O layer issues discovered by Caetano.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Several bug fixes for 'Instant Restart' milestone 2.
    RAW-style lock manager
    cleaned up comments, preconditions for _ux_lock_range
    merge with bufferpool change
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Small refactor of search to clean it up and improve readability.
    
    Changes to scripts ought be reveresed, likely.
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Added put operation to zero.
    
    Added a put operation, which is essentially "update, or insert if didn't exist".
    
    src/sm/btree.* : add btre_m::put
    
    src/sm/btree_impl.* :
    
    Separated the traversal and getting if it was found/a ghost for insert and update into new function
    _ux_get_page_and_status.
    
    Split insert & update core functions into a head and a tail part; tail does the "heavy lifting" of
    modification, head does the searching.
    
    Use insert_core_tail and update_core_tail to implemetn _ux_put_core and _ux_put.
    Zero branch from subversion rev 11038
    Got rid of old "plog" stuff
    Fixed CArray concurrency bug (issue #22)
    Removed unused class logbuf_core and associated files
    Brought back old cmake targets
    Set Aether delegated release to on by default
    switch to the new log buffer
    removed boost static assert for old debian
    parameterize carray active slot count
    bug fix on delegated-buffer-release
    subtle changes
    slight comment change
    Added MCS_EXPOSE options
    Ported Consolidation Array
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Replaced restart_m with restart_thread_t
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed w_stream stuff
    Made tid_t a simple uint instead of its own class
    Removed 1thread mutex and xct dependency list
    Removed old&unused xct_log_t
    Got rid of old "plog" stuff
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Goodbye fileoff_t!
    Removing #define USE_TLS_ALLOCATOR
    
    This was being defined by default anyway. No documentation, be the alternative
    to the TLC allocator was called "naive allocator", so it is probably safe to
    discard it.
    Moving #defines to proper file
    
    Defining variable in the source files might generate unpredictable bugs if
    dependency between compilation units change.
    
    For example, #define BP_ALTERNATE_CB_LATCH was done in bf_tree.h, but used
    also in bf_tree_cb.h. If someone else included bf_tree_cb.h without #define,
    weird behaviors would happen.
    Added global instance for char memalign_allocator
    
    - Still unused so far...
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed prologue_rc_t
    Removed unused and unecessary header files
    Removed old & unused "pmap" stuff
    Moved ticker thread inside log_core class
    
    - New init() method must be called after constructor to fork it
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Removed obsolete ArchiveMerger class
    Implemented ticker thread
    
    - When enabled, this thread inserts a tick event log record every second
    or millisecond, depending on the configuration.
    Fixed bugs after rebasing branch smlevel on restore
    Decoupled chkpt_m from smlevel_0
    
    Class chkpt_m does not inherit from smlevel_0 anymore. Instead, the
    required members and methods (which are all static) are accessed through
    ss_m. Similar refactoring should follow for other classes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Some whitespace changes
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed traces of device_m from sm_base.h
    Refactored log manager to use sm_options
    
    Same thing as done for bf_tree_m on the previous commit, but now for log
    manager classes (log_core, log_common, logbuf_core). This was quite
    tricky to achieve due to the crazy dependencies in log manager
    initialization and the complete lack of reuse in logbuf_core.
    Added code to instantiate and activate log archiver
    Removed old index interface from Shore
    Updated plog tests
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Decoupled Aether methods in log_core to enable atomic commit protocol
    Implemented simple commit logic on clog
    New generic allocation mechanism for xct_t and related classes
    Initial code for Instant Restart performance test, work-in-progress.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Implemented backward log scan, not lock acquisition and no test yet, the function is not being executed currently.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Fixed compile warning messages from test_backup.cpp and test_spr.cpp.
    Minor updates in design documents, more will come later.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Return value checks, conform to coding convention, etc
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    backup manager now called from SPR
    refactoring w_rc_t
    Removed regex package
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    st_bad -> st_unallocated
    removed some dead fix code
    code formatting changes
    Many small changes to eliminate compiler warnings. Work-in-progress.
    removed unused t_store_freeing_exts state of store_deleting_t enum
    added missing includes to sm_base.h
    enable/disable statistics at runtime
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Various restart fixes
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Changed GC pool forest default settings
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    merged okvl branch
    RAW-style lock manager
    Private lock hashtable to quickly check if the lock is already taken
    refactoring w_rc_t
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    converted slot consistency checker
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    bug fix for debug level 3 code
    new function, lock_m::give_permission_to_violate, that a transaction may
    use to give permission to other transactions to violate its locks.
    _check_compatible can now return a lsn to add to read_watermark if the
    lock is granted (because of control lock violation.)
    pulled out code for checking if our new lock mode request is compatible
    with an existing request into a single in-line function.
    added comment reminder that we could downgrade SIX to IX on release
    read-only locks someday
    early release read-only locks releases U as well as S and SI locks
    made sure we update lock tag when we release any lock with exclusive access
    added one more critical section to remove last UNSAFE operation
    codified the unconventional access rules for some of the fields of
    lock_queue_entry_t; this allowed moving several operations to SAFE via
    some asserts checking which thread was doing the work
    extended some critical sections, added one to make more operations SAFE
    added appropriate spin locks to make ELR tag accounting safe
    Added documentation to lock_queue_t class on what fields are protected
    by what latches.  Renamed locks to latches when they were actually
    latches.
    
    ifdef'd out _dump(-) as it wasn't being used and was unsafe.
    more cleanup of lock_queue_entry_t:
      added documentation of how field access is supposed to be protected
      Added // UNSAFE's to accesses breaking the rules
    
    fixed so no warnings about unused parameters
    cleaning up lock_queue_entry_t:
      fixed access control to not be public for changeable fields
      changed fields that are initialized at constructor time and never
        changed thereafter to references
      no longer passing in pointers to others that are always NULL in practice
      changes elsewhere are simplest consequences of these changes
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed page_prev_lsn adjustment in logarchive_writer
    
    - Input data should not be modified, otherwise mmap will not work
    Fixed & optimized log archive with bucket size 1
    
    - Using buckets of size 1 yields 100% lookup accuracy without Bloom
    filters, and index blocks still use less than 0.5% of the run size.
    Fixed several bugs on log archiving
    
    - Run merging now works properly, with the correct initialization of the
    index and correct definition of runLSN  boundaries, taking into account
    the different levels and the potential absence of runs in a certain
    level.
    Added maxPID filter to log archive runs
    Decoupled BlockAssembly from log_core with compression option
    Fixed bug on page image compression
    Stats to keep track of page-img compression & small fix
    
    - Stats will help us evaluate exactly how much space is saved (or
    perhaps even wasted with page-image compression)
    - Log volume counter on page CB should be reset before and after
    generating page image.
    Applying page-image compression in BlockAssembly
    
    - When seeing a page_img_format log record, all previously seen log
    records of that same page (in the current block being assembled) are
    dropped and the prev. LSN pointer is set accordingly.
    Fixed archive index deadlocks
    Unified classes ArchiveIndex and ArchiveDirectory
    Fixed archive merging and implemented merger daemon
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Restart log analysis using LogConsumer instead of xct_i
    Fixed log archiver shutdown
    
    - Reader thread now uses worker_thread
    - Shutting down consumer first so that we can exit before current log
    archive activation loop finishes
    Updated ReaderThread to derive log_worker_thread_t
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    common cleanup: removed some unused files
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 1
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    RAW-style lock manager
    Addressed code review feedback on 78
    Private lock hashtable to quickly check if the lock is already taken
    Added comments
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    new function, lock_m::give_permission_to_violate, that a transaction may
    use to give permission to other transactions to violate its locks.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Fixed fuzzy checkpoints and added assertions
    Fuzzy chkpt fix: ignoring read-only transactions
    Brought back traditional fuzzy checkpoints
    Detecting warmup based on hit ratio & other updates
    Implemented undo progress and fixed restore progress
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Bugfix: TID assignment was not thread-safe
    Removed logrec category field
    
    - Category can be derived statically from type, so I removed the field
    in the logrec header and converted get_logrec_cat into a constexpr
    function. The logrec_t::cat() function now calls it using the _type
    field.
    - Removed the undoable_clr stuff, which seemed to be some deprecated
    stuff from old Shore times.
    - Left the byte in the logrec header to tell if logrec is a CLR. I.e.,
    the t_cpsn category flag was the only one that could change at runtime.
    Ideally, it would also not be needed if there is a dedicated CLR logrec
    type which just points to the LSN being undone.
    Changed signature of xct_t::cleanup
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Cleaning up some compiler warnings
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed w_stream stuff
    Made tid_t a simple uint instead of its own class
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Removed xct thread attachment business
    
    - Every xct can only be run by one thread -- it has been like that for a
    long time, but the code to support multiple threads was still there
    Removed 1thread mutex and xct dependency list
    Removed old&unused xct_log_t
    Moved log record buffer from xct_t into smthread_t::tcb_t
    Got rid of old "plog" stuff
    Moved some logging logic from xct_t to XctLogger
    Replaced log "stub" calls with generic Logger
    New templated function to replace log "stubs"
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Updated & fixed some tests
    Added latency measurements to transaction commit
    Page eviction must acquire EX latch on parent
    Added assertion to existing bug
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Fixed log fetch to only support LSNs up to durable_lsn
    Removed class ErrLog and replaced its uses with std::cerr
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed auto_delete stuff
    Removed all uses of w_list_t outside sthread_t
    Removed old FUNC macro
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Temporary fix for xct_t latching/memory leak problem
    
    - See GitHub issue #21
    Add xct assertions to help catch bugs
    
    See Issue #11
    Fixed bug on btree split log record
    
    In order for page LSNs to be updated correctly, the constructor stub in
    logdef.dat must have its first two parameters named exactly "page" and
    "page" (weird, old Shore stuff...)
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed flag SM_LEVEL
    Removed SM level 1
    Removed SM level 2
    Removed SM level 3
    Removed SM level 4
    
    This begins a series of commits in which I'll attempt to remove the
    concept of "SM levels". The goal is to have independent components (bf,
    log, lock, io, etc.) which can be constructed independently, and a much
    "thiner" ss_m which simply orchestrates the components and delegates API
    calls to them.
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Made vid_t a simple typedef and deleted volid_t
    Fixed behavior of SSX object by W_COERCEing abort
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Separated commit processing of plog_xct_t and xct_t
    Fixed some compiler warnings
    Decoupled Aether methods in log_core to enable atomic commit protocol
    Fixed allocation of xct log buffer in plog
    New generic allocation mechanism for xct_t and related classes
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Implemented basic extensibility of xct for private logs
    Removed references to LOG_BUFFER switch in xct.cpp
    Work around a bug in Single Page Recovery, which did not handle log record 'comment'.
    Log refactoring: moved common code of log_core and logbuf_core into
    abstract parent class log_common
    Log refactoring: pulled log reservation logic into class log_resv
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Log refactoring: made log_core and logbuf_core implementations of log_m
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    switch to the new log buffer
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Changed 'doomed' to 'loser'
    Renamed from 'doomed' to 'loser' transaction.
    Bug #182 is working correctly now, enable the test case in test_restart_bugs.
    Several bug fixes for 'Instant Restart' milestone 2.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Modifications based on Goetz's code review comments, also initial test plan.
    More bug fixes, all existing crahs and restart test cases (27 of them) are passing now.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    RAW-style lock manager
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    bug fix
    log_page_evict to update parent page LSN without EX latch
    [Transaction classes] Allow consecutive SSXs to chain
    SSX chaining
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    moved module comments
    SPR dumping feature, new testcase, and bug fix
    Added SPR APIs
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    renamed w_okvl to ovkl_mode
    merge remnant
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Fixed build break
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    un-inlining functions in page_bf_inline.h
    Many small changes to eliminate compiler warnings. Work-in-progress.
    generic_page_h -> fixable_page_h
    Make sure everything compiles in debug mode.
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    page_p -> generic_page_h
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    In preparation for adding _page_prv, added "xct" to:
          logrec.h:    lsn_t               _xct_prv;
          logrec.h:logrec_t::xct_prev() const
          logrec.h:logrec_t::set_xct_prev(const lsn_t &lsn)
          log.h:    bool xct_next(lsn_t& lsn, logrec_t*& r);
    Updated references to tickets to give ticket name and both jira and trac numbers.
    Remove indirection through atomic_templates.h
    pretty much finished implementation of controlled lock violation except
    for one issue with the handling of abort.
    
    Modified test_elr to run the analogous tests with controlled lock
    violation mode.  Sharpened the tests to work somewhat better and fixed a
    bug where the tests assumed different tuples in the same page cause lock
    conflict.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Fixed default value of group commit timer
    Implemented log analysis with mmap (direct fetch)
    
    - also downgraded log_core assertions
    Fixed deletion of log_core fetch buffer
    Added direct I/O options for log archive and log
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Fixed group commit
    
    - Should not return from flush_daemon_work after current and old epochs
    have been updated
    Simple group commit implementation
    Implemented checkpoint-less no-db mode
    Removed most dependencies on sthread_t
    Added command to extract propagation stats from log
    
    - Propagation stats a.k.a. recovery backlog
    - Counts number of dirty pages and REDO length for each tick on the log
    Cleaned up messy calculations of partition_size
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Added stress test for Aether (carray & log buffer)
    
    - Concurrent threads generate garbage log records with a random size
    according to a normal distribution and insert them into the log
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Implemented new log read buffer for log_core::fetch
    
    - Buffers a certain number of log partitions, starting from the latest
    one backwards.
    - Asynchronous thread loads buffer in chunks of 32MB in reverse
    chronological order.
    - log_core keeps track of LSN range already buffered and get log record
    from buffers in case of a hit.
    - Since a big sequential LSN range is what is buffered, a pair of
    variables suffices and there is no need to track individual log pages
    with a hash table. Given the pattern of log reads during restart
    recovery, this mechanism is also quite effective.
    - Also moved log analysis log record inside init method, so that we
    also count the buffer initialization as startup time in the experiments.
    Moved ticker thread inside log_core class
    
    - New init() method must be called after constructor to fork it
    Implemented new truncate_log method in log_core
    
    - Log truncation is now integrated into log_core, rather than being a
    dirty hack invoked directly on log files by ss_m code
    - Acquires insertion and flush locks and creates a new empty epoch on a new
    partition. Flush daemon then automatically performs actual truncation.
    Fixed option sm_logsize
    
    - Now given in MB rather than KB
    - Removed redundant --logsize in kits
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Fixing chkpt bug eOUTOFLOGSPACE
    When inserting chkpt log records, consume_chkpt_reservation() was being called to decrement log_resv::_space_resv_for_chkpt, but this value was never being incremented. In other words, there was nothing "reserving" space for the chkpt log records to come.
    log_resv::_space_resv_for_chkpt was initialized in the contructor only and never incremented again.
    If we want to guarantee that there is enough log space to complete the checkpoint before starting it, then we must call verify_chkpt_reservation() in the beginning of the chkpt_m::take() method.
    verify_chkpt_reservation() will check if there is already enough space reserved. If not, it will try to reserve space. If it fails to reserve space, then the conclusion is that the log is full.
    Whitespace changes
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Moved lastMountLSN into log manager
    Refactored log manager to use sm_options
    
    Same thing as done for bf_tree_m on the previous commit, but now for log
    manager classes (log_core, log_common, logbuf_core). This was quite
    tricky to achieve due to the crazy dependencies in log manager
    initialization and the complete lack of reuse in logbuf_core.
    Removed unused hint-based log fetch
    
    Hint-based log fetches were part of Yupu's work on the buffered log
    manager (see logbuf_core.h), which he was not able to finish due to new
    resposibilities at HP Labs. With his permission, I have removed this
    now legacy code.
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Decoupled Aether methods in log_core to enable atomic commit protocol
    Moved SPR methods out of log_m and into restart_m
    Log refactoring: moved common code of log_core and logbuf_core into
    abstract parent class log_common
    Log refactoring: pulled log reservation logic into class log_resv
    Updated/reorganized prime methods in log manager code
    Fixed some of the bugs on logbuf_core after refactoring
    Reintroduced logbuf_core into new refactored architecture and fixed some compilation bugs
    Log refactoring: pulled out log_storage into its own class
    Log refactoring: made log_core and logbuf_core implementations of log_m
    Moved parts of log_core constructor (logdir scanning) into log_storage.cpp
    Fixed compilation bugs resulting from last merge
    Moved implementation code from log_m to log_core
    switch to the new log buffer
    Modified test code so it is easier to merge with changed code from master.
    More bug fixes for Instant Restart milestone 2.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    parameterize carray active slot count
    Addressed Mark's code review feedbacks
    subtle changes
    slight comment change
    Ported Consolidation Array
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    backup manager now called from SPR
    moved module comments
    more code comments
    SPR dumping feature, new testcase, and bug fix
    Added SPR APIs
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Zero branch from subversion rev 11038
    Various bugfixes
    New sm_stats_t -- now just an array of enums
    Removed sthread_stats
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Reimplemented global thread list for aggregating smstats
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed w_stream stuff
    Removed xct thread attachment business
    
    - Every xct can only be run by one thread -- it has been like that for a
    long time, but the code to support multiple threads was still there
    Removed 1thread mutex and xct dependency list
    Removed old&unused xct_log_t
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed named sthreads
    Removed sthread priorities
    sthread_stats is now static thread_local instead of sthread_t member
    Cleaned up CB and page header fields
    Removed old FUNC macro
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    refactoring w_rc_t
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    enable/disable statistics at runtime
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    -modified experiment select_only to switch on/off oprofile to profile code section
    -identified scalability bottlenecks in statistics collection
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Made alloc_cache constants constexpr
    Fixed ARIES restart with proper alloc & stnode logging
    Setting page tag properly for alloc pages
    Correct recovery of dirty pages in nodb mode
    Fixed alloc cache initialization
    Added option for store clustering
    
    - Also fixed metadata initialization without clustering.
    Bugfix: added sx_append_extent call to stnode cache ctor
    
    - This is needed to format the first alloc page, with pid 0
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Fixed flushing of alloc/stnode pages on sm shutdown
    alloc_cache and stnode_page read directly from vol_t
    
    ... instead of fixing page in the buffer pool. This is done so that they
    don't leave a dangling page which is never updated, read, or cleaned.
    Small fix in alloc_cache
    
    - LSN comparison in write_dirty_pages was inverted
    Implemented alloc_cache_t::write_dirty_pages
    
    - Since our alloc cache does not maintain bitmpas within page images,
    relying instead on its internal data structures, a special method is
    required to flush these pages in the page cleaner.
    - The method simply reads an old page image and replays updates on it
    with single-page recovery, but it does this only for pages which were
    actually updated since a given LSN.
    Added assertion that stnode pid is never allocated
    Fixed bug on alloc_cache
    
    - Alloc page of the given pid in alloc and dealloc SSXs was being
    calcullated wrong, to that per-page chain was not correctly maintained.
    - Small fixes in bf_tree_cleaner
    Fixed get_page_lsn in alloc_cache_t
    
    - It should use iterator for search instead of [], which adds inexisting
    elements to the map
    Fixing bf_tree_cleaner not flushing alloc and stnode
    
    force_volume() explicitly reads this pages from disk, triggering single page recovery, and then writes them back.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Bugfix: properly loading alloc pages in alloc_cache
    
    - Flag loaded_extents[ext] must only be set after actually loading the
    page, otherwise the page is simply fixed and unfixed without any loading
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed unused vol field from alloc_cache
    
    - Volume was only used in a single assertion, so it was not required as
    a member variable. Data is accessed indirectly through bf_fixed, which
    also supports a null volume, as long as no flushes are performed (i.e.,
    read-only mode). This is possible because the constructor directly takes
    a file descriptor as parameter.
    - This functionality was implemented to extend the dbinspect command of
    zapps with allocation information. We basically need to load the
    alloc_cache of aa volume without creating or mounting a vol_t object.
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    Added comments and error messages to alloc_cache_t
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Made vid_t a simple typedef and deleted volid_t
    Fixed usage of debug macros
    Enabled concurrent transaction page loading of in_doubt page, this is for on-demand REDO operation where the user transaction triggers REDO operation in M3, no blocking.
    The M2 behavior was that user transaction is not allowed to load in_doubt page and an error was raised to rollback the user transaction.
    complex testcases for SPR and bug fixes
    3 binaries for swizzling experiments
    refactoring w_rc_t
    Many small changes to eliminate compiler warnings. Work-in-progress.
    accessors from fixable_page_h to generic_page_h
    changes from code review
    page_s -> generic_page
    stnode_p -> stnode_page_h
    alloc_p-> alloc_page_h
    renamed:    src/sm/alloc_p.h -> src/sm/alloc_page.h
    alloc_p's _page member is now private
    all members of alloc_page are now private
    workin on pulling secrets of bitmap allocation into alloc_page class
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Decoupled cleaner optimization with page-img log records
    Proper attempt count and cleaner wakeups during eviction
    Logging duration of eviction calls into a file
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Various restart fixes
    Fixed deletion of log_core fetch buffer
    Implemented run filtering based on maxPID
    Added stat la_wasted_read
    Various bugfixes
    Removed perl script that generated stats
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Removed htab stats
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed old bf_m code
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Cleaned up CB and page header fields
    Added operator<< into generic_page (for debugging)
    complex testcases for SPR and bug fixes
    adjust for moved checksum field
    calculate checksum function is no longer inline
    Made alloc_cache constants constexpr
    Implemented page-img compression for non-btree pages
    Fixed ARIES restart with proper alloc & stnode logging
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Little refactoring in chkpt_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Simplified vhdr and peristent vol metadata mgmt
    
    - Volume header only has to contain vid and total number of pages; all
    other fields were not necessary.
    
    - Isolated logic to write metadata pges (incl. volume header) so that it
    can be reused for taking backups.
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    complex testcases for SPR and bug fixes
    define bitmapsize as a constant and use the constant directly instead of sizeof. avoids errors with old compilers that don't like mixing const with non-const
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    renamed:    src/common/FairRWLatch.hpp -> src/common/FairRWLatch.h
    converting to BOOST_STATIC_ASSERT
    changes from Alistair review feedback
    new class generic_page_h that is the superclass of all page handle classes
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    adding/updating comments to src/sm/stnode_page.h
    added missing includes to sm_base.h
    changes from code review
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    stnode now using generic_page_header
    alloc_p-> alloc_page_h
    renamed:    src/sm/alloc_p.h -> src/sm/alloc_page.h
    improved documentation and removed two not used functions
    alloc_p now has two constructors, one which formats a new page and one
    which takes an existing page
    alloc_p's _page member is now private
    all members of alloc_page are now private
    pulled in implementation of bitmap into alloc_page class.
    workin on pulling secrets of bitmap allocation into alloc_page class
    alloc_page now has actual fields rather than generic data array
    initial creation of alloc_page class
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    Trying again to re-commit Alistair's fix from last October.
    three tests fail:  39 test_btree_merge, 45 test_crash, 52 test_insert_many
    Bugfix: incorrect calculation of number of pages in bitmap in alloc_p
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Added comment on a weird line of code
    Added small assertion
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Removed 'undo' parameter from B-tree methods
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Replaced occurrences of "shpid" with "pid"
    
    - Also renamed _fix_nonswizzled to fix, in preparation for next steps
    bringing back swizzling
    Removed old FUNC macro
    Fixed some restart bugs & general clean-up
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Added store number parameter to B-tree locking
    
    Since store number is not available in the page ID anymore, all B-tree
    locking methods (e.g., _ux_lock_key) must include the store number as
    an additional parameter.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Replaced all occurrences of volid+snum with stid_t
    Fixed an infinite loop bug, also update the 'known issues' list in Recovery.docx to track the I/O layer issues discovered by Caetano.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Do set reset first_lsn in a loser transaction so it can be picked up by checkpoint.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Added debug output.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Review Request 75: [B-tree search] Getting rid of unnecessary normalize_shpid in B-tree traverse to get 3% speedup in TPCC
    code formatting only
    replaced dat_leaf[_ref]
    updated comments for search_node
    fixed a couple of uses of search_node to better use new orthogonal interface
    new_search->search, replace search_leaf with search
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Fixed double-traverse-on-contention performance bug.  25% improvement for
    high-contention insert workload, both swizzled and non.
    
    Put mixed_multi_skewness back the way I found it too.
    Small refactor of search to clean it up and improve readability.
    
    Changes to scripts ought be reveresed, likely.
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Added pinned_for_restore field to bf_tree_cb_t
    Added small useful functions to bf_tree and fixable_page_h
    Fixed assertions that fail with new restore
    Fixed assertions that fail sometimes
    Added checks for page tag value in fix operations
    Various fixes to traditional ARIES restart
    Correct recovery of dirty pages in nodb mode
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Cleaning up some compiler warnings
    Removed deprecated page deletion stuff
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Replaced log "stub" calls with generic Logger
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    bf_tree cleanup: removed unused methods and flags
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Cleaned up CB and page header fields
    Removed legacy LATCH_Q mode
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Fixed bug with overflow on partition_t and some cleanup
    
    - File offset must be 64 bits
    - Added assertions to restart REDO
    - Cleaned up some restart code
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Basis for new eviction algorithm
    
    - Gave up on "hierarchical traversal" idea because it is simply broken.
    A B-tree cannot be properly traversed without acquiring latches --
    otherwise we could apply the same latch-free mechanism of eviction to
    normal traversals! I was getting all kinds of inconsistencies, and tried
    to fix them for a while, but the mechanism will always be unreliable.
    - New approach simply sweeps through the control blocks sequentially and
    tries to latch a page and its parent (in reverse order). If the latching
    succeeds (done conditionally) and the page is a leaf, then it is
    selected for eviction.
    - In terms of locality and hit ratio, we don't expect this to work
    better than LRU or clock, but it should still be better than random.
    - This approach is still not really working, because parent pointer is
    hard to maintain, and so we quickly come to the situation where all
    pages in buffer are unavailable for replacement.
    - New approach comming in the next commits!
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Reverted method fixable_page_h::setup_for_restore
    
    Previous implementation would initialize page with metadata from the log
    record, but this should not be required, because correct log replay must
    guarantee that the page state is compatible to what each log record
    expects. Method now only sets the page pointer (_pp) of the handle.
    Updated setup_for_restore on fixable_page_h
    
    Passing whole log record to setup_for_restore in order to initialize
    all attributes of the page correctly.
    
    NOTE: This shouldn't actually be necessary, since the page state should
    have been already correct from previous redo operations. Even in the
    backup-less case, proper formatting and initialization should ensure the
    correct state. This hack was required to work with B-tree splits and
    merges, but it still seems to be broken. This commit may get removed in
    the future, once I understand initialization and splits/merges better.
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Updated handling of CLSN field of pages
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Some cleanup and also enable some M4 mix mode code path.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Initial Recovery milestone 2 design doc (still work-in-progress), plus a few minor changes in code.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Incremental check-in for the work in Checkpoint and Log Analysis.
    hierarchical eviction in bufferpool
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    changed fixable_page_h to use a separate _bufferpool_managed flag
    instead of using the convention that _mode = NL for non-buffer pool
    managed pages; this allows us to use latching mode EX with non-buffer
    pool managed pages.
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    fixing up comments, related assertions
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    crabbing from Q is now handled by fixable_page_t correctly
    removed unnecessary quick check that page was correct as crabbing will
    detect any problems
    changed upgrade_latch_conditional to allow upgrading from Q to S/X
    new test subcases for Q->{SH,EX} crabbing, which do not pass yet
    added code to test for valid Q to Q crabbing + new subtest for it
    (failing); uses new error code: ePARENTLATCHQFAIL
    new test for checking fixing non-root pages with Q; so far only simple
    test without interference
    pass back success state via ticket rather than separate boolean for bf_tree_m::fix_with_Q_nonroot
    new function, change possible after fix
    Added subtest cases to check that it works; currently failing as expected
    (no QSX latch yet)
    added basic Q ticket plumbing
    added simplest possible subtest: fixing the root page with Q
    added code to unfix to deal with Q mode
    added a temporary static global variable for using Q mode instead of S mode
    fix_nonroot now returns a reasonable error code rather than giving
    assertion failure on Q failure
    made rest of routines do reasonable things with pages in Q mode
    added a new error code for Q mode failing
    re-flowed some comments to use new line limit
    made fix routines handle Q mode
    initial handling of Q mode by fixable_page_h::fix_nonroot
    added a new latch mode, Q
    changed code of fixable_page_h::fix_root to handle it for now
    many places need tests/code to handle new mode not yet done
    cleaning up interface needed for swizzling
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    delete_slot -> delete_item
    pulled out btree_page_h class
    replaced sinome used of casting
    minor code cleanup
    un-inlining functions in page_bf_inline.h
    cleaned up documentation of assignment operator for fixable_page_h
    move last of buffer manager's direct dependence on btree_page_h
    introduced use of child slot indirection layer
    still have a few level()'s to remove/deal with
    Beginning to install child slot interface between fixable_page_h and the
    buffer manager
    Fixing includes
    changes from Alistair review feedback
    moved down two B-tree fields
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    generic_page_h -> fixable_page_h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
    page_p -> generic_page_h
    removed pragma interface/implementation
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed termination order of chkpt and recovery
    Implemented alternative log fetches using mmap
    
    - They perform much better, without the need for log fetch buffers
    Chkpt using new block-wise BackwardLogScanner
    Fixed compilation of tests
    Goodbye fileoff_t!
    Added best-effort partition recycling mechanism
    
    - Support for sm_log_max_partitions options, which limits the number of
    partition files in the log directory. At each partition creation, old
    partitions are deleted proactively. If the limit is reached, a forced
    deletion is attempted, but it only works if the min active LSN collected
    on the last checkpoint allow it -- hence the best-effort approach.
    - A true recycling mechanism is only possible with log reservations,
    which we removed because they were messy and not fully effective
    (required "fudge factors").
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Refactoring partition_t & removed peek function
    
    - Peek is only necessary to determine the position of the skip log
      record, but it was too cumbersome. The only use of knowing this
      position (i.e., the partition size) is to determine the last LSN in a
      partition for a backward log scan. For now, we disabled it, but a
      better way to achieve that must be implemented
    - Simplified partition_t object by removing many unnecessary fields and
      methods.
    - prime() method of log_storage also reuses partition_t::read
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Removed unused class logbuf_core and associated files
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Updated/reorganized prime methods in log manager code
    Implemented/fixed backward log scan on log_core
    Reintroduced logbuf_core into new refactored architecture and fixed some compilation bugs
    Log refactoring: pulled out log_storage into its own class
    switch to the new log buffer
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    added new --artificial-delay argument to tpcb_elr
    Added an optional artificial delay after the log is flushed (default zero)
    fixed test_intent_lock so retries when gets a timeout
    Zero branch from subversion rev 11038
    Implemented log analysis with mmap (direct fetch)
    
    - also downgraded log_core assertions
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Fixed adding backups
    Fixed log archiver and consumer
    
    - Archiver should join after consumer adn before block assembler
    - Consumer's next method should call nextBlock on demand
    Fixed log archiver shutdown
    
    - Reader thread now uses worker_thread
    - Shutting down consumer first so that we can exit before current log
    archive activation loop finishes
    Updated ReaderThread to derive log_worker_thread_t
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved latches to sm and fixed test compilation
    Small updates on latch_t (debugging)
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed legacy LATCH_Q mode
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    changed upgrade_latch_conditional to allow upgrading from Q to S/X
    added basic Q ticket plumbing
    added a new latch mode, Q
    changed code of fixable_page_h::fix_root to handle it for now
    many places need tests/code to handle new mode not yet done
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Moved latches to sm and fixed test compilation
    Removed sthread_stats
    Commented destruction of global TLS latch_t structures
    
    - Even though this code was copied from the old sthread_t, it does not
    make sense to me to destroy global static structures when deleting one
    single instance of a thread object
    Small updates on latch_t (debugging)
    Removed w_stream stuff
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed legacy LATCH_Q mode
    Removed old FUNC macro
    Uncommented important assertions in latch_t
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    added a new latch mode, Q
    changed code of fixable_page_h::fix_root to handle it for now
    many places need tests/code to handle new mode not yet done
    refactoring w_rc_t
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    Convert arithmetic atomics from legacy to lintel::Atomic
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed old restore usage in vol_t
    evict_page logrec now has ppage LSN at time of eviction
    Commented assertions that fail with page-img logrecs
    Propstats now keeps track of static-store pages
    Added fetch_page log records for debugging
    Updated logrec output operator
    Logging page evictions for debug
    Renamed logrec type page_evict to update_emlsn
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Implemented page-img compression for non-btree pages
    Fixed ARIES restart with proper alloc & stnode logging
    Fixed log partition recycling with fuzzy checkpoints
    Fuzzy chkpt fix: ignoring read-only transactions
    Detecting warmup based on hit ratio & other updates
    Fixed adding backups
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    Little hack to temporarily fix alloc_page redo
    Compressing btree split logrecs when archiving
    
    - Instead of simply duplicating the logrec on both pids involved, we
    eliminate the redundant information for each pid.
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Fixed use of restore_segment_log
    
    - Logrec is t_system, so we must use log_sys method
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Removed logrec category field
    
    - Category can be derived statically from type, so I removed the field
    in the logrec header and converted get_logrec_cat into a constexpr
    function. The logrec_t::cat() function now calls it using the _type
    field.
    - Removed the undoable_clr stuff, which seemed to be some deprecated
    stuff from old Shore times.
    - Left the byte in the logrec header to tell if logrec is a CLR. I.e.,
    the t_cpsn category flag was the only one that could change at runtime.
    Ideally, it would also not be needed if there is a dedicated CLR logrec
    type which just points to the LSN being undone.
    Removed t_rollback flag from log records
    
    - It didn't seem to be used for anything at all
    Updated stnode_cache_t to use normal page fix
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    Removed generated files used in logrec switch statements
    Properly logging initialization of stnode_cache
    
    - Log record must be generated when an empty stnode cache is created in
    order to format the stnode page correctly.
    - This fixes some related bugs in some unit tests.
    Fixed logrec TID assignment transaction rollback
    
    - Critical bug introduced with new XctLogger
    Cleaning up some compiler warnings
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed log_spr.{h,cpp}
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Removed deprecated page deletion stuff
    Removed method logrec_t::fill
    Moved logrec header initialization out of constructors
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Bugfix: properly constructing logrecs with type and cat fields
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Got rid of old "plog" stuff
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Small bugfix on restore logrecs
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Fixed restore_segment log record
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Added latency measurements to transaction commit
    Renamed macro 'align' to avoid naming conflict with C++11's std::align.
    Updated application tools: kits, propstats, and stress_cleaner
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed deprecated store ID on chkpt_buf_tab
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Removed old FUNC macro
    Added timers to ss_m constructor for each phase of the initialization
    
    - Also commented out some verbose outputs in restart
    Small bugfix in dealloc_page log record
    
    - PID of correspongding alloc page was not being saved in log record
    Added restart event log records for debugging and experiments
    
    - Log events for begin and end og log analysis, end of REDO, and end of
    UNDO.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Clean-up of the log analysis mechanism [part 2]
    
    - Simplified and fixed behavior of functions used to mark tx as active
    and page as dirty. The logic assumes a backward scan only.
    - Simplified the logic of processing bf, xct, and lock tables, so that
    the methods could be removed and the code inlined in the big log scan
    loop.
    - Removed some unnecessary stuff (e.g., undo_nxt in tx table)
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Changing constructors of chkpt dev and backup table
    Modified these constructors so they match the pattern followed by the other contructors.
    Fixing bug in read_devnames().
    Append new line to break between the string paths when inserting them in the stringstream.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed restore activation and finishing
    
    - LA activation not invoked properly without eager archiving
    - Logging of restore_segment moved to restore.cpp
    - Removed redo argument from check_restore_finished (TODO)
    Assorted fixes and cleanups
    
    - Fixed doMerge function to process whole input archive
    - Deleted old code
    - Added W_DO to mount redo
    Fixed valid_header test in logrec_t
    
    - In principle, a log record's size can be as little as its header
    (class baseLogHeader), which is the case, e.g., for the skip log record
    at the end of log archive runs.
    Fixed undefined reference on logrec_t::type_str()
    
    - Inline methods must be on header file.
    Added logrec fill method with just page ID as parameter
    
    - Useful for operations such as alloc_a_page, which do not actually use
    a fixed page image, but still refer to a page id.
    - Currently, only volume is set, but in the future, once we fix the
    metadata recovery stuff, the ID of the affected alloc page should be
    used.
    Proper valid_header check for log records
    
    - Type number actually checked to be within the allowed values instead
    of "random" number 100.
    - Also checking if length is within the maximum limit.
    Small improvements to debug features
    
    - Added shorter macros DBG1, DBG3, and DBG5
    - Added some info when printing out checkpoint log records
    - Tweaked CMake options for debug
    Added stat restore_log_volume
    
    - Counts the total log volume (in bytes) which was processed by a
    restore log replay, including skipped log records.
    - The goal is to compare this to the numer of log blocks read. Ideally,
    the latter (multiplied by the block size) should not be much greater
    than the former.
    Fixed bug on backup tab serialization
    
    - Deserializing strings using the >> operator requires each string to
    be followed by a newline character
    - Structures such as the chkpt_backup_tab_t must be aligned, otherwise
    their sizeof does not match the sum of their components' sizeof. This I
    learned recently from Stroutroup's book and luckily I realized that when
    debugging this.
    Added info about allocation log records to output operator
    Fixed bug with page_evict log records
    
    - Data was being stored in the normal data region of the log record.
    However, since page_evict is an SSX log record, it should be stored in
    the SSX data region (`data_ssx()`)
    Moved definition of sysevent epoch to its own cpp file
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Added timed log records and stubs for sysevent
    
    - Helper class sysevent_timer created to generate timestamps as the
    number of milliseconds since an epoch (Jan 1, 2015)
    
    - TIMED_LOG_RECORDS added as configuration flag. Log records for which a
    timestamp is desired must then observe this flag. Currently being used
    by restore log records.
    
    - Basic stubs created for log record of type sysevent. At first, only
    tick log record will be implemented as a sysevent.
    Fixed bug on btree split log record
    
    - Prev pointers were switched (prev2 pointing to previous update on
    page1 and vice-versa). Fixed constructor method and its invocaiton to
    produce the correct assignment.
    
    - Aldo fixed log archiver to correctly set previous pointer on
    duplicated multi-page logrec.
    Added static get_type_str() to logrec_t
    
    - Allows getting the name of a given kind_t value.
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    Implemented checkpoint and restart for vol backups
    
    Added a chkpt_backup_tab log record, similar to chkpt_dev_tab. It keeps
    track of the paths for the backup files of each volume. During restart,
    the log records are simply replayed. Since we don't have delete_backup
    operations so far, there is no need to replay them in reverse order, as
    done for mounts/dismounts.
    
    (Untested)
    New (logged) sx_add_backup operation for volumes
    
    A volume now contains a list of FS paths to be used as backup files.
    These can be added with the vol_m::sx_add_backup method. The operation
    is part of persistent system state and thus it must be logged,
    checkpointed, and recovered. Logging and recovery are done,
    chekpointing will come next.
    Basic logging and recovery functionality for restore
    
    Implemented log records and their generations as SSX, their REDO
    operations, and required methods in vol_t and RestoreManager.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Small fixes on restore code
    
    - After redo, adjust page fields such as LSN and checksum
    - Correctly set store parameter on store_operation log records (not
    required for now, but it could lead to bugs later)
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    Fixed logging of volume operations
    
    Format volume operation is now properly logged and redone, and SSX
    behavior of other sx_* methods in vol_m was also fixed. Still need to
    implement logging for dismount_all though. Testing recovery fo volume
    operations is also to be done soon.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Implemented logging and recovery of volume ops
    
    Added logrecs with proper REDO and SSX for create, mount, and dismount
    of volumes. Recovery works by simply invoking redo() on them, including
    chkpt_dev_tab_log.
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Added store number to logrec header
    
    Same idea as in page header: operations that need the store number must
    get it from an extra header field.
    
    Also updated the fill() method and added other fill() variants for
    convenience.
    Fixed REDO of store operations
    
    Store operations always generated log records, which is wrong in case of
    a REDO step. Updated the interface across all classes to include a
    "redo" boolean flag. If set to true, no log record is generated.
    Fixed logging of store operations
    
    The log record store_operation_log was basically broken because it did
    not include a volume ID (i.e., its page ID was always null). This causes
    any undo/redo operation to fail, because it uses 0 as a volume ID.
    Changed valid_header() to accept lsn_t::null as parameter.
    New generic allocation mechanism for xct_t and related classes
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Modified test code so it is easier to merge with changed code from master.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    bugfix
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    moved module comments
    SPR dumping feature, new testcase, and bug fix
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    refactoring w_rc_t
    Conversion of more w_asserts to use if (false) when disabled.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    introduced unused_part call to pull representation details out of
    page_img_format_log
    btree_page[_header] no longer all public
    delete_slot -> delete_item
    un-inlining functions in page_bf_inline.h
    cleanup includes, friends
    comment sections
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    changes from Alistair review feedback
    generic_page_h -> fixable_page_h
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    page_p -> generic_page_h
    adding/updating comments to src/sm/stnode_page.h
    removed unused t_store_freeing_exts state of store_deleting_t enum
    page_s -> generic_page
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    In preparation for adding _page_prv, added "xct" to:
          logrec.h:    lsn_t               _xct_prv;
          logrec.h:logrec_t::xct_prev() const
          logrec.h:logrec_t::set_xct_prev(const lsn_t &lsn)
          log.h:    bool xct_next(lsn_t& lsn, logrec_t*& r);
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Fixed some restart bugs & general clean-up
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed btree growth to free page if it fails
    
    - A Btree growth (i.e., creation of a new root) may fail because
    multiple threads can race and only one wins. In that case, the page
    initially allocated must be freed with an SSX.
    Properly setting parent pointer on btree operations
    
    - Any operation that changes the parent of a note (adoption, split, and
    growth) must update the hashtable to reflect the changes. Otherwise, the
    eviction algorithm cannot find parents and therefore cannot evict.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Fixed usage of debug macros
    indentation
    added a new_lsn argument to format_steal (previously it kept whatever the
    page's LSN previously was)
    removed init_fix_steal function in favor of calling fixed then format
    (we are separating fixing from formatting for more needed flexibility)
    merge with bufferpool change
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    changes from Alistair review feedback
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    stnode_p -> stnode_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Decoupled cleaner is back!
    Added pinned_for_restore field to bf_tree_cb_t
    Fixed initialization of control blocks
    Updated use of refcount in page cleaner
    
    - Refcount is reset to zero after cleaning
    Fixed deadlocks resulting from cleaner actions
    Fixed control block initialization and race conditions
    New mechanism to compute rec_lsn, got rid of clean_lsn
    Fixed CB pinning and concurrency operations for checkpoints
    Bugfix on cleaner policies
    
    - Comparison function used in heap operations was wrong
    - Now using rec_lsn in oldest_lsn policy -- makes more sense than
    using clean_lsn
    Fixed fuzzy checkpoints and added assertions
    Fixed CB pinning and its use in cleaner and eviction
    Added rec_lsn back into bf_tree_cb
    Correct recovery of dirty pages in nodb mode
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Removing #define BP_ALTERNATE_CB_LATCH
    
    Alternate control blocks and latches in the bufferpool is now the one and only
    behavior supported by Zero. We are not supporting older layout anymore.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 1]
    
    - Unswizzling for eviction currently not implemented
    - First attempt -- not tested yet
    Added ref_count_ex on bf_tree_cb to count only X-latch acquires
    
    - Also see comment on bf_tree.h: we should reuse the mechanism in
    latch_t to count references and get rid of counters in the control block
    Cleaner refactoring IV: policy infrastructure
    
    - Added functionality to parametrize candidate selection in the cleaner
    according to a policy, which so far includes a type (enum class
    cleaner_policy) and a number of candidates to select (num_candidates)
    Cleaned up CB and page header fields
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed support for careful write ordering
    
    ... which never really worked and breaks instant restore, so we don't
    really need it.
    Removed unused and unecessary header files
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed pin mechanism and latching on fix calls
    
    - Updated bf_tree_cb_t interface to have a simple pair of pin/unpin
    methods, which perform atomic increment/decrement.
    - My last change to the pin mechanism introduced a stupid (but painful
    to debug) bug in which threads with an SH latch would update the pin
    count in a non-atomic manner, which obviously causes races.
    - Fixed the various fix methods of the buffer pool to latch pages
    correctly and only update the control block once latch is successfully
    acquired.
    - Hopefully, the buffer pool is thread safe now.
    Made vid_t a simple typedef and deleted volid_t
    Updated handling of CLSN field of pages
    Added uncommitted counter to bf_tree_cb
    Modified test code so it is easier to merge with changed code from master.
    More bug fixes for Instant Restart milestone 2.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Incremental check-in for the work in Checkpoint and Log Analysis.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    added placeholders for what is guarding each field
    line wrapped comments
    added comments to describe when we increment refbit_approximate and counter_approximate
    fixed incorrect uses of lock instead of latch
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Bufferpool keeps track the number of swizzled pointers per inner node. If an inner node has no swizzled pointers then its a candidate for replacement. This is useful when the bufferpool runs low in memory. Also we have seen a case where cold inner nodes touched by a burst stay in the bufferpool and cause hot data pages to be evicted instead.
    Addressed issues raised in review request 10:
    -added comment explaining why we have the new layout
    -fixed the blockcnt + 1
    -made maximum value of refcount a parameter
    Encapsulated access to control block table and latches behind buffer pool API. This gives us flexibility in implementing layout of control blocks and latches without having to make drastic code changes. I implemented a new allocation scheme that alternates control blocks and latches in this fashion: |CB0|L0|L1|CB1|CB2|L2|L3|...
    This schme helps removing a pathology that I believe is related to the L2 spatial prefetcher. See Jira Issue 119
    Macro flag to enable/disable inner-node page replacement
    Improved method from the code review.
    It seems like the '1' was an error, and should have been "val".
    This is part of Issue 137, "Eliminate all compiler warnings".
    Partial commit of changes necessary to remove volatile modifiers. See https://jira.hpl.hp.com/browse/ZERO-116
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    bunch of scripts to run swizzling experiments; some swizzling bug fixes: hierarchical clock didn't take refcount into account when selecting pages to unswizzle
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    Added a macro parameter to control whether to enable increment/decrement of page pincnt
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Deleted old ArchiveScanner
    Replaced uses of ArchiveScanner with new ArchiveScan
    Multi-segment restore + using backupLSN as log replay bound
    Some fixes to ArchiveScan
    Bugfix: SprIterator initialization without log archive
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Initial support for mmap as a new MmapRunScanner
    
    - Relies on the same RunFile infrastructure as RunScanner
    - Not being used for now because RunMerger always uses RunScanner
    - Future commit should add template argument to RunMerger
    - Leaving it like this for now because performance was worse with mmap
    Extended log archve to use RunFile struct
    
    ... instead of file descriptors
    - This will facilitate the mmap implementation coming soon
    Removed readSize parameter from ArchiveScanner::open
    Added stat la_wasted_read
    Fixed bug with incorrect log archive read size
    Updated ReaderThread to derive log_worker_thread_t
    Updated stats for log archive and restore
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Using shared_ptr to manage archive scans
    Re-structured some code in log archive scanner
    Unified classes ArchiveIndex and ArchiveDirectory
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Fixed normal restart w/o redo
    Replaced uses of ArchiveScanner with new ArchiveScan
    Fixed write elision and decoupled cleaner
    Fixed more assertions
    Fixed assertions that fail sometimes
    Commented out assertion that fails sometimes
    Updating dirty page table during eviction in nodb mode
    Bugfix: SprIterator initialization without log archive
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Fixed checkpoint bug
    SprIterator using vector instead of list for lr_offsets
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Not calling wakeup_cleaner from restart thread
    
    - but from bf_tree instead, when setting warmup_done
    Various restart fixes
    Buffer-pool warm-up now configurable with sm options
    
    - Also starting background recovery in instant restart only after
    warm-up
    Downgraded assertions in restart code
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Kick-off cleaner only after recovery is done
    
    - Sumstantial improvement to restart times!
    Switched to thread-local, single-allocation SprIterator
    Fixed ARIES restart with proper alloc & stnode logging
    Removed readSize parameter from ArchiveScanner::open
    Various fixes to traditional ARIES restart
    Fixed deletion of log_core fetch buffer
    Fixed non-instant restart modes
    Taking checkpoint right after log analysis
    Restart thread doing undo first
    Removing dirty pages after background restart redo
    Correct recovery of dirty pages in nodb mode
    Restart log analysis using LogConsumer instead of xct_i
    Fixed adding backups
    Fixed ARIES restart
    
    - Worker thread stuck at the end because there should be only one round
    Fixed redo bookkeeping and vol_t shutdown
    Fixed redo progress
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    Replaced restart_m with restart_thread_t
    Webserver: Tracking current status of redo and log analysis.
    Using shared_ptr to manage archive scans
    Unified classes ArchiveIndex and ArchiveDirectory
    Implemented checkpoint-less no-db mode
    Added prioritize_archive option on vol_t
    
    - also deleted method restart_m::recover_single_page, since SprIterator
    is really easy to use and the method was only called from
    vol_t::read_page_verify
    Encapsulating SPR logic in new class SprIterator
    Unified construction of ArchiveDirectory and ArchiveIndex
    Fixed SPR from log archive
    
    - grow_buffer being used incorrectly
    - pid range used incorrectly in log archive scan
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Moved nested classes out of LogArchiver
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed log_spr.{h,cpp}
    Made tid_t a simple uint instead of its own class
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Moved some logging logic from xct_t to XctLogger
    Replaced log "stub" calls with generic Logger
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    Fixed log analysis bug
    
    - Because we were using is_page_update() to track dirty pages,
    compensation log records were not being processed as dirtying updates,
    causing wrong PageLSN computation.
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Added some debug msgs and assertiosn to rollback code
    
    - Hope is to fix bug of per-page chain inconsistency when using instant
    restart.
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed sm_du_stats
    Removed class ErrLog and replaced its uses with std::cerr
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Added timers to ss_m constructor for each phase of the initialization
    
    - Also commented out some verbose outputs in restart
    Implemented new log read buffer for log_core::fetch
    
    - Buffers a certain number of log partitions, starting from the latest
    one backwards.
    - Asynchronous thread loads buffer in chunks of 32MB in reverse
    chronological order.
    - log_core keeps track of LSN range already buffered and get log record
    from buffers in case of a hit.
    - Since a big sequential LSN range is what is buffered, a pair of
    variables suffices and there is no need to track individual log pages
    with a hash table. Given the pattern of log reads during restart
    recovery, this mechanism is also quite effective.
    - Also moved log analysis log record inside init method, so that we
    also count the buffer initialization as startup time in the experiments.
    Added restart event log records for debugging and experiments
    
    - Log events for begin and end og log analysis, end of REDO, and end of
    UNDO.
    Fixed bug with overflow on partition_t and some cleanup
    
    - File offset must be 64 bits
    - Added assertions to restart REDO
    - Cleaned up some restart code
    Fixed some restart bugs & general clean-up
    Cleaned up some old restart code
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Added chkpt_t test and fixed bugs found so far
    Clean-up of the log analysis mechanism [part 5]
    
    - Moved logic of backward log scanning and serialization into log
    records inside class chkpt_t.
    - Removed master_lsn and other parameters of log scan.
    Clean-up of the log analysis mechanism [part 4]
    
    - Removed lock table and integrated list of acquired locks into
    transaction table
    Clean-up of the log analysis mechanism [part 3]
    
    - Deleted old monstruous checkpoint method. Now relying solely on
    decoupled checkpoints.
    - TODO: clean-up all parts of the code that assumed a traditional
    checkpoint (e.g., concurrency control on xct table, buffer pool, etc.)
    Clean-up of the log analysis mechanism [part 2]
    
    - Simplified and fixed behavior of functions used to mark tx as active
    and page as dirty. The logic assumes a backward scan only.
    - Simplified the logic of processing bf, xct, and lock tables, so that
    the methods could be removed and the code inlined in the big log scan
    loop.
    - Removed some unnecessary stuff (e.g., undo_nxt in tx table)
    Clean-up of the log analysis mechanism [part 1]
    
    - Removed forward scan
    - Moved common logic of marking a page dirty, a transaction active,
    etc., into the chkpt_t class, making the code more modular and with less
    repetition.
    - Log analysis now has a more generic treatment of log records, without
    a lot of specific tasks executed depending on the logrec type. Actions
    such as acquiring a lock, marking a page dirty, and a transaction active
    do not depend on the logrec type -- they are executed for any logrec
    that represents an update.
    - Removed a lot of complexities and unnecessary optimizations (e.g., the
    "mapCLR" stuff)
    Cleaned up old log analysis code in restart.cpp
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Removing unnecessary calls to cleaner
    Cleaner should flush the buffer ONLY during clean shutdown. In all other occurences it should only make a meaningless request for flushing pages by waking up a cleaner thread.
    Replacing vector for map in chkpt_t
    vector is too slow for handling insert/delete operations.
    map is much faster, but we had to change the way chkpt_t is represented.
    Fixing xct_next() bug.
    The problem was that xct_next() was calling fetch(), which returns a pointer to the log record currently allocated in the log manager read buffer. xct_next() was returning the same pointer to the caller and releasing the log latch.
    If xct_next() is used isolated from other operations, this is not a problem, but if other running operations modify the log read buffer, the pointer returned might be invalid.
    The solution was to make xct_next() receive a log record buffer and make a copy to it before releasing the log latch.
    New log_analysis() method
    Uses chkpt_m::backward_scan_log().
    Inserted assertion after analysis()
    The backward log analysis outputs commit_lsn and undo_lsn. We assume these values have the same meaning. An assertion was added in order to verify such assumption in the future.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Little hack to make restore work with backups
    
    - Processing device and backup tables at once after log scan is
    completed. This allows the log records to appear in any order.
    - Currently only works for the checkpoint tables, and not for the actual
    mount and backup log records. However, this code is temporary -- proper
    checkpoint and log analysis is being implemented by Lucas.
    Fixing bug t_dealloc_a_page
    It was written t_alloc_a_page.
    Fixed log archiver and log truncation to work together
    
    - A truncated log introduces a bunch of special conditions in the log
    archiving process:
      - It must generate empty runs to account for the hole beteen the
      truncated LSN and the next partition.
      - It must tolerate empty runs.
      - It must support manually unsetting the eager flag and activating
      until an LSN larger than the current log LSN.
    
    These and other tricks were implemented to make log truncation work with
    log archiving and vice-versa.
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Fixed and simplified single-page recovery
    
    - Single-page recovery was using the log fetch buffer incorrectly.
      (Fixes issue #17)
    - Simplified collection of log records by simply copying into a (now
    automatically expanding) buffer and replaying directly from this buffer.
    This eliminates the need for a separate list of log record pointers.
    - Added some assertions to replay process.
    - Removed "actual_emlsn" parameter which was never false. If it's to be
    implemented in the future, the same condition can be simulated with
    `emlsn == lsn_t::null`
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Fixed bugs with backup handling
    
    - Removed deadlock in sx_add_backup
    - Short I/O check was wrong
    Fixed restart to recognize allocation and restore
    
    - I re-introduced page allocation log records a couple of commits back,
    but the code that processed them in restart.cpp was still commented.
    
    - Restart was not recognizing restore-related log records
    Bug fixes on restart tests.
    Implemented checkpoint and restart for vol backups
    
    Added a chkpt_backup_tab log record, similar to chkpt_dev_tab. It keeps
    track of the paths for the backup files of each volume. During restart,
    the log records are simply replayed. Since we don't have delete_backup
    operations so far, there is no need to replay them in reverse order, as
    done for mounts/dismounts.
    
    (Untested)
    Moved lastMountLSN into log manager
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Implemented logging and recovery of volume ops
    
    Added logrecs with proper REDO and SSX for create, mount, and dismount
    of volumes. Recovery works by simply invoking redo() on them, including
    chkpt_dev_tab_log.
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Added store number to chkpt_bf_tab
    
    The diorty page table saved in checkpoints needs to record the store
    number of each page separately, since it's not available in the page ID
    anymore. Also updated the log analysis method and in-doubt marking
    accordingly.
    Added store number to logrec header
    
    Same idea as in page header: operations that need the store number must
    get it from an extra header field.
    
    Also updated the fill() method and added other fill() variants for
    convenience.
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Removed unused hint-based log fetch
    
    Hint-based log fetches were part of Yupu's work on the buffered log
    manager (see logbuf_core.h), which he was not able to finish due to new
    resposibilities at HP Labs. With his permission, I have removed this
    now legacy code.
    Bug fixing, during checkpoint, if an 'used' page did not have rec_lsn (first dirty LSN), most likely the page was allocated but not formatted at this point when the checkpoint was taking, therefore nothing to recovery if system crashed after this checkpoint.  In such case do not record the page in checkpoint therefore Restart process will not mark this page as in_doubt because there is nothing to recover for an unformatted page.  If the page was formatted and updated after the checkpoint, then proper log record(s) would be generated and the page will be marked as in_doubt by Log Analysis phase accordingly.
    Bug fix in log-driven REDO, if an update log record has a corresponding page which is not marked as in_doubt, it is a valid scenario and simply ignore it.
    Temporary fix to page allocation issue (see ticket #6)
    Temporary fix for bug with REDO of clean (not in-doubt) pages (see ticket #5)
    Added some debug messages
    Added comments
    Changed performance measurement messages from DBGOUT0 to DBGOUT1 so they do not show up during functional runs
    Added comments
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Updated handling of CLSN field of pages
    Fixed xct deallocation in restart_m (compilation fails otherwise)
    Added code to forward log scan Log Analysis to delete ended transaction object from transaction table as soon as possible.  Currently forward log scan Log Analysis is not being used, all Instart Restart code are using backward log scan during Log Analysis, but the forward log scan function is being maintained for performance measurement purpose only.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Added code to forward log scan Log Analysis to delete ended transaction object from transaction table as soon as possible.  Currently forward log scan Log Analysis is not being used, all Instart Restart code are using backward log scan during Log Analysis, but the forward log scan function is being maintained for performance measurement purpose only.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Bug fixes, also addressed the test break issues in test_logbuf and test_logbuf_scan.
    Moved SPR methods out of log_m and into restart_m
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Reintroduced logbuf_core into new refactored architecture and fixed some compilation bugs
    Continue working on performance test.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed the nested log scan issue, do not nest the call to log scan iterator.
    Fixed a bug in transaction destructor (existing bug), free latch only if we had it.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    This  check-in was not planned, it was forced in order to merge changes from master.
    Added a new test file for Restart performance test, no actual test case implementation with this check-in.
    switch to the new log buffer
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Added more error output to function _collect_single_page_recovery_logs() for OOM, the goal is to capture more information when this error occurred, to help debugging in this function (which might have multiple issues).
    Fixed another bug in test code which is causing infinite loop if normal shutdown instead of crash shutdown.
    Some cleanup and also enable some M4 mix mode code path.
    Enabled child thread REDO and UNDO for mixed mode (M4)
    Added couple test cases for M3 and found out that backward log scan does not work (which was never used)
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    Added comments to function prototypes in header file, no code change.
    Clean up the restart code more for the 2nd M3 check-in, also fixed a few bugs in Log Analysis phase.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Fixed a bug in Log Analysis backward log scan, set the undo_nxt to the latest lsn since it is for rollback purpose.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Added logic in log analysis to handle possible save_point and partial rollback in in-flight transactions.
    Accepted test code merge from master and added some comments.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Do set reset first_lsn in a loser transaction so it can be picked up by checkpoint.
    Fixed a bug on normal shutdown with transaction rollback where the transaction contains a page split through full logging.
    Fixed a regression bug from implementing backward scan.
    Also changed the buffer pool flush code so it does not flush in_doubt pages.
    Implemented backward log scan, not lock acquisition and no test yet, the function is not being executed currently.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Changed 'doomed' to 'loser'
    Renamed from 'doomed' to 'loser' transaction.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Fixed bug on 'failed to generate log record' for deletion compensation (insert).
    Bug fix for Zero-183, it works in debug mode but still having issue in retail build, need more investigation.  Also Zero-183 has multiple issues, this check-in only addressed one of them.
    Multiple bug fixes, plus some prep work for page-rebalance and page-merge full logging work.
    Multiple bug fixes, also draft design doc for milestone 3.
    More bug fixes for Instant Restart milestone 2.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    Initial Recovery milestone 2 design doc (still work-in-progress), plus a few minor changes in code.
    Modifications based on Goetz's code review comments, also initial test plan.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    indentation
    Incremental check-in for the work in Checkpoint and Log Analysis.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Minor changes in checkpoint area, also added synch checkpoint to Recovery, one at the end of Log Analysis, and one at the end of UNDO phase.
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    w_assert1(-) now is if (false) {...} for lower debug levels so we still
    compile the code even then
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    un-inlining functions in page_bf_inline.h
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    accessors from fixable_page_h to generic_page_h
    generic_page_h -> fixable_page_h
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    page_p -> generic_page_h
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    In preparation for adding _page_prv, added "xct" to:
          logrec.h:    lsn_t               _xct_prv;
          logrec.h:logrec_t::xct_prev() const
          logrec.h:logrec_t::set_xct_prev(const lsn_t &lsn)
          log.h:    bool xct_next(lsn_t& lsn, logrec_t*& r);
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Lightweight propstats using chkpt data
    Fixed assertions that fail sometimes
    Updating dirty page table during eviction in nodb mode
    Chkpt considers archived LSN to compute min_rec_lsn w/o nodb mode
    Fixed use of fuzzy checkpoints with nodb
    Fixed log partition recycling with fuzzy checkpoints
    Fixed fuzzy checkpoints and added assertions
    Fuzzy chkpt fix: ignoring read-only transactions
    Taking checkpoint right after log analysis
    Brought back traditional fuzzy checkpoints
    chkpt_m now derives directly from worker_thread_t
    Optimized chkpt_t::scan_log
    
    - Replaced std::map with std::unordered_map
    - Reduced number of lookups per analyzed log record
    - Bandwidth improved 3x for in-memory log scan
    Fixed nodb checkpoints by using archived_lsn
    
    - Checkpoints now take log archive into account by not marking a page as
    dirty when the related update has an LSN below the last archived LSN.
    Updated TruncateLog command
    Correct recovery of dirty pages in nodb mode
    Fixed adding backups
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    Initializing chkpt_m correctly after log analysis (fixes #35)
    Implemented checkpoint-less no-db mode
    Little refactoring in chkpt_t
    Reverting all that chkpt_only_root_pages jazz
    Added (yet unused) option chkpt_only_root_pages
    
    - It's not as easy as I thought to keep track of root pages only in
    checkpoints, so I abandoned the project but left the option here for the
    future.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Chkpt mgr keeps track of last chkpt LSN
    
    - which allows returning a meaningful min_active_lsn() when both
    min_xct_lsn and min_rec_lsn are null.
    A bunch of bugfixes
    
    Sorry for not breaking these up into individual commits. Here's a
    summary:
    - Eviction should only process leaf pages without any foster children
    - btree_insert redo was generating log records, which resulted in
    inconsistencies in the per-page log chain (e.g., for SPR).
    - PageLSN should also be updated when page is fixed with
    fix_non_bufferpool_page (e.g., for page_evict log records)
    - Other fixes and assertions
    Chkpt serialization to file (initial code from Lucas)
    
    - Checkpoint data is now serialized to a serparate file instead of as
    embedded *_tab log records.
    Fixed semantics of chkpt_m::get_min_active_lsn
    
    - When either min_rec_lsn or min_xct_lsn are null, method
    chkpt_m::get_min_active_lsn() should take special care -- see comments
    Removed deprecated store ID on chkpt_buf_tab
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Revised checkpoint wakeup mechanism & added cached min LSN values
    
    - If negative interval is given to chkpt thread, then it waits on a
    condition variable without a timeout, and it only runs when a signal is
    recieved. Signals are also handled properly with critical sections and a
    _wakeup flag.
    - min_rec_lsn and min_xct_lsn values of the latest checkpoint are now
    cached inside chkpt_m to allow retrieval without entering the critical
    section, i.e., without waiting for a currently running checkpoint.
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Fixed silly checkpoint bug
    
    - The log scan of a decoupled checkpoint must cover the range between
    the current chkpt_begin and the last one, so that the complete history
    of log records is captured in the latest checkpoint. For that to happen,
    the system must first write out a begin log record *and then* start
    scanning. Previous code was only inserting a begin after scanning, which
    means all log records inserted during the scan were ignored. Really
    dumb.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Added chkpt_t test and fixed bugs found so far
    Clean-up of the log analysis mechanism [part 5]
    
    - Moved logic of backward log scanning and serialization into log
    records inside class chkpt_t.
    - Removed master_lsn and other parameters of log scan.
    Clean-up of the log analysis mechanism [part 4]
    
    - Removed lock table and integrated list of acquired locks into
    transaction table
    Clean-up of the log analysis mechanism [part 3]
    
    - Deleted old monstruous checkpoint method. Now relying solely on
    decoupled checkpoints.
    - TODO: clean-up all parts of the code that assumed a traditional
    checkpoint (e.g., concurrency control on xct table, buffer pool, etc.)
    Clean-up of the log analysis mechanism [part 2]
    
    - Simplified and fixed behavior of functions used to mark tx as active
    and page as dirty. The logic assumes a backward scan only.
    - Simplified the logic of processing bf, xct, and lock tables, so that
    the methods could be removed and the code inlined in the big log scan
    loop.
    - Removed some unnecessary stuff (e.g., undo_nxt in tx table)
    Clean-up of the log analysis mechanism [part 1]
    
    - Removed forward scan
    - Moved common logic of marking a page dirty, a transaction active,
    etc., into the chkpt_t class, making the code more modular and with less
    repetition.
    - Log analysis now has a more generic treatment of log records, without
    a lot of specific tasks executed depending on the logrec type. Actions
    such as acquiring a lock, marking a page dirty, and a transaction active
    do not depend on the logrec type -- they are executed for any logrec
    that represents an update.
    - Removed a lot of complexities and unnecessary optimizations (e.g., the
    "mapCLR" stuff)
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Adding checkpoint command line options
    Fixing missing typedef in chkpt.h
    For some reason, after merging with Caetano/restore, the tid_CLR_map was defined in chkpt.h anymore.
    Replacing vector for map in chkpt_t
    vector is too slow for handling insert/delete operations.
    map is much faster, but we had to change the way chkpt_t is represented.
    Adding forward_log_scan again.
    Thank you, Caetano.
    Fixing bug in chkpt_dev_tab
    Similar to the previous bug with chkpt_bf_tab. We have to consider the case where a device is listed in the chkpt_dev_tab, but it was dismounted between chkpt_begin and chkpt_dev_tab log records.
    Fixing bf_tab bug in log scan
    backward_scan_log() populates an object chkpt_t with the current server status.
    It scans the log backward, from the given lsn to the most recent completed checkpoint.
    A checkpoint has information about all log records that happened BEFORE its chkpt_begin log record.
    However, the checkpoint is currently split into multiple log records that might not be adjacent to each other.
    For this reason, when the find the chkpt_bf_tab log record, it has the pages that were in the buffer up to the point of the chkpt_begin log record.
    We have to consider the case there a page in the chkpt_bf_tab was flushed between the chkpt_begin and the chkpt_bf_tab log records.
    Removing useless parameters from chkpt methods.
    Making life simples :)
    Cleaning code and removing warnings
    Warnings related to int-uint compararissons were removed.
    Removing forward scan_log()
    Since only the backward_scan_log() acquires locks, the forward scan is useless.
    Adding checkpoint backward scan and auxiliary methods.
    This was heavily based on the log analysis backward scan method.
    The backward scan handle the acquired locks from transactions.
    Changed the chkpoint infrastructure again.
    Added utility function indexOf().
    This function is just a short for retrieving the index of a given element in a vector, if present.
    Moving includes from .cpp to .h.
    Changed the chkpoint infrastructure again.
    Adding the initial chkpt_t infrastructure.
    We are re-using existing types defined in logrec.h for the checkpoint tables.
    Empty constructors were added to these table types.
    Decoupled chkpt_m from smlevel_0
    
    Class chkpt_m does not inherit from smlevel_0 anymore. Instead, the
    required members and methods (which are all static) are accessed through
    ss_m. Similar refactoring should follow for other classes.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Zero branch from subversion rev 11038
    Removed virtual methods from archiver workspace memory manager
    Fixed mem_mgt for larger blocks
    
    - Page-img compression results in log records larger than 8192 bytes,
    which requires larger max size in the class fixed_lists_t.
    - Larger max size cause a small bug that was fixed.
    Fixed bug in archiver workspace
    
    - Memory manager msut use a buffer size which is multiple of the maximum
    block size. Otherwise neighbor calculations and coalescence will fail.
    Added destructor for archiver memory manager
    Copied log archiver files from old plog branch
    Replaced uses of ArchiveScanner with new ArchiveScan
    Fixed write elision and decoupled cleaner
    Updating dirty page table during eviction in nodb mode
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    SprIterator using vector instead of list for lr_offsets
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Switched to thread-local, single-allocation SprIterator
    Various fixes to traditional ARIES restart
    Taking checkpoint right after log analysis
    Fixed ARIES restart
    
    - Worker thread stuck at the end because there should be only one round
    Fixed redo progress
    Replaced restart_m with restart_thread_t
    Not spawning recovery thread in no-db mode
    Webserver: Tracking current status of redo and log analysis.
    Using shared_ptr to manage archive scans
    Implemented checkpoint-less no-db mode
    Reverting all that chkpt_only_root_pages jazz
    Added prioritize_archive option on vol_t
    
    - also deleted method restart_m::recover_single_page, since SprIterator
    is really easy to use and the method was only called from
    vol_t::read_page_verify
    Encapsulating SPR logic in new class SprIterator
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed log_spr.{h,cpp}
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Fixed lock timeout of restart thread
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Fixed bug with overflow on partition_t and some cleanup
    
    - File offset must be 64 bits
    - Added assertions to restart REDO
    - Cleaned up some restart code
    Cleaned up some old restart code
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Clean-up of the log analysis mechanism [part 5]
    
    - Moved logic of backward log scanning and serialization into log
    records inside class chkpt_t.
    - Removed master_lsn and other parameters of log scan.
    Considering lsn from log record t_store_operation
    The lsn of a log record t_store_operation must be considered for redo(), but t_store_operation is not adding a page to buffer table. Since no page is added, the lsn of these log records were not being considered before.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed and simplified single-page recovery
    
    - Single-page recovery was using the log fetch buffer incorrectly.
      (Fixes issue #17)
    - Simplified collection of log records by simply copying into a (now
    automatically expanding) buffer and replaying directly from this buffer.
    This eliminates the need for a separate list of log record pointers.
    - Added some assertions to replay process.
    - Removed "actual_emlsn" parameter which was never false. If it's to be
    implemented in the future, the same condition can be simulated with
    `emlsn == lsn_t::null`
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Implemented logging and recovery of volume ops
    
    Added logrecs with proper REDO and SSX for create, mount, and dismount
    of volumes. Recovery works by simply invoking redo() on them, including
    chkpt_dev_tab_log.
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Removed old bf_m code
    Moved SPR methods out of log_m and into restart_m
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    Added comments to function prototypes in header file, no code change.
    Clean up the restart code more for the 2nd M3 check-in, also fixed a few bugs in Log Analysis phase.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    Modified log records for insert and delete to add information for full logging, so we can skip the 'undo' during rollback.  This is because page rebalance is a system transaction, although full logging would generate log records outside of system transaction, we do not want to undo those operations.
    Fixed a regression bug from implementing backward scan.
    Also changed the buffer pool flush code so it does not flush in_doubt pages.
    Implemented backward log scan, not lock acquisition and no test yet, the function is not being executed currently.
    Changed 'doomed' to 'loser'
    Renamed from 'doomed' to 'loser' transaction.
    Fixed test cases.
    Added test hooks and sm_external.h
    More bug fixes for Instant Restart milestone 2.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    Incremental check-in for the work in Checkpoint and Log Analysis.
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Whitespace changes
    BTree cursor now supports open-end scans
    
    - Cursor can be opened with just a start condition. Stop condition is
    then set to infimum or supremum depending on the scan direction.
    Removed SM level 1
    Removed SM level 2
    Replaced all occurrences of volid+snum with stid_t
    Modified test code so it is easier to merge with changed code from master.
    indentation
    cursor to check refix return code for SPR
    minor code reformatting
    deleted:    src/sm/page_bf_inline.h
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Removed "robust" b-tree methods
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Implemented B-tree page compress operation
    
    Compress operation recomputes the key prefix given new fence keys and
    truncates all keys inside a page accordingly. As such, it frees up space
    in the page for further insertions without splitting. Currently, it is
    only invoked in the very special case where there is no space to set a
    new fence key after a split. In our current test suite, this happens
    only with the very long keys of the "keytrunc" test suite.
    Added test for vol_t::take_backup method
    
    Test generates a backup and uses utility function verifyVolumesEqual to
    varify that logical content of backup and original DB file is the same.
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Fixed a bug in full logging page rebalance recovery on the source page, when reset the high fence key, also delete the records which don't belog to the source page due to the new high fence key.
    Also increase the size of Singe Page Recovery buffer for log collection from 128K to 256K.
    Attemped to fix a full logging page rebalance bug but did not get anywhere, check in the current code although it is not completed.
    Updated test plan design document (modified by Julian).
    Bug fixes.
    Modified test code so it is easier to merge with changed code from master.
    moved child_emlsn code to handle class
    indentation
    Applied Mark's page layout suggestion
    more testcases, backup folder option, bug fix
    bugfix
    merge with bufferpool change
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    workaround for ebrowse
    make commenting style consistent
    improvements identified by Hideaki in btree_page
    now fully uses robust methods (forgot two places)
    bug fix to robust_item_data
    on second thought, removed optimization for variable size data too
    small; too ugly for the speed savings
    clarified a comment
    optimization to avoid worrying about too small items in robust cases
    rest of robust item interface
    beginnings of robust interface to B-tree pages
    removed incorrect comment
    finished cleaning up implementation
    removed previous helper functions
    working on better implementation helper functions
    switching using a local version of align
    added some overall implementation comments
    committing so can switch branches
    missed some spots dealing with item 0's format
    added static asserts that field sizes are big enough
    starting cleanup of implementation
    item 0 now has the same format as other items in a page
    more cleanup
    commented all item API functions
    renamed fixed length item fields
    adding comments
    rearranged classes to provide better access control flexibility
    some cleanup
    editing comments only
    more interface cleanup
    more interface cleanup
    interface cleanup
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    removed get_rec_size* functions in favor of new get_rec_space function
    based on item_space
    
    removed dead code page_usage
    introduced predict_item_space
    introduced unused_part call to pull representation details out of
    page_img_format_log
    btree_page[_header] no longer all public
    removed insert_slot
    delete_slot -> delete_item
    finished converting resize_slot to resize_item
    replace_el_nolog now using item API
    new item_resize function
    fence packing now excludes length
    removed some now dead code
    made non-debug mode compile again (unused variables)
    bugs fixes to item code
    replace another occurrence of slot_insert
    introduced insert_item, replaced one usage of insert_slot
    fixed slot length definition for slot 0
    fixed fence accessors
    hold together node field access code
    pulled together common code for accessing leaf item fields
    made an accessor for the poor man's key, _poor
    new API for items; beginning to switch code to it
    cleaned up set/unset_ghost asserts
    beginning to turn slots into items
    Again, newest g++ is too picky
    
    Revert "Add c++0x compile flags to Zero build. This enables several new and"
    
    This reverts commit 6771ea7db808734e91a823455911b0ae3d209379.
    converted compaction routine
    converted slot consistency checker
    Add c++0x compile flags to Zero build. This enables several new and
    desirable features, even on relatively old gcc versions. The changes
    here also include swapping out all instances of BOOST_STATIC_ASSERT
    for static_assert (one of those nice new features) which includes the
    capability of adding an assert message.
    added insert_slot
    code for marking slots as ghost/non-ghost, resizing slots
    cleanup includes
    pulled out btree_page_h class
    compute slot_length correctly for fence slots
    removed data array
    delete_slot pulled out, added typedef's for slot_body
    replaced sinome used of casting
    code reformatting
    deleted:    src/sm/page_bf_inline.h
    un-inlining functions in page_bf_inline.h
    cleanup includes, friends
    comment sections
    move last of buffer manager's direct dependence on btree_page_h
    mostly code reformatting
    converting to BOOST_STATIC_ASSERT
    cleaned up generic page header's fields
    pulled down some more B-tree fields
    removed unused private store page field
    moved down two B-tree fields
    accessors from fixable_page_h to generic_page_h
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    generic_page_h -> fixable_page_h
    created a btree_page_header class to avoid need for hardwired constants
    that must stay in sync
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    fixed extremely dubious casting between page handles by introducing a
    new class, borrowed_btree_page_h
    btree_page_h now checks page has correct tag a via assertion
    bug fix to one of the tests that did not set the tag correctly
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
    page_p -> generic_page_h
    removed pragma interface/implementation
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    Fixed a logic error in btree_p::compare_with_fence_high (const char* key, size_t key_len) that struck when the search key exactly matched the page prefix.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Better defaults for page cleaner and eviction
    Fixed write elision and decoupled cleaner
    Deleted gclock evictioner
    
    - Base cleaner can be configured to behave like GCLOCK, so there's no
    need
    No-policy-cleaner and eviction bugfix: WAL rule
    Made cleanee more flexible with attempt-based triggers
    Added option sm_eviction_interval
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    evict_page logrec now has ppage LSN at time of eviction
    Added buffer-pool infrastructure for new instant restore
    Removing unnecessary calls to wakeup_cleaner
    Eviction loop incrementing idx with std::atomic
    Added should_exit() check to async evictioner
    Proper attempt count and cleaner wakeups during eviction
    Waking up cleaner at beginning of async eviction round
    Commented archive activation only after warmup
    Some assertions and new default values for log archiver
    Fixed some nobd bugs and default options
    
    - Fuzzy checkpoints do not scan buffer frames in nodb mode
    - chkpt_m::_use_log_archive must be set in nodb mode
    Updating dirty page table during eviction in nodb mode
    Fixed 2 crucial bugs in page eviction
    
    - Must check if the thread invoking eviction already holds latch on the
    potential victim, because otherwise the latch is granted but the frame
    can obviously not be evicted.
    - When evicting a dirty page, sync() must be called on the volume
    Implemented random pick_vitcim and optional used of clock
    Logging page evictions for debug
    Default eviction is now a simple CLOCK
    Added option to flush dirty pages on eviction
    Cleaner now has both async (dedicated thread) and sync (on-demand) modes
    Fixed control block initialization and race conditions
    Made eviction tests more explicit and with comments
    Eviction ignoring unused control blocks in pick_victim
    Eviction: ignoring EMLSN maintenance if required and fixed spelling
    Fixed CB pinning and its use in cleaner and eviction
    Added _maintain_emlsn option
    Fixed eviction bug (pin cnt was ignored)
    Cleaner tolerates invalid parent in some cases
    
    - Added write elision option
    - If write elision is on and pointer is unswizzled, page cleaner is now
    free to evict page without a valid parent pointer
    Added max rounds in eviction loop
    Fixed compilation errors in Release mode
    Eviction ignores dirty state in no-db mode
    Eviction not waiting on cleaner anymore
    
    - Finally provides more robust, throttled bahavior to transaction
    throughput under high miss ratios.
    Adding GCLOCK evict policy
    
    Two options control que policy used:
    1. "sm_evict_policy" = "latched" | "gclock"
    
    In case of "gclock", there is an option "sm_bufferpool_gclock_k" that is an int
    indicating the GCLOCK k parameter (every time a frame is referenced, the count
    is set to K).
    Minor formatting issues
    Separation of concerns inside evictioner thread
    
    We are splitting the previous funcionality of do_work() in 3 methods:
    void do_work()
    bf_idx pick_victim()
    bool unswizzle_and_update_emlsn(bf_idx idx)
    
    pick_victim is solely worried about selecting the best victim and returning
    its bf_idx with the CB latched in EX mode. New policies only have to worry
    about overriding this method.
    
    unswizzle_and_update_emlsn encapsulates a funcionality that is common every
    time a page is evicted, therefore it is implemented by the base class and
    cannot be overriden.
    
    do_work does a higher level management of calling pick_victim, unswizzle and
    update expected lsn on the parent, erasing victim from hashtable, releasing
    latches, etc
    Fixing wrong naming of parameters
    
    This was mistakenly introduced by a previous commit
    Replacing 2 asserts by one
    
    The semantic is still the same
    Fixing possible bug when iterating bufferpool
    
    When we reach end of buffer, we should restart at bf_idx 1, not 0.
    Initialiting parameter at constructor
    Renaming parameter to match .h definition
    Adding initial file for evictioner thread
    Added maxPID filter to log archive runs
    Decoupled BlockAssembly from log_core with compression option
    Applying page-image compression in BlockAssembly
    
    - When seeing a page_img_format log record, all previously seen log
    records of that same page (in the current block being assembled) are
    dropped and the prev. LSN pointer is set accordingly.
    Unified classes ArchiveIndex and ArchiveDirectory
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Brought back traditional fuzzy checkpoints
    Implemented undo progress and fixed restore progress
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Replaced restart_m with restart_thread_t
    Bugfix: TID assignment was not thread-safe
    Changed signature of xct_t::cleanup
    Made tid_t a simple uint instead of its own class
    Removed xct thread attachment business
    
    - Every xct can only be run by one thread -- it has been like that for a
    long time, but the code to support multiple threads was still there
    Removed 1thread mutex and xct dependency list
    Removed old&unused xct_log_t
    Moved log record buffer from xct_t into smthread_t::tcb_t
    Got rid of old "plog" stuff
    Moved some logging logic from xct_t to XctLogger
    New templated function to replace log "stubs"
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Added latency measurements to transaction commit
    Removed all uses of w_list_t outside sthread_t
    Removed old & unused "vtable" stuff
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Temporary fix for xct_t latching/memory leak problem
    
    - See GitHub issue #21
    Removed SM level 1
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Fixed log archiver bugs and warnings
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Separated commit processing of plog_xct_t and xct_t
    New generic allocation mechanism for xct_t and related classes
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Implemented basic extensibility of xct for private logs
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Changed 'doomed' to 'loser'
    Renamed from 'doomed' to 'loser' transaction.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Minor bug fix, updated documents and added initial (work-in-progress) design doc for milestone 2.
    Updated the milestone 1 design document, also a few minor code changes.
    RAW-style lock manager
    [Transaction classes] Allow consecutive SSXs to chain
    SSX chaining
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    moved module comments
    Added page_evict_t
    more code comments
    Added SPR APIs
    Added SPR APIs
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    refactoring w_rc_t
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    Many small changes to eliminate compiler warnings. Work-in-progress.
    generic_page_h -> fixable_page_h
    btree_p -> btree_page_h
    page_p -> generic_page_h
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    pretty much finished implementation of controlled lock violation except
    for one issue with the handling of abort.
    
    Modified test_elr to run the analogous tests with controlled lock
    violation mode.  Sharpened the tests to work somewhat better and fixed a
    bug where the tests assumed different tuples in the same page cause lock
    conflict.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixing memory leak
    Detecting warmup based on hit ratio & other updates
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Fixed TL stats life cycle
    Reimplemented global thread list for aggregating smstats
    Removed rand48.{h,cpp}
    Removed 1thread mutex and xct dependency list
    Removed old&unused xct_log_t
    Moved log record buffer from xct_t into smthread_t::tcb_t
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Copied timeout stuff from sthread to smthread
    Trying to make smthread_t fully static (huge commit from hell)
    Removed named sthreads
    Removed sthread priorities
    Cleaned up CB and page header fields
    Managing partition_t lifecycle with shared_ptr & latching
    
    - All methods now return shared_ptr, which allows automatic control of
    ownership and destruction of partition_t objects
    - All accesses to the partition_t map now acquire a latch.
    - Removed old partition lock
    Removed old FUNC macro
    Removed old & unused "vtable" stuff
    Removed unused methods from smthread_t
    
    - Methods were only used in the DORA implementation in Shore-Kits
    Changed debug message mechanism to work with debug flags (like old Shore-MT)
    refactoring w_rc_t
    Conversion of more w_asserts to use if (false) when disabled.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    fixed bug where code was incorrectly assuming a store was unallocated
    if it's root pid was 0
    fixed some shore includes
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Partial commit of changes necessary to remove volatile modifiers. See https://jira.hpl.hp.com/browse/ZERO-116
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Removed most dependencies on sthread_t
    Private lock hashtable to quickly check if the lock is already taken
    Follow-up cleanings
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    new function, lock_m::give_permission_to_violate, that a transaction may
    use to give permission to other transactions to violate its locks.
    _check_compatible can now return a lsn to add to read_watermark if the
    lock is granted (because of control lock violation.)
    pulled out code for checking if our new lock mode request is compatible
    with an existing request into a single in-line function.
    codified the unconventional access rules for some of the fields of
    lock_queue_entry_t; this allowed moving several operations to SAFE via
    some asserts checking which thread was doing the work
    cleaned up documentation of bucket_t on what fields have what latches required
    Added documentation to lock_queue_t class on what fields are protected
    by what latches.  Renamed locks to latches when they were actually
    latches.
    
    ifdef'd out _dump(-) as it wasn't being used and was unsafe.
    more cleanup of lock_queue_entry_t:
      added documentation of how field access is supposed to be protected
      Added // UNSAFE's to accesses breaking the rules
    
    fixed so no warnings about unused parameters
    cleaning up lock_queue_entry_t:
      fixed access control to not be public for changeable fields
      changed fields that are initialized at constructor time and never
        changed thereafter to references
      no longer passing in pointers to others that are always NULL in practice
      changes elsewhere are simplest consequences of these changes
    commit test: no longer dereferences freed space
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    Removed old restore usage in vol_t
    SM destructor waits for recovery thread with clean shutdown
    Fixed bf shutdown, which was being done 3 times
    Various restart fixes
    Buffer-pool warm-up now configurable with sm options
    
    - Also starting background recovery in instant restart only after
    warm-up
    Fixed termination order of chkpt and recovery
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Kick-off cleaner only after recovery is done
    
    - Sumstantial improvement to restart times!
    Commented out unused log archive truncation
    Various fixes to traditional ARIES restart
    Fixed non-instant restart modes
    Fuzzy chkpt fix: ignoring read-only transactions
    Restart thread doing undo first
    chkpt_m now derives directly from worker_thread_t
    Gather filthy shutdown LSN earlier
    Clean shutdown waits until all frames are clean
    Fixed recovery in bf_tree_m with nodb==false
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Correct recovery of dirty pages in nodb mode
    Updated genarchive command
    Some restore fixes
    Fixed redo bookkeeping and vol_t shutdown
    Small bugfix in debug code
    Fixed restore shutdown
    
    - Some parts of the code were still waiting for restore to finish
    Support for mixed restart and restore; cleaned up chkpt
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Removed htab stats
    Replaced restart_m with restart_thread_t
    Generating benchmark_start log record on SM constructor
    Initializing chkpt_m correctly after log analysis (fixes #35)
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Webserver: Adding shutdown filthy
    Adding an option to call inside the system a dirty shutdown, which simulates a real crash by removing log records from the log.
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Reimplemented global thread list for aggregating smstats
    Fixed SM destruction order
    
    - Lock manager must be destructed after buffer pool
    Unified classes ArchiveIndex and ArchiveDirectory
    Changed siganture of deleteRuns (minor)
    Fixed & generalized wait/notify behavior of worker_thread_t
    Changed signature of xct_t::cleanup
    Fixed truncation with no-db mode
    Updated stnode_cache_t to use normal page fix
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed more headers, fixing their previous uses
    Removed w_stream stuff
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Removed 1thread mutex and xct dependency list
    Got rid of old "plog" stuff
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Goodbye sthread IO!
    Removing #define USE_TLS_ALLOCATOR
    
    This was being defined by default anyway. No documentation, be the alternative
    to the TLC allocator was called "naive allocator", so it is probably safe to
    discard it.
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Update sm.cpp
    Fixing call to archive if it does not exist
    
    ss_m::_truncate_log() was calling the archive even if it was not active
    Fixed log archive truncation
    
    - Regex must use perl mode instead of basic
    - isLogTooSlow condition expanded to include case of crossing log file
    borders (which is expected on truncation)
    Options to truncate log archive and run benchmark for a given log volume
    Chkpt mgr keeps track of last chkpt LSN
    
    - which allows returning a meaningful min_active_lsn() when both
    min_xct_lsn and min_rec_lsn are null.
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Added global instance for char memalign_allocator
    
    - Still unused so far...
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    Fixed asynchronous candidate collection in cleaner
    
    - Separate thread can collect candidates asynchronously while other
    frames (collected in a previous invocation) are cleaned
    - Added option to activate this behavior
    Tweaked cleaner initialization
    
    - Moved eager initialization to SM constructor
    - Cleaner has dependency not only on a valid vol object, but also on its
    alloc and stnode caches -- added method caches_ready() for that purpose.
    truncate_log now deletes truncated log partitions
    Fixed shutdown of log, vol, and bf_tree
    
    - Added shutdown method to bf_tree
    - Invoking shutdowns in correct order
    Fixed cleaner and bf initialization
    
    - Buffer must be initialized after volume if cleaner starts running
    eagerly
    - Properly initializing eager cleaner and destroying it on shutdown
    Fixed flushing of alloc/stnode pages on sm shutdown
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Initializing cleaner lazily & fixed log_truncate option
    
    - Log truncation should be off by default, and it has nothing to do with
    sm_format
    - Cleaner should only be initialized if it's ever used, i.e., if
    get_cleaner is called
    - This makes for quicker startup & shutdown during test cases
    Fixed log manager destruction
    
    - delete log was not being invoked at SM destruction
    - Fixed shutdown of recycler thread; moved condvar & mutex inside its
    class
    Page cleaner acessed directly with bf_tree::get_cleaner
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    chkpt_m: removed chkpt_serial and added get_curr_rec_lsn()
    Small preliminary clean-up of sm.h and sm.cpp
    Removed sm_du_stats
    Removed class ErrLog and replaced its uses with std::cerr
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed prologue_rc_t
    Removed auto_delete stuff
    Removed unused class logbuf_core and associated files
    Removed old & unused "vtable" stuff
    Unified all truncate/reformat options into single sm_format
    Flushing log after force volume & other small fixes
    Added timers to ss_m constructor for each phase of the initialization
    
    - Also commented out some verbose outputs in restart
    Implemented new log read buffer for log_core::fetch
    
    - Buffers a certain number of log partitions, starting from the latest
    one backwards.
    - Asynchronous thread loads buffer in chunks of 32MB in reverse
    chronological order.
    - log_core keeps track of LSN range already buffered and get log record
    from buffers in case of a hit.
    - Since a big sequential LSN range is what is buffered, a pair of
    variables suffices and there is no need to track individual log pages
    with a hash table. Given the pattern of log reads during restart
    recovery, this mechanism is also quite effective.
    - Also moved log analysis log record inside init method, so that we
    also count the buffer initialization as startup time in the experiments.
    Moved ticker thread inside log_core class
    
    - New init() method must be called after constructor to fork it
    Passing dirty page table to vol_t by copy instead of pointer
    
    - Table must be copied to avoid unexpected segmentation errors
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Refactored checkpoint thread management
    
    - No more sync/async modes -- take() method is always synchronous
    - Thread takes a checkpoint when an interval timeout is reached or upon
    receiving an awake signal.
    - If interval is negative, no thread is created.
    Implemented new truncate_log method in log_core
    
    - Log truncation is now integrated into log_core, rather than being a
    dirty hack invoked directly on log files by ss_m code
    - Acquires insertion and flush locks and creates a new empty epoch on a new
    partition. Flush daemon then automatically performs actual truncation.
    Fixed bug with overflow on partition_t and some cleanup
    
    - File offset must be 64 bits
    - Added assertions to restart REDO
    - Cleaned up some restart code
    Introducing page_cleaner_base generic class
    
    - virtual class for page cleaner (bf_tree_cleaner now inherits from this class)
    - join_cleaner(timeout_t) replaced for simple join(), since timeout_t seems not to be working anymore
    - request_stop_cleaner() and join() unified into new shutdown() method
    - take_interval() and interval_millisec_min/max removed. Cleaner now wakes up every fixed time and clean pages, even if no implicit request was made
    Fixed some restart bugs & general clean-up
    Fixed silly checkpoint bug
    
    - The log scan of a decoupled checkpoint must cover the range between
    the current chkpt_begin and the last one, so that the complete history
    of log records is captured in the latest checkpoint. For that to happen,
    the system must first write out a begin log record *and then* start
    scanning. Previous code was only inserting a begin after scanning, which
    means all log records inserted during the scan were ignored. Really
    dumb.
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Removed operating_mode flag
    
    - Global flag to tell if system is in recovery or not is not really
    necessary
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Clean-up of the log analysis mechanism [part 3]
    
    - Deleted old monstruous checkpoint method. Now relying solely on
    decoupled checkpoints.
    - TODO: clean-up all parts of the code that assumed a traditional
    checkpoint (e.g., concurrency control on xct table, buffer pool, etc.)
    Cleaned up old log analysis code in restart.cpp
    Fixed bugs with vol_t and stnode_cache
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding checkpoint command line options
    Enabling logging for ss_m::create_vol()
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed log truncation and clean shutdown
    
    - Truncation is only allowed when performing clean shutdown
    - Shutdown is now dirty by default
    New log archive file format
    
    - Log records are not stored contiguously in runs, with a skip log
    record determining the EOF. I.e., the same format as log files. The only
    difference is that index blocks are stored at the end.
    - The old format kept log record in blocks in the same format as
    produced by BlockAssembly. However, the format is not beneficial for
    scans on the log archive, since unless opening a file at the exact
    beginning of a block, I/O sizes will be smaller than a block. The block
    format was maintained for index blocks, however.
    - The log archive generation methods (mostly in the WriterThread) had to
    be changed. For RunScanner, a LogScanner object is required to parse the
    continuous stream of log records.
    Fixed race condition in ArchiveDirectory
    
    - For a brief period of time, writer thread closed the current run
    before it opens a new one. If during this time window, a flush request
    (from archiver thread) tries to close the current run, it will throw a
    file not found error.
    - Fixed by implementing an atomic closeCurrentRun method which uses a
    mutex and closes and opens a new run in the same method.
    Fexed restore to write the checksum of pages
    
    - Due to the restore loop logic, the checksum was not calculated for the
    last page on each segment.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Removed obsolete ArchiveMerger class
    Fixed series of bugs on log archiver
    
    - Mostly related to log truncation, which creates a lot of special cases
    - Fixing these bugs was a painful process, so in retrospect, such
    truncation features were probably not very useful.
    Fixed sharp backup taking
    
    - To make sure that a sharp backup is taken from the current tail of the
    recovery log, a stronger version of log archive flushing was
    implemented, in which not only we wait for all log records to be
    consumed and written out to archive blocks, but also forcibly close the
    currenr run and create a new one. This also makes sure that the new run
    has the requested LSN as its upper boundary.
    Fixed annoying bug with DEBUG3 on xct code
    Fixing first chkpt call
    This line calls the first checkpoint when the storage manager starts. It must be a synch checkpoint, otherwise the storage manager may start running transactions before a checkpoint exists.
    Fixed log archiver and log truncation to work together
    
    - A truncated log introduces a bunch of special conditions in the log
    archiving process:
      - It must generate empty runs to account for the hole beteen the
      truncated LSN and the next partition.
      - It must tolerate empty runs.
      - It must support manually unsetting the eager flag and activating
      until an LSN larger than the current log LSN.
    
    These and other tricks were implemented to make log truncation work with
    log archiving and vice-versa.
    Implemented log truncation
    
    - Log truncation is useful to load a database and leave behind a clean
    database and a minimal amount of log. In our case, the log starts a new
    partition and copies the contents from the last checkpoint into it,
    adjusting the LSNs and checkpoint information. Then, all previously
    existing partitions can be deleted.
    
    - This commit also includes a bugfix on the backward log scanner, which
    would fail if the checkpoint begin was the first log record of the first
    existing partition. In that case, because there is no previous
    partition, it could not get the "nxt" LSN field correctly.
    Getting shutdown_clean flag from an SM option
    Added debug macro W_IFDEBUG5
    
    - We only had those until debug level 4
    Small fix on ticker thread
    
    - It should be destroyed after volume manager if we want the logged
    restore progress to be ticked
    Implemented ticker thread
    
    - When enabled, this thread inserts a tick event log record every second
    or millisecond, depending on the configuration.
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Renamed log archiver shutdown method
    
    start_shutdown implies an asynchronous shutdown, but since we changed
    the shutdown mechanism to be synchronous, the method should be called
    simply "shutdown()"
    Several bug fixes on eager log archiver
    
    - Reader thread cannot run eagerly, because endLSN must be in sync with
    log archiver. This is because log consumer expects a skip log record on
    the endLSN position, and it must be artificially inserted by reader.
    - Reader activation fixed to use a single signal instead of a loop.
    Thanks to proper lock acquisition, we guarantee that the signal is
    always caught.
    - Reader correctly fetches partial blocks across activation cycles,
    i.e., if then endLSN is in the middle of a block, following read will
    fetch data into the rest of the block, so that scanner continues from
    the same offset where it left off.
    - LogArchiver keeps track of the endLSN of the last activation, to avoid
    being activated on a region which was already covered before. This is
    important for cases when the archiver runs faster than the log grows.
    - Shutdown of log archiver is synchronous now, i.e., it sends
    synchronous shutdown to all sub-components and joins on all threads.
    - Writer thread forked from the beginning rather than on demand.
    Eliminated writerForked flag and fixed shutdown.
    - Small fix on heap workspace deallocation (array delete was wrong)
    - Added log archiver shutdown to SM destructor.
    Several bugfixes on restore/volume code
    
    - Fixed fixedSegment checks on BackupReader
    - Correct initialization of restore bitmap
    - Memory leak with RunMerger in restore loop
    - Volume manager shutdown in correct order (sm.cpp)
    - Not cleaning volume metadata when marking as failed
      (Temporary fix! Must figure out how to keep allocated pages in the
      server state)
    - Correct log record for restore_begin
    - Close backup file on volume dismount
    - Handling short I/O on read_backup method
    Simplified vhdr and peristent vol metadata mgmt
    
    - Volume header only has to contain vid and total number of pages; all
    other fields were not necessary.
    
    - Isolated logic to write metadata pges (incl. volume header) so that it
    can be reused for taking backups.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Removed SM level 3
    Removed SM level 4
    
    This begins a series of commits in which I'll attempt to remove the
    concept of "SM levels". The goal is to have independent components (bf,
    log, lock, io, etc.) which can be constructed independently, and a much
    "thiner" ss_m which simply orchestrates the components and delegates API
    calls to them.
    Implemented shutdown of volume manager
    
    When destroying ss_m, invoke shutdown on vol_m, which simply relays the
    call to all mounted vol_t. The shutdown procedure is essentially an
    unlogged dismount. If a restore is ongoing and an abrupt flag was not
    set, it should wait for restore to complete.
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Fexed restart bugs with new volume manager
    
    Log analysis was not processing mounts and dismounts correctly and
    checkpoints were not being completed with writing master log record.
    Also fixed virgin-page handling after eliminating past_end mechanism on
    volume reads.
    
    At least test_crash is passing now. There may be more bugs to be found
    in the various restart tests.
    Fixed SSX's and thread safety of volume mgr
    
    - Added spinlock to protect operations on vol_t and vol_m
    - Fixed behavior of SSX -- log only after all operations completed in a
    method
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed raw device stuff and unused vhdr fields
    
    The distinction between raw and non-raw volumes does not make much
    sense, because nothing important was really done based on it. Also see
    comments.
    
    Removed fields quota and page_sz from volume header, since these are
    redundant.
    Some whitespace changes
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Removed store number from page ID
    
    - Updated all constructor occurrences
    - Updated some buffer pool methods to take store ID as parameter
    Replaced l0 with lvid_t::null
    Made vid_t a simple typedef and deleted volid_t
    Missing pieces from lid_m removal
    Refactored log manager to use sm_options
    
    Same thing as done for bf_tree_m on the previous commit, but now for log
    manager classes (log_core, log_common, logbuf_core). This was quite
    tricky to achieve due to the crazy dependencies in log manager
    initialization and the complete lack of reuse in logbuf_core.
    Refactored bf_tree constructor to use sm_options
    
    Instead of parsing/gathering options in sm.cpp and invoking the
    bf_tree_t constructor with a bunch of parameters, the cosntructor now
    takes the sm_options as parameter directly. We should have all
    "managers" be initialized this way.
    Moved some restart code in sm.cpp into own methods
    Removed LID manager
    
    Class lid_m was only used to generate lvid for new volumes. I copied the
    method inside sm.cpp and deleted the class. One less "manager" to take
    care of...
    Fixed bug on volume creation
    
    Old device manager code would perform a mount and dismount when creating
    a volume, only to later invoke another mount operation through
    ss_m::mount_dev. Since we eliminated mount_dev, the volume was left
    unmounted after a create. To fix this in the best way, I simply removed
    the unmount operation after creation.
    Removed device manager and its uses
    
    Shore/Zero always had the concept of a device, which was supposed to be
    composed of multiple volumes -- in the same way a linux device is
    composed of multiple partitions. However, this destinction was never
    really realized, and a device was always assumed to contain just one
    volume.
    
    In a refactoring which was supposed to be done many years ago, I removed
    the device manager and all its uses, delegating to volume operations
    where applicable. It seems like things will keep working as expected,
    but more tests will be required to see if anything is broken by this
    change.
    Updated log archiver constructors
    
    Constructors now rely on sm_options to initialize their state.
    Additionally, LogArchiver can be constructed by passing instances of
    ArchiveDirectory, LogConsumer, ArchiverHeap, and BlockAssembly. This
    modularization will be useful for tests and experiments.
    Removed option to generate unsorted log archive
    
    The copy() method was used instead of replacement selection in the BTW
    paper to compare the overhead of partially-sorted with traditional log
    archiving. We probably won't be using it again, and it actually needs
    to be rewritten since the latest refactorngs, so I'm removing it for
    now.
    Fixed log archiver bugs and warnings
    Added code to instantiate and activate log archiver
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Fixed bug with update handling in clog
    Updated SM code to consider cmake flag USE_ATOMIC_COMMIT
    Decoupled Aether methods in log_core to enable atomic commit protocol
    Implemented simple commit logic on clog
    Plog implementation with dynamically growing memory
    New generic allocation mechanism for xct_t and related classes
    Changed construction of xct objects to use customized new operator
    instead of static new_xct method
    Implemented basic extensibility of xct for private logs
    Moved SPR methods out of log_m and into restart_m
    Fixed bugs in logbuf_core (tests passing now -- except for TSTAT issues)
    Log refactoring: moved common code of log_core and logbuf_core into
    abstract parent class log_common
    Fixed some of the bugs on logbuf_core after refactoring
    Log refactoring: pulled out log_storage into its own class
    Log refactoring: made log_core and logbuf_core implementations of log_m
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    switch to the new log buffer
    Enabled child thread REDO and UNDO for mixed mode (M4)
    Added couple test cases for M3 and found out that backward log scan does not work (which was never used)
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Implemented backward log scan, not lock acquisition and no test yet, the function is not being executed currently.
    Fixed test cases.
    Added test hooks and sm_external.h
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    Multiple bug fixes, also draft design doc for milestone 3.
    More bug fixes for Instant Restart milestone 2.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Fixed compile warning messages from test_backup.cpp and test_spr.cpp.
    Minor updates in design documents, more will come later.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Frequent check-in to local repository during 'Instant Restart' milestone 2 development.
    In this check-in:
    1. Mostly infrustructure changes
    2. Spawn a recovery child thread for the concurrent REDO/UNDO phases, but no actual implementation for the REDO/UNDO yet.
    3. Prepare bit settings to turn on/off recovery features.
    Initial prep work for 'Instant Restart' milestone 2 work.  Check into work-in-progress code only because need to merge code from Trunk/master.
    Merge fixed for OKVL experiment
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    RAW-style lock manager
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    parameterize carray active slot count
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    Ported Consolidation Array
    more testcases, backup folder option, bug fix
    [Transaction classes] Allow consecutive SSXs to chain
    SSX chaining
    Return value checks, conform to coding convention, etc
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    backup manager now called from SPR
    more code comments
    refactoring w_rc_t
    deleted more files.
    Removed regex package
    Conversion of more w_asserts to use if (false) when disabled.
    dropping solaris support
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    Ripping out distributed xct/2pc related code (which has been broken for long time).
    
    (Suggested required reviewers: Wey, Mark, and Harumi)
    This is what we discussed and concluded 12/16/13.
    Distributed xct/2pc features in Foster B-tree were anyway broken since its beginning because I ripped out network-related  code when I converted Shore-MT to Foster B-tree.
    
    Now, I am cleaning up the remnant more thoroughly.
    We will need distributed xct later, but
     - We need to significantly simplify the code for log manager refactoring.
     - Dead code is evil by itself.
     - Our distributed xct implementation will be anyway from scratch.
     - If we need to see the old code, we can anytime come back to this diff for reference.
    
    This changeset removes most of the distributed xct/2pc related code and comments.
    However, there are most likely some code that was indirectly used only by the removed codes.
    I think we can do even more cleanups especially in log manager as we are throwing away all 2pc related codes.
    Nevertheless, fully figuring it out now is tough. Let's do it gradually.
    
    Instead, this change set consists only of easy code removal I'm pretty sure to be safe.
    All testcases pass with this change.
    btree_page[_header] no longer all public
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    st_bad -> st_unallocated
    removed some dead fix code
    Many small changes to eliminate compiler warnings. Work-in-progress.
    removed no longer in use constants
    generic_page_h -> fixable_page_h
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    page_p -> generic_page_h
    page_s -> generic_page
    stnode_p -> stnode_page_h
    enable/disable statistics at runtime
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Modified page replacement policy to (1) make it more modular so that different policies can be implemented, (2) introduced runtime argument to select page replacement policy
    Fixup warnings about unused variables in stubbed out functions
    
    We have several files which stub a LOT of API functionality w/assert(0);
    I've gone through and tried to suppress all of these warnings.
    
    There still are some, but these warnings seem to be actually unused
    variables, rather than warnings related to bits of API we've only stubbed.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Backup now guarantees zeroed contents when fetching unallocated pages
    
    - With help of new class backup_alloc_cache_t
    Removed unused and unecessary header files
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Updated bf_hashtable to use pair of bf_idx
    
    - Every entry now contains a pair of bf_idx values, which we can use to
    store the parent cb index.
    - Also updated the find methods to return bool and pass the return value
    as argument.
    Turned bf_hashtable into a template
    
    - Goal is to allow storing two bf_idx in the buffer hash table: one for
    the CB of the page itself, and one for the CB of its parent.
    Added update operation to bf_hashtable
    
    - Will be used by B-tree adoption when parent cb pointer is stored in
    the hash table as well
    hierarchical eviction in bufferpool
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Removed most dependencies on sthread_t
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Copied log archiver files from old plog branch
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Added store number parameter to B-tree locking
    
    Since store number is not available in the page ID anymore, all B-tree
    locking methods (e.g., _ux_lock_key) must include the store number as
    an additional parameter.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Initial implementation of on_demand UNDO with lock conflict detection.
    Clean up some of the existing test cases to get ready for M3 test case development.
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    RAW-style lock manager
    fixed bug where we took the gap lock on the wrong key (the following one, not the preceding one)
    cleaned up comments, preconditions for _ux_lock_range
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    *_key's -> get_key
    new_search->search, replace search_leaf with search
    OKVL terminology change and optimizations
    renamed w_okvl to ovkl_mode
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Moved latches to sm and fixed test compilation
    Removed sthread_stats
    Removed most dependencies on sthread_t
    Moved latch/mutex stuff out of sthread files
    Merged folders common, sthread, fc, latches, and Lintel
    -modified experiment select_only to switch on/off oprofile to profile code section
    -identified scalability bottlenecks in statistics collection
    -modified clock replacement policy to identify between cold and hot pages
    -limit refcount increments
    Facility to limit physical memory consumed by a process
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Convert arithmetic atomics from legacy to lintel::Atomic
    Fix 2 obvious (in retrospect) bugs introduced by conversion to lintel::Atomic
    Eliminate atomic_cas_[32|64]
    Replace membar-*() with atomic_thread_fence()
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Fixes so that we can do a complete out of tree build.  Also
      other minor improvements.
    
    {examples,experiments,src/**,tests}/CMakeLists.txt: auto-generated file include paths
       Generate files in the binary directory only, and only generate them once rather
       than N different custom commands.
    
    experiments/experiments.h: move log/data stuff to /dev/shm
    
    experiments/random_inserts/select_only.cpp: improve usage message
    
    src/sthread/srwlock.cpp: add { } to eliminate compiler warning
    Zero branch from subversion rev 11038
    Added option for single-pass restore
    Multi-segment restore + using backupLSN as log replay bound
    Fixed wait for restore to be done
    Removed 4th state of restore bitmap
    Removed old restore code (farewell part 1)
    
    - Goodbye, old friend. It hurts me deeply to do this after years of hard
    work, but it had to be done. The old must make way for the new. It's
    been a pleasure.
    Fixed descturction of BackgroundRestorer
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Updated restore bitmap
    Fixed log replayer for new restore
    Added buffer-pool infrastructure for new instant restore
    Some restore fixes
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Interrupting restore when performing shutdown
    Support for mixed restart and restore; cleaned up chkpt
    Webserver: tracking media recovery progress
    Restore bitmap using std::atomic, no global critical section
    Fixed restore coordinator logic
    
    - Waiting for signal in a timeout loop
    - Using is_replayed to check segment restoration
    Using shared_ptr to manage archive scans
    Batch restore/warmup for nodb mode
    
    - Still need to detect a warm buffer when capacity is very large (i.e.,
    no misses)
    Unified classes ArchiveIndex and ArchiveDirectory
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved nested classes out of LogArchiver
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Extended restore scheduler with thread-specific calls
    
    - Just temporatily trying out a partitioned scheduler
    Adapted BackupOnDemandReader for multiple threads
    
    - Also using it as default for now. With multi-threaded restore,
    BackupPrefetcher should be less significant and will probably be removed
    later on (if multi-threaded restore works well enough on HDDs)
    Updated restore scheduler
    
    - Only onte thread attempts single pass; others pick a segment at random
    between firstNotRestored and lastUsedPid
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Small restore bugfix: handling segments beyond the bitmap size
    Fixed restore manager shutdown
    
    - Fixed pin behavior
    - check_restore_finished() does not block waiting for restore
    Fixed RestoreMgr for latest refactorings
    
    - Restore scheduler used to treat page id 0 as a special value meaning
    "no next page", but since new allocation was implemented, 0 is a valid
    page id, so a bool return value is used instead to indicate whether
    there is a next page to restore or not.
    - Disabled restore logging -- to be fixed later
    - Other bug fixes
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed restore shutdown with pin mechanism
    
    - Pin mechanism avoids deletion and destruction of restore manager while
    threads may still be accessing it. New shutdown method only proceeds
    once it manages to set the pin count from 0 to -1
    Removed random-order restore and singlePassLoop
    
    - Current instant restore implementation can perform single-pass restore
    without a separate loop method
    - Random restore did not show any benefit in practice, so I removed it
    to keep the codebase lean
    Eliminated multseg restore techniques
    
    - New "preemptive" technique is much simpler and achieves the same goal
    - Updated log archive probes to not use min/max read and segment size
    Implemented preemptive adaptive restore technique
    
    - Every segment restore by default opens a log archive scan until EOF,
    and multiple adjacent segments are restored until a new request pops up
    in the scheduler.
    - The goal is to restore one segment at a time during the initial phase
    of restore, prioritizing latency. As the working set is restored in the
    buffer, the algorithm then behaves more like single-pass restore,
    achieving higher bandwidth.
    - This simple and effective technique should replace our complicated
    multiple-segment technique. Thanks to Goetz for suggesting it.
    Updated backup prefetcher
    
    - Prefetching now controlled by RestoreMgr instead of scheduler
    - Changed how prefetching is performed in the restore logic. Got simpler
    code and better performance
    Restore considers last used PID as end of device
    
    - ..instead of the maximum page ID given the quota of the disk.
    - Remvoed the variable numPages and replaced it with lastUsedPid.
    - Control of restore progress as well as bitmaps are now based on
    lastUsedPid, which makes for smaller memory footprint.
    - Also a good idea because I plan to get rid of the disk quota soon.
    Some bugfixes on restore
    
    - Separate bitmap for replayed but not written-back segments must be
    kept in the object state, so that mlutiple-segment restores also set it
    correctly.
    - Prefetching only one segment on every singlePassLoop iteration
    - Making sure finishSegment inbetween a multiple-segment restore never
    passes a page count larger than the segment size when writing.
    Updated backup-taking method to use single-pass restore
    
    - Instead of taking a backup (through restore) of the device in
    segments, it is more efficient to used single-pass restore by setting
    the "instant" parameter of the restore manager to false.
    New archive index probe method and multiple-segment restore
    
    - Whole probing/scanning mechanism of log archive was updated and is
    much simpler now, also supporting multiple-segment restore.
    - Open method now takes a start pid and the number of page ids to be
    scanned (segment size), as well as a min and a max read size.
    - Probe method returns a list of probe result objects, which simply
    contain a start offset and an end page ID on which to stop scanning.
    In order to achive reads greater than the given min size, the end pid
    is adjusted based on neighboring segments, but going no further than the
    max read size.
    - After initial probe, open method readjusts endPid of all run scanners
    based on the maximum value collected.
    - Restore manager was also updated to work with the new mechanism.
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Small fixes on single-pass restore
    
    - Fixed prefetching on single-pass restore
    - Adjusted segment borders to start at page ID 0
    Added tryMultipleSegments as an option
    Added restore prefetch window as an SM option
    Reuse one log archive scan to restore multiple segments
    
    - Implemented a technique taht checks when opening a scan if multiple
    segments can be restored based on the page IDs contained in the first
    block read from each run.
    - The technique required a new restoreSegment method, which is more
    generic and can now be reused for the single-pass loop and, later, for a
    generic log replay class.
    Fixed small bug on restore
    
    - getSegmentForPid was performing the wrong calculation concerning the
    first data page ID.
    Implemented true single pass restore
    
    - Added another version of a restore loop which performs one pass over
    the whole log archive as well as one pass over the backup
    - This restore loop is used if the option "sm_restore_instant" is false
    Incorporated prefetching on restore manager
    
    - Invoking backup prefetching on restore scheduler and on-demand request
    enqueueing.
    - Proper shutdown of async writer and prefetcher threads.
    - Fixed bug with inline methods (code not compiling on release build)
    Restore manager using async writer
    
    - Adapted restore manager methods to use asynchronous writer when the
    corresponding option is set.
    - Now there are three methods involved in finishing up a restored
    segment: finishSegment, writeSegment, and markSegmentRestored. They are
    called in this order, but orchestrated differently if we are using an
    asynchronous writer.
    Implemented asynchronous writer thread for restore
    
    - Class SegmentWriter (declared and defined in restore.cpp) is used to
    write restored segments asynchronously.
    - This commit simply introduces the class, which is not being used yet.
    Reorganized restore methods
    
    - restoreLoop was too large, so I moved the logic to perform log replay
    on a single segment into the new method restoreSegment.
    - Flushing log buffer when marking segment restored (useful for offline
    restore experiments)
    - Assorted clean-ups on restore.cpp code
    Supporting on-demand and random order in restore
    
    - If on-demand is turned off, restore scheduler ignores all requests and
    performs a pure single-pass restore
    - If random order is enabled, single-pass restore happens in random
    order of segments, instead of the default sequential behavior.
    Fixed synchronization between restore and log archiver
    
    - Order of operations in the `mark_failed` method is crucial (See
    comments in the code). It turns out that the failure LSN cannot be set
    when restore manager is constructed, but only after the device is marked
    failure.
    - Also fixed the `check_restore_finished` condition, which had a race
    condition when some other thread unsets `failed` after one thread checks
    but before it grabs the mutex.
    Restore goes only to last used page ID
    
    - Information is extracted from alloc_cache, which is expected to be
    consistent by the time the device is marked failed. Furthermore, no
    allocations can occur once failed is set, so there are no "lost
    allocations"
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Implemented non-instant restore and eager archiving
    
    - Added "instant" flag to restore manager. On-demand requests are only
    satisfied if the segment is restored AND the flag is true. This allows
    us to run experiments with traditional restore.
    
    - Eager archiving means that the reader thread and the sorter thread of
    the log archiver keep running indefinitely in a loop until shutdown. The
    lazy behavior (old one, current default) means that these threads must
    wait for an activation signal.
    Fixed backup generation
    
    - Flush bf_fixed to initialize metadata of backup, instead of writing it
    empty, as done in sx_format
    - Deadlocks removed
    - No restore logging when taking backup
    - Other minor bugs
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Added functionality to take backups
    
    vol_t now supports take_backup() operation. Its internal state keeps
    track of a path and file descriptor for a backup file currently being
    generated. It instantiates a RestoreMgr and reuses its functionality to
    generate a new backup file instead of a replacement device.
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    Basic logging and recovery functionality for restore
    
    Implemented log records and their generations as SSX, their REDO
    operations, and required methods in vol_t and RestoreManager.
    Proper volume shutdown after restore merge
    
    Shutting down with ongoing restore requires waiting for the
    (single-pass) restore operation to complete, unless an "abrupt" flag is
    passed.
    Fixed bugs after rebasing branch smlevel on restore
    Added options to tweak restore behavior
    
    - trySinglePass: if true, restore scheduler will return page IDs in
    sequential order if there are no requests available, meaning that
    single-pass restore is performed together with on-demand restore.
    - reuseRequestBuffer: if true, read requests from the volume manager
    may reuse the restore buffer and copy requested page contents into the
    target frame in the buffer pool after restore. This avoids an additional
    read of a page which was just recently on main memory.
    
    These two behaviors used to be on by default
    RestoreMgr now keeping track of volume metadata
    
    Log records belonging to shpid 0 must be restored first, since they
    rebuild the volume metadata (stnode cache) by replaying store
    operations. RestoreMgr now has a special restoreMetadata() function
    which is called before restoring any data page. Accordingly, methods
    accessing such metadata (such as vol_t::get_store_root()) must wait
    until it is restored. A mechanism to achieve this was also implemented
    witha simple flag 'metadataRestored'.
    
    This commit fixes complements the previous one.
    Fixed restore manager
    
    - Fixed archive scan boundary cases (first PID or LSN, beyond end, etc.)
    - Fixed restore progress control to handle non-used segments (no log
    replay)
    - Restore ignoring/forbidding requests on first pages of the volume
    (i.e., alloc pages, volume descriptor, etc.)
    - Sending restore signal after each segment to waiting threads
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Started implementation of Restore Manager
    
    Sketched the basic API and added a simple bitmap implementation.
    Backup now guarantees zeroed contents when fetching unallocated pages
    
    - With help of new class backup_alloc_cache_t
    vol_t::read_backup now returns void
    Removed old restore usage in vol_t
    New instant restore!
    
    - Reuses buffer pool for all page I/O, no separate read or write
    buffers, no complicated prefetch and async write logic, no tricky
    request handling and copying requested pages back into buffer, etc.
    - Also uses new mmap-based ArchiveScan class, so log archive access
    is much more efficient
    Bufferpool prefetch for instant restore
    Fixed backup handling in vol_t
    Moved dirty page tracking and redo code from vol_t to restart_thread_t
    Fixed ARIES restart with proper alloc & stnode logging
    Fuzzy chkpt fix: collecting dirty pages from vol_t table
    Correct recovery of dirty pages in nodb mode
    Detecting warmup based on hit ratio & other updates
    Fixed redo bookkeeping and vol_t shutdown
    Fixed redo progress
    Fixed restore checkpoints
    
    - Restore state now being serialized to checkpoints
    - restore_begin log record keeps track of lastUsedPid, so that the
    original value is used for every instantiation of the same restore
    process
    Support for mixed restart and restore; cleaned up chkpt
    Webserver: tracking media recovery progress
    Added option for store clustering
    
    - Also fixed metadata initialization without clustering.
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Implemented checkpoint-less no-db mode
    Added prioritize_archive option on vol_t
    
    - also deleted method restart_m::recover_single_page, since SprIterator
    is really easy to use and the method was only called from
    vol_t::read_page_verify
    Fixed test_restore
    Fixed restore_begin logging
    Removed uses of sthread IO in vol_t
    Enabling option to open volume without O_SYNC
    
    When opening with O_SYNC, any write to the file is guaranteed to be sync.
    When opening without O_SYNC, one would have to call sync() after a write to
    ensure persistence.
    
    By making persistent writes optional, we can compare Zero to other systems that
    offer the same guarantees (NoSQL systems, for example).
    
    The default option is still: "sm_vol_o_sync = true"
    Fixed race conditions on testing _failed flag of vol_t
    
    - Using latch instead of memory fences -- it's easier, safer, and
    there's no critical performance impact.
    New command AddBackup
    
    - Brings back functionality to add backup files, but this time
    externally using a cp'ed file. Backup LSN is registered in the log
    record and processed by vol_t.
    - Checkpointing backups not supported yet.
    Tweaked cleaner initialization
    
    - Moved eager initialization to SM constructor
    - Cleaner has dependency not only on a valid vol object, but also on its
    alloc and stnode caches -- added method caches_ready() for that purpose.
    Added dbscan command to show page info on DB file
    
    - Also changed agglog to aggregate all types if not -t argument given
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    alloc_cache and stnode_page read directly from vol_t
    
    ... instead of fixing page in the buffer pool. This is done so that they
    don't leave a dangling page which is never updated, read, or cleaned.
    Fixed restore manager shutdown
    
    - Fixed pin behavior
    - check_restore_finished() does not block waiting for restore
    Parametrizing use of O_DIRECT in vol_t
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Passing dirty page table to vol_t by copy instead of pointer
    
    - Table must be copied to avoid unexpected segmentation errors
    Added options to log page reads and writes
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Adding important note to vol_t::read_page and write_page
    Since we are using O_DIRECT now, the caller must know he is responsible for aligning the buffer.
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Introducing vol_t::read_many_pages()
    in analogy to vol_t::write_many_page()
    Removing bf_uninstall flag from vol_t::dismount()
    The bf_fixed page of a volume is not recovered during restart. For now we keep this assumption and we must guarantee that the bf_fixed is flushed even during dirty_shutdown.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed restore activation and finishing
    
    - LA activation not invoked properly without eager archiving
    - Logging of restore_segment moved to restore.cpp
    - Removed redo argument from check_restore_finished (TODO)
    Added read-only flag to vol_t
    
    - If flag is set, all writes are ignored and method returns imediately
    (i.e., write elision).
    Added option to flush log archiving when taking backup
    Fixed backup bugs
    
    - Missing comma in vol header prolog was compiling but causing weird
    errors. That was hard to catch.
    - Fixed backup reader to star reading from the offset of the first data
    page.
    Added backup LSN
    
    - Each backup file is now equipped with an LSN which corresponds to the
    most recent update guaranteed to be reflected in its pages. It is
    extracted by looking at the archive last LSN before the backup is taken.
    - The purpose of this LSN is to prune runs which are not required during
    restore. If the backup was taken when N runs were available, and during
    restore there are M runs, at most M-N runs will be replayed for each
    segment.
    Restore goes only to last used page ID
    
    - Information is extracted from alloc_cache, which is expected to be
    consistent by the time the device is marked failed. Furthermore, no
    allocations can occur once failed is set, so there are no "lost
    allocations"
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Added test for vol_t::take_backup method
    
    Test generates a backup and uses utility function verifyVolumesEqual to
    varify that logical content of backup and original DB file is the same.
    Changed vol_m to index the volume array by vid
    Implemented checkpointing of restore bitmap
    
    Checkpoints now include the restore bitmap, which tells which segments
    were restored so far. This allows restore to continue where it left of
    after a system crash, instead of restoring all segments from the
    beginning.
    
    (Untested)
    Added functionality to take backups
    
    vol_t now supports take_backup() operation. Its internal state keeps
    track of a path and file descriptor for a backup file currently being
    generated. It instantiates a RestoreMgr and reuses its functionality to
    generate a new backup file instead of a replacement device.
    Simplified vhdr and peristent vol metadata mgmt
    
    - Volume header only has to contain vid and total number of pages; all
    other fields were not necessary.
    
    - Isolated logic to write metadata pges (incl. volume header) so that it
    can be reused for taking backups.
    Added BackupReader class to abstract backup access
    
    Implementations of BackupReader include:
    - DummyBackupReader: no actual backup; just manages an empty buffer for
    the restore workspace, i.e., backup-less restore.
    - BackupOnDemandReader: Reads from the backup one segment at a time, as
    pages are requested (i.e., no prefetching)
    - BackupPrefetcher: manages a "buffer pool" of segments which are
    prefetched from the backup file.
    
    Implemented the interaction between restore and BackupReader, as well as
    the construction of the appropriate reader object depending on sm
    options.
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    New (logged) sx_add_backup operation for volumes
    
    A volume now contains a list of FS paths to be used as backup files.
    These can be added with the vol_m::sx_add_backup method. The operation
    is part of persistent system state and thus it must be logged,
    checkpointed, and recovered. Logging and recovery are done,
    chekpointing will come next.
    Fixed volume remount operation in mark_failed
    
    Isolated methods for initialization of metadata (stnode, bf_fixed, and
    alloc_cache) into their own methods, allowing the related objects to be
    reset during a media failure without explicit remounting and deadlock
    problems.
    
    Also fixed methods that rely on metadata information, so that they wait
    for restore if one is in progress.
    Basic logging and recovery functionality for restore
    
    Implemented log records and their generations as SSX, their REDO
    operations, and required methods in vol_t and RestoreManager.
    Implemented shutdown of volume manager
    
    When destroying ss_m, invoke shutdown on vol_m, which simply relays the
    call to all mounted vol_t. The shutdown procedure is essentially an
    unlogged dismount. If a restore is ongoing and an abrupt flag was not
    set, it should wait for restore to complete.
    Fixed restore bugs
    
    - Releasing latch on requests and marking a segment as restored can only
    be done after segment is written, otherwise readers will proceed and
    likely read garbage.
    - Added ignoreRestore flag to write_many_pages(), otherwise deadlock
    would occur
    Removed some trailing whitespace
    Added option to clear buffer pool during restore
    
    Method vol_t::mark_failed now has a boolean argument which is passed
    down to the remount operation to determine if the pages of the failed
    volume are to be evicted from the buffer pool or not. This is useful for
    testing
    Fixed restore loop and vol_t integration
    
    - Wait for device to be marked failed in restore loop
    - Keep track of previous page in restore loop
    - Added vol_t::remount_from_backup to remount volume when marking as
      failed, thus resetting the metadata (header, store, and alloc pages)
    Added restore support to vol_t
    
    Read and write operations on a volume now check if the device has failed
    before proceeding. If volume war marked as failed, then it interacts
    with the restore manager to request the corresponding pages and wait for
    their complete restoration.
    
    Other updates in this commit:
    - Conditional requestRestore (returns false if copy failed)
    - Export sm options in ss_m
    - Export ArchiveDirectory in LogArchiver
    - Bugfixes on restore manager
    Fixed SSX's and thread safety of volume mgr
    
    - Added spinlock to protect operations on vol_t and vol_m
    - Fixed behavior of SSX -- log only after all operations completed in a
    method
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Implemented logging and recovery of volume ops
    
    Added logrecs with proper REDO and SSX for create, mount, and dismount
    of volumes. Recovery works by simply invoking redo() on them, including
    chkpt_dev_tab_log.
    Updated format of chkpt_dev_tab_t
    
    Now using a vector of strings and storing the next_vid.
    Recovery still needs to be fixed.
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed raw device stuff and unused vhdr fields
    
    The distinction between raw and non-raw volumes does not make much
    sense, because nothing important was really done based on it. Also see
    comments.
    
    Removed fields quota and page_sz from volume header, since these are
    redundant.
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Removed creation time from volume header
    
    It wasn't used for anything and probably will never be in our research
    prototype.
    Page allocation taking only lpid_t as argument
    
    Store number is not require to allocate a page, since it only involes a
    volume and a short page ID (i.e., position of the new page in the volume)
    Fixed REDO of store operations
    
    Store operations always generated log records, which is wrong in case of
    a REDO step. Updated the interface across all classes to include a
    "redo" boolean flag. If set to true, no log record is generated.
    Small fix on log archiver
    
    Made parseLSN a public method, since it is used in loginspect. Also
    removed some comments about certain methods being used only for tests.
    addressed weys code review
    ctimne timestamp for backups and vols, test case not passing
    More bug fixes for Instant Restart milestone 2.
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    page_s -> generic_page
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    alloc_p-> alloc_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Moved latches to sm and fixed test compilation
    Removed sthread_stats
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    sthread_stats is now static thread_local instead of sthread_t member
    Moved latch/mutex stuff out of sthread files
    Got rid of old "plog" stuff
    Revert "Minor fixes to kits scanner and btcursor"
    
    This reverts commit ce06fb17c6b1bfaa32de1f92055798c367893483.
    Minor fixes to kits scanner and btcursor
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed old FUNC macro
    Fixed lock reacquisition with new lock mgr interface
    
    - Lock methods now take only hash value as key and accept three boolean
    flags:
        - Whether to check for conflicts with existing locks
        - Whether to wait if a conflict is detected (i.e., !conditional)
        - Whether to acquire the lock or just check
    - Lock reacquisition during log analysis must ignore any conflicts,
      i.e., it must pass check = false. This wasn't possible before.
    - With these changes, there's now only one lock method in the lock mgr
      and in btree_impl
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed file bf_tree_inline.h
    
    - The compiler should be smart enough to inline functions that can (and
    should) be inlined.
    Whitespace changes
    BTree cursor now supports open-end scans
    
    - Cursor can be opened with just a start condition. Stop condition is
    then set to infimum or supremum depending on the scan direction.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Added store number parameter to B-tree locking
    
    Since store number is not available in the page ID anymore, all B-tree
    locking methods (e.g., _ux_lock_key) must include the store number as
    an additional parameter.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Replaced all occurrences of volid+snum with stid_t
    Fixed page lsn updates and check for modification in btree traversal
    Implemented plog rollback and fixed related bugs (separation between log and clog now complete)
    RAW-style lock manager
    added assertion to detect cursor failure due to bad LSN's; modified tpcc to no longer allow -nolog because it needs to use cursors.
    indentation
    cursor to check refix return code for SPR
    refactoring w_rc_t
    replaced dat_leaf[_ref]
    *_key's -> get_key
    new_search->search, replace search_leaf with search
    renamed w_okvl to ovkl_mode
    Addressed some of the comments
    OKVL implementation first version.
    This version does minimal thing to get OKVL working.
    
    Although it's incomplete in terms of integration into experiments/tests code,
    I separated this as one commit because it concisely contains the "core" of OKVL implementation.
    
    Missing things:
    
    - Experiments/tests folder are tentatively disabled.
    Needs several minor changes in those folders to get them compile with the new lock manager.
    
    - Non-unique index and secondary index is missing.
    These two types of indexes will be implemented later.
    They are related to the benefits of OKVL, but mostly orthogonal in terms of implementation.
    
    - Performance experiments for OKVL paper.
    Ideally we should address the above and then do experiments with really interesting workload.
    However, we should quickly move on to more interesting things, so we will do some quick "hacks"
    to do necessary performance experiments without the features.
    
    - Several other clean-up/optimizations.
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Added latency measurements to transaction commit
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Introducing vol_t::read_many_pages()
    in analogy to vol_t::write_many_page()
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Implemented event log records
    
    - Using simple dummy log records (with category t_status). A helper
    class "sysevent" is used to construct and insert such event log records.
    Added timed log records and stubs for sysevent
    
    - Helper class sysevent_timer created to generate timestamps as the
    number of milliseconds since an epoch (Jan 1, 2015)
    
    - TIMED_LOG_RECORDS added as configuration flag. Log records for which a
    timestamp is desired must then observe this flag. Currently being used
    by restore log records.
    
    - Basic stubs created for log record of type sysevent. At first, only
    tick log record will be implemented as a sysevent.
    Removed most dependencies on sthread_t
    Moved latch/mutex stuff out of sthread files
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Some whitespace changes
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Added comments
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    common cleanup: removed some unused files
    Trying to make smthread_t fully static (huge commit from hell)
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Addressed code review feedback on 78
    Private lock hashtable to quickly check if the lock is already taken
    Replaced uses of ArchiveScanner with new ArchiveScan
    Fixed write elision and decoupled cleaner
    Removed page-img-logrec nonsense from decoupled cleaner
    Decoupled cleaner optimization with page-img log records
    Decoupled cleaner is back!
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Removed readSize parameter from ArchiveScanner::open
    Using shared_ptr to manage archive scans
    Unified classes ArchiveIndex and ArchiveDirectory
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved nested classes out of LogArchiver
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Updated decoupled page cleaner
    Implemented STL allocator using posix_memalign
    
    - Using it in page_cleaner_base so far
    Cleaner refactoring II: common functionality in page_cleaner_base
    
    - Logic common to both cleaners, such as thread management and
    activation, workspace buffer, and buffer manager pointer, has ben placed
    in common abstract class page_cleaner_base.
    - Decoupled cleaner now uses this same base functionality.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Cleaned up CB and page header fields
    Small cleanup on page cleaners
    
    - Removed error_happened and is_dirty_shutdown stuff
    - Using std::atomic instead of lintel and manual fences
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed support for careful write ordering
    
    ... which never really worked and breaks instant restore, so we don't
    really need it.
    Removed uses of vol_t::first_data_pageid & fixed restore
    
    - With new allocation mechanism, there is no need to keep track of the
    first page ID containing "actual data" or treat these pages differently.
    - This makes a big difference for restore, which so far had to restore
    such metadata pages differently; thus, the code has been considerably
    simplified.
    Removing obsolete code and fixing minor bugs
    
    - removed obsolete cleaner options
    - added sm_cleaner_decoupled option
    - bf_tree_cleaner() and page_cleaner_decoupled() now receive a sm_options object, instead of the parameters
    - page_cleaner_decoupled does not receive vol and logArchiver as parameter anymore, it accesses them through smlevel_0
    - removed incorrect assertion from page_cleaner_decoupled (wrong for alloc pages, since they are not directly update in the buffer pool)
    - fixed IF clause in page_cleaner_decoupled for the same reason above
    - in destruct_once(), logArchiver can only be destroyed after bf is shutted down (cleaner need logArchiver)
    Decoupled cleaner only considers redoable log records
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Updated decoupled cleaner to use a single volume
    Fixed compilation errors of last merge
    
    - i.e., updated Lucas' cleaner and checkpointer to work with the new
    single-volume infrastructure
    Fixing deadlock in page cleaner
    Assume the buffer is full of dirty pages.
    We acquire the latches all the way from parent to leaf node.
    Then the cleaner kicks in. Cleans all the pages and flushes them to disk.
    After flushing it tries to mark the cb in the buffer pool as clean, so it has to acquire a latch.
    However, we are still holding the latch in the parent node, ans so cleaner gets stuck.
    We fixed that by making the cleaner try to latch, if it fails we leave the page as it is (dirty)
    We have to archive until durable_lsn, not curr_lsn
    curr_lsn may refer to the skip log record in the end of every log partition.
    If the archiver reaches this log record, it assume it partition is over and will wait for a new partition from now on.
    We decrement the dirty_page count only when the page was indeed dirty
    Activating a cleaner is now only a async signal
    In other words, it does not guarantee that the cleaner was awoken
    Adding in_real_hurry mode to page cleaner
    In case the buffer pool is 75% full of dirty pages and there is no archive file for the cleaner to use, the cleaner forces the log and the archive in order to be able to clean pages.
    Changing cleaner buffer from vector<generic_page> to generic_page*
    Now that vol_t::read_page() requires the buffer to be aligned, we made this change, because it was cumbersome to aling a vector<generic_page>
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding page_cleaner logic and concurrency control
    Adding page_cleaner source files and test files.
    Some assertions and new default values for log archiver
    Fixed ARIES restart with proper alloc & stnode logging
    Setting page tag properly for alloc pages
    Fixed redo of stnode and alloc caches
    
    - Redo should not fix any pages; page image is given in the redo method
    Using normal page updates for alloc_cache
    
    - ... which fixes the append_extent issue and the extent-to-store
    clustering.
    - Also makes the use of "in-memory data structure logging", i.e., the
    method XctLogger::log_page_chain deprecated.
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Updated stnode_cache_t to use normal page fix
    Cleaning up some headers and includes
    
    - Removed SM_SOURCE macro
    Properly logging initialization of stnode_cache
    
    - Log record must be generated when an empty stnode cache is created in
    order to format the stnode page correctly.
    - This fixes some related bugs in some unit tests.
    Fixed XctLogger::log_page_chain
    Fixed stnode_cache logging
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    Fixed flushing of alloc/stnode pages on sm shutdown
    alloc_cache and stnode_page read directly from vol_t
    
    ... instead of fixing page in the buffer pool. This is done so that they
    don't leave a dangling page which is never updated, read, or cleaned.
    Fixing bf_tree_cleaner not flushing alloc and stnode
    
    force_volume() explicitly reads this pages from disk, triggering single page recovery, and then writes them back.
    Fixed allocation management
    
    - Scheme of reserving extent to certain stores was not really working
    properly, causing a bug in which an already allocated page would be free
    after restart and thus reallocated again by another transaction. This
    would result in inconsistencies when traversing.
    - Fixed alloc_cache and stnode_cache to not differentiate among stores.
    Fixed construction of empty stnode cache
    
    - Virgin page is not zeroed, so invalid data would be read
    Fixed some assertion bugs
    
    - PageID 0 is actually a valid one, so cleaner should not assert that
    - sx_append_extent was switched to use sysevent instead, but the ssx
    object was still being created, leaving an open (chained) ssx in the xct
    state, which was causing a nasty bug when interting log records form the
    parent UX.
    Fixed log-based REDO
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Added chkpt_t test and fixed bugs found so far
    Fixed bugs with vol_t and stnode_cache
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Fixed volume remount operation in mark_failed
    
    Isolated methods for initialization of metadata (stnode, bf_fixed, and
    alloc_cache) into their own methods, allowing the related objects to be
    reset during a media failure without explicit remounting and deadlock
    problems.
    
    Also fixed methods that rely on metadata information, so that they wait
    for restore if one is in progress.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Fixed REDO of store operations
    
    Store operations always generated log records, which is wrong in case of
    a REDO step. Updated the interface across all classes to include a
    "redo" boolean flag. If set to true, no log record is generated.
    Fixed logging of store operations
    
    The log record store_operation_log was basically broken because it did
    not include a volume ID (i.e., its page ID was always null). This causes
    any undo/redo operation to fail, because it uses 0 as a volume ID.
    reviewer comments
    fixed concurrency bug where latch was not held while modifying store
    metadata
    minimize includes
    fixed bug where code was incorrectly assuming a store was unallocated
    if it's root pid was 0
    fixed some shore includes
    st_bad -> st_unallocated
    removed some dead fix code
    converting to BOOST_STATIC_ASSERT
    removed some impossible to be false assertions to remove warnings
    pulled up generic page formatting
    accessors from fixable_page_h to generic_page_h
    new class generic_page_h that is the superclass of all page handle classes
    more cleanup
    removed unused t_store_freeing_exts state of store_deleting_t enum
    more cleanup of stnode_page
    removed pragma interface/implementation
    stnode_cache_t now accesses _stnode_t's correctly using a stnode_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
            renamed:    src/sm/stnode_p.cpp -> src/sm/stnode_page.cpp
            renamed:    src/sm/stnode_p.h -> src/sm/stnode_page.h
    stnode_p -> stnode_page_h
    stnode now using generic_page_header
    alloc_p-> alloc_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Decoupled cleaner optimization with page-img log records
    Proper attempt count and cleaner wakeups during eviction
    Logging duration of eviction calls into a file
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Various restart fixes
    Fixed deletion of log_core fetch buffer
    Implemented run filtering based on maxPID
    Added stat la_wasted_read
    Detecting warmup based on hit ratio & other updates
    Various bugfixes
    Removed perl script that generated stats
    New sm_stats_t -- now just an array of enums
    Replaced sm_stats_info_t with sm_stats_t
    
    - One was just an empty wrapper of the other
    Removed htab stats
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Placeholders to implement missing Shore-MT API that is needed to run Shore-kits
    Zero branch from subversion rev 11038
    Compressing btree split logrecs when archiving
    
    - Instead of simply duplicating the logrec on both pids involved, we
    eliminate the redundant information for each pid.
    Removed all code related to btree merge and rebalance
    
    - Iw wasn't used or maintained at all. Furthemore, it was a very
    cubersome implementation -- we ought to re-implement merges like we did
    splits.
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Fixed linker problems with explicit template instantiations
    
    - Not a pretty solution at all -- just a transitional step
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Trying to make smthread_t fully static (huge commit from hell)
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Fixed alignment bug on B-tree split logrec
    Whitespace changes
    Fixed logging and recovery of B-tree split
    
    Serialization of split information (i.e., class bulk_delete_t) was
    completely wrong. Tests were only passing because memory contents were
    being reused, I guess. Implemented proper serialization now.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    Made vid_t a simple typedef and deleted volid_t
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Implemented second chuck of Restart milestone 3 code, including logging lock information in checkpoint, re-acquire locks during backward Log Analysis log scan, and added debug only function to compare acquired locks.
    No test cases or coverage for the new code at this point.
    asyncCommit now true by default
    Added log_inserts stat
    Made cleanee more flexible with attempt-based triggers
    Fixed evict_time dump to count duration per eviction call
    Logging duration of eviction calls into a file
    Print txn. tput directly to a file in ticker thread (no log scans)
    Fixed default value of group commit timer
    Implemented log analysis with mmap (direct fetch)
    
    - also downgraded log_core assertions
    Fixed deletion of log_core fetch buffer
    Direct IO off by default for log and archive
    Updated genarchive command
    Various bugfixes
    Added direct I/O options for log archive and log
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Fixed group commit
    
    - Should not return from flush_daemon_work after current and old epochs
    have been updated
    Simple group commit implementation
    Implemented checkpoint-less no-db mode
    Removed logrec category field
    
    - Category can be derived statically from type, so I removed the field
    in the logrec header and converted get_logrec_cat into a constexpr
    function. The logrec_t::cat() function now calls it using the _type
    field.
    - Removed the undoable_clr stuff, which seemed to be some deprecated
    stuff from old Shore times.
    - Left the byte in the logrec header to tell if logrec is a CLR. I.e.,
    the t_cpsn category flag was the only one that could change at runtime.
    Ideally, it would also not be needed if there is a dedicated CLR logrec
    type which just points to the LSN being undone.
    Got rid of sysevent logger
    
    - System events and alloc/stnode caches now use specialized methods in
    XctLogger.
    - Also renamed (unused) t_status category into t_system.
    Introducing: NoDB mode!
    
    - No db file is maintained and all pages are restored from both recovery
    log and log archive using single-page recovery.
    Removed w_stream stuff
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Goodbye sthread!
    
    - All dependencies to the deleted sthread files have been resolved.
    zapps is compiling and kits benchmarks seem to be working.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Goodbye fileoff_t!
    Removed use of sthread IO from log_core
    Small changes on some assertions
    Fixed log manager destruction
    
    - delete log was not being invoked at SM destruction
    - Fixed shutdown of recycler thread; moved condvar & mutex inside its
    class
    Cleaned up messy calculations of partition_size
    Managing partition_t lifecycle with shared_ptr & latching
    
    - All methods now return shared_ptr, which allows automatic control of
    ownership and destruction of partition_t objects
    - All accesses to the partition_t map now acquire a latch.
    - Removed old partition lock
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Fixed CArray concurrency bug (issue #22)
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Refactoring partition_t & removed peek function
    
    - Peek is only necessary to determine the position of the skip log
      record, but it was too cumbersome. The only use of knowing this
      position (i.e., the partition size) is to determine the last LSN in a
      partition for a backward log scan. For now, we disabled it, but a
      better way to achieve that must be implemented
    - Simplified partition_t object by removing many unnecessary fields and
      methods.
    - prime() method of log_storage also reuses partition_t::read
    Fixed log fetch to only support LSNs up to durable_lsn
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Removed class ErrLog and replaced its uses with std::cerr
    Removed auto_delete stuff
    Removed old FUNC macro
    Fixed backward log scan getting to lsn 1.0
    Unified all truncate/reformat options into single sm_format
    Fixed lock acquisition & other bugs in log fetch buffer
    
    - Partition lock was being acquired earlier than necessary.
    - Fixed "load" of empty fetch buffer (p == 0)
    - Deadlock may occur when calling flush() due to "must_be_durable"
    variable in log_core::fetch -- will fix later by removing flush and
    throwing exception if fetch is beyond current durable_lsn
    Commented out assertion in log_core that fails sometimes
    Implemented new log read buffer for log_core::fetch
    
    - Buffers a certain number of log partitions, starting from the latest
    one backwards.
    - Asynchronous thread loads buffer in chunks of 32MB in reverse
    chronological order.
    - log_core keeps track of LSN range already buffered and get log record
    from buffers in case of a hit.
    - Since a big sequential LSN range is what is buffered, a pair of
    variables suffices and there is no need to track individual log pages
    with a hash table. Given the pattern of log reads during restart
    recovery, this mechanism is also quite effective.
    - Also moved log analysis log record inside init method, so that we
    also count the buffer initialization as startup time in the experiments.
    Moved ticker thread inside log_core class
    
    - New init() method must be called after constructor to fork it
    Implemented new truncate_log method in log_core
    
    - Log truncation is now integrated into log_core, rather than being a
    dirty hack invoked directly on log files by ss_m code
    - Acquires insertion and flush locks and creates a new empty epoch on a new
    partition. Flush daemon then automatically performs actual truncation.
    Fixed option sm_logsize
    
    - Now given in MB rather than KB
    - Removed redundant --logsize in kits
    Removed all stuff related to log reservations
    
    - Delete log_resv class and code related to partition scavenging, log
    warning callbacks, etc.
    Fixing segfault when debugging log_core.cpp
    Debug message was printing *nxt, but for the last one nxt would be null and this would cause segmentation fault.
    Whitespace changes
    Removed apparently invalid calls to log_core::sanity_check
    
    - The sanity check assertion during fetches was failing. However, I
    don't think it's a bug with the log buffer (which is very well tested
    and stressed). Rather, it seems like sanity checks can only be invoked
    when the proper mutexes are held, to avoid invalid racy states.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Refactored log manager to use sm_options
    
    Same thing as done for bf_tree_m on the previous commit, but now for log
    manager classes (log_core, log_common, logbuf_core). This was quite
    tricky to achieve due to the crazy dependencies in log manager
    initialization and the complete lack of reuse in logbuf_core.
    Removed unused hint-based log fetch
    
    Hint-based log fetches were part of Yupu's work on the buffered log
    manager (see logbuf_core.h), which he was not able to finish due to new
    resposibilities at HP Labs. With his permission, I have removed this
    now legacy code.
    Fixed bug on backward log scan
    
    Bugfix in the backward log scan logic, precisely the part that assigned a prev_lsn
    pointer to know from where to fetch the preceding log record. This bug
    was so far undetected because no test case had to scan all the way to
    the beginning of the log file, apparently. The bug appeared only after
    the device manager was removed, currently in the volrefact branch.
    Fixed inline bug on log_core
    Decoupled Aether methods in log_core to enable atomic commit protocol
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Small bugfix on waiting logic of log manager
    Fixed bugs in logbuf_core (tests passing now -- except for TSTAT issues)
    Log refactoring: fixed prime mechanism so logbuf_core can be initialized independently
    Log refactoring: moved common code of log_core and logbuf_core into
    abstract parent class log_common
    Log refactoring: pulled log reservation logic into class log_resv
    Updated/reorganized prime methods in log manager code
    Fixed some of the bugs on logbuf_core after refactoring
    Implemented/fixed backward log scan on log_core
    Fixed small bug on opening partitions during recovery
    Fixed fetch method in log_core
    Fixed some of the bugs resulting from log refactoring
    Reintroduced logbuf_core into new refactored architecture and fixed some compilation bugs
    Log refactoring: pulled out log_storage into its own class
    Log refactoring: made log_core and logbuf_core implementations of log_m
    Moved parts of log_core constructor (logdir scanning) into log_storage.cpp
    Removed redundancy due to LOG_BUFFER switch in log_core.cpp
    Moved log_core methods related to storage into file log_storage.cpp
    Fixed compilation bugs resulting from last merge
    Moved implementation code from log_m to log_core
    removed compiler warnings; added some comments about backward scan
    switch to the new log buffer
    Several bug fixes for 'Instant Restart' milestone 2.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    parameterize carray active slot count
    bug fix on delegated-buffer-release
    slight comment change
    Ported Consolidation Array
    [Logging-Output] Get rid of deferred SSX logging. ReviewBoard 86
    [Shore Remnant] Another Solaris-specific code removed
    backup manager now called from SPR
    SPR dumping feature, new testcase, and bug fix
    Added SPR APIs
    refactoring w_rc_t
    Removed regex package
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Changes:
      - Renamed xct_prev to be xid_prev to match xid.
      - Per Alistair's suggestion, added structures to hold logrec_t common header
        and xid chain header information so that we can use sizeof instead of
        manually calculating the size of the header.
      - Added a simple page chain variable.
      - Still need to handle chains that impact multiple pages (e.g., split and merge).
    Most of the changes required to remove volatile variables from the code,
    plus a few other bits and pieces.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    In preparation for adding _page_prv, added "xct" to:
          logrec.h:    lsn_t               _xct_prv;
          logrec.h:logrec_t::xct_prev() const
          logrec.h:logrec_t::set_xct_prev(const lsn_t &lsn)
          log.h:    bool xct_next(lsn_t& lsn, logrec_t*& r);
    Remove indirection through atomic_templates.h
    Replace membar-*() with atomic_thread_fence()
    Get ELR experiments working again
    
    experiments.h, tpcb.h: Improved debugging messages
    
    experiments_env.h: move log directory away from data device
    
    tpcb_elr.cpp: switch to lintel:ProgramOptions for command line arguments
    
    w_base.h: add support for more useful assertion messages
    
    log_core.cpp: Make error message regarduing unexpected files in the logging directory actually
    understandable, & provide useful suggestion
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Deleted old ArchiveScanner
    Multi-segment restore + using backupLSN as log replay bound
    Small comment
    New optimized archive scanner using MergeInput (mmap only)
    
    - Huge restart and warmup time improvements!
    Extended log archve to use RunFile struct
    
    ... instead of file descriptors
    - This will facilitate the mmap implementation coming soon
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Fixed & optimized log archive with bucket size 1
    
    - Using buckets of size 1 yields 100% lookup accuracy without Bloom
    filters, and index blocks still use less than 0.5% of the run size.
    Fixed several bugs on log archiving
    
    - Run merging now works properly, with the correct initialization of the
    index and correct definition of runLSN  boundaries, taking into account
    the different levels and the potential absence of runs in a certain
    level.
    Implemented run filtering based on maxPID
    Added maxPID filter to log archive runs
    Added direct I/O options for log archive and log
    Fixed closeScan after merge
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Replaced pthread mutex with spinlock in ArchiveIndex
    Renamed RunFileStats to RunId
    Added run recycler thread
    Fixed archive index deadlocks
    Unified classes ArchiveIndex and ArchiveDirectory
    Changed siganture of deleteRuns (minor)
    Fixed archive merging and implemented merger daemon
    Fixed maxLevel tracking in log archive
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Unified construction of ArchiveDirectory and ArchiveIndex
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Replaced boost::regex with std::regex
    Deleted old ArchiveScanner
    Decoupled cleaner is back!
    Updating dirty page table during eviction in nodb mode
    Fixed file closing in archive index
    Fixed deafult value of archiver bucket size
    Initial support for mmap as a new MmapRunScanner
    
    - Relies on the same RunFile infrastructure as RunScanner
    - Not being used for now because RunMerger always uses RunScanner
    - Future commit should add template argument to RunMerger
    - Leaving it like this for now because performance was worse with mmap
    Implemented log analysis with mmap (direct fetch)
    
    - also downgraded log_core assertions
    Extended log archve to use RunFile struct
    
    ... instead of file descriptors
    - This will facilitate the mmap implementation coming soon
    Removed readSize parameter from ArchiveScanner::open
    Added ArchStats command and ArchiveIndex::listRunsNonOverlapping
    Fixed & optimized log archive with bucket size 1
    
    - Using buckets of size 1 yields 100% lookup accuracy without Bloom
    filters, and index blocks still use less than 0.5% of the run size.
    Archiver bucket size is 8 by default
    Direct IO off by default for log and archive
    Fixed several bugs on log archiving
    
    - Run merging now works properly, with the correct initialization of the
    index and correct definition of runLSN  boundaries, taking into account
    the different levels and the potential absence of runs in a certain
    level.
    Implemented run filtering based on maxPID
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Added maxPID filter to log archive runs
    Optimizing log archive writes with smaller critical sections
    
    - closeCurrentRun is a pretty heavy-weight method with I/Os and system
    calls, and we were holding the spinlock exclusively for its entire
    duration
    Correct recovery of dirty pages in nodb mode
    Detecting warmup based on hit ratio & other updates
    Added direct I/O options for log archive and log
    Fixed roundToEndLSN (calls findRun with empty run)
    Fixed closeScan after merge
    Updated stats for log archive and restore
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Replaced pthread mutex with spinlock in ArchiveIndex
    Renamed RunFileStats to RunId
    Added run recycler thread
    Fixed archive index deadlocks
    Unified classes ArchiveIndex and ArchiveDirectory
    Changed siganture of deleteRuns (minor)
    Fixed archive merging and implemented merger daemon
    Fixed maxLevel tracking in log archive
    Fixed truncation with empty log archive runs
    More ArchiveDirectory refactoring
    
    - Updated constructor to get partitions list from log_storage
    - Using a properly constructed skip log record
    - Abstracted skip logrec reservation in BlockAssembly
    Unified construction of ArchiveDirectory and ArchiveIndex
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Renamed logrec type page_evict to update_emlsn
    Removed deprecated log records
    
    - chkpt_end, chkpt_*_tab, xct_group_end, xct_freeing_space
    Implemented page-img compression for non-btree pages
    Fixed compilation errors in Release mode
    Implemented multi-level log archive
    Removed log_spr.{h,cpp}
    Moved definitions of logrec "support" classes
    
    - Having defs in their own header eliminates the need for explicit
    template instantiations. It's also another step towards cleaning up the
    logging infrastructure.
    Implemented alternative log fetches using mmap
    
    - They perform much better, without the need for log fetch buffers
    Chkpt using new block-wise BackwardLogScanner
    Cleaning up some compiler warnings
    Removed more headers, fixing their previous uses
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Goodbye fileoff_t!
    Removed use of sthread IO from partition_t
    Cleaned up messy calculations of partition_size
    Added best-effort partition recycling mechanism
    
    - Support for sm_log_max_partitions options, which limits the number of
    partition files in the log directory. At each partition creation, old
    partitions are deleted proactively. If the limit is reached, a forced
    deletion is attempted, but it only works if the min active LSN collected
    on the last checkpoint allow it -- hence the best-effort approach.
    - A true recycling mechanism is only possible with log reservations,
    which we removed because they were messy and not fully effective
    (required "fudge factors").
    Changed log fetch mechanism to copy directly into caller's buffer
    
    - Internal read buffer used for alignment is now inside each partition_t
    object. Just like with the partition lock in log_core, a latch was
    introduced so that readers on the same partition serialize. The method
    release_read() must be called when caller has copied the fetched log
    records.
    - Also changed the buffer priming mechanism, which is simpler now
    because it reuses the partition_t::read method
    - Also adapted SPR mechanism, which must read into a buffer of at least
    BLOCK_SIZE. It now uses an array of offsets within the buffer to locate
    individual log records to be replayed.
    Fixed partition_t::scan_for_size
    
    - Last two blocks of file must be scanned byte by byte
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Determining durable_lsn at startup using a backward scan
    
    - Before performing log analysis, the current log file must be
    initialized by determining the last valid log record in it. This used to
    be in the peek() method, but it used the chk file -- which was removed
    recently. This means that a full forward scan was required. New
    mechanism scans from the end of the file backwards until a vlaid log
    record is found.
    Refactoring partition_t & removed peek function
    
    - Peek is only necessary to determine the position of the skip log
      record, but it was too cumbersome. The only use of knowing this
      position (i.e., the partition size) is to determine the last LSN in a
      partition for a backward log scan. For now, we disabled it, but a
      better way to achieve that must be implemented
    - Simplified partition_t object by removing many unnecessary fields and
      methods.
    - prime() method of log_storage also reuses partition_t::read
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed master_lsn and min_rec_lsn from log
    
    - Master LSN is not needed anymore because checkpoint and log analysis
    use a backward log scan.
    - Min rec LSN is used fro log partition recycling, and it can be
    extracted from a checkpoint (recycling not implemented yet)
    - The disadvantage now is that when doing partition_t::peek, we must
    always start in the beginning of the file, without any hint of where the
    skip LSN might be -- this will be fixed/implemented soon.
    Removed restricion of 8 log partitions in log_storage
    
    - partition_t objects are now managed in a map<partition_number_t,
    partition*> instead of a fixed array of size 8
    - All available partitions are loaded into this map at log_storage
    construction time
    - Removed all uses of partition_index_t
    - User specifies size of a partition instead of total log size
    - Current downside: no support for recycling old partitions based on
    min_rec_lsn; and also no support for specifying maximum limit of log
    device -- this will be fixed soon!
    Removed class ErrLog and replaced its uses with std::cerr
    Removed auto_delete stuff
    Removed old FUNC macro
    Fixed problem of short IO when peeking a log file
    
    - If last write was interrupted, peek method must tolerate a short IO
    error, since we may not be able to read a whole log page
    Fixed bug with overflow on partition_t and some cleanup
    
    - File offset must be 64 bits
    - Added assertions to restart REDO
    - Cleaned up some restart code
    Updated debug msgs in partition.cpp and backup_reader.cpp
    Whitespace changes
    Updated I/O layer for O_DIRECT and error checking
    
    - Flag OPEN_RAW renamed to OPEN_DIRECT
    - Methods of sdisk_unix.cpp now check for error using the same macro,
    which prints the kernel error code as well (errno).
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Fixed bug on backward log scan
    
    Bugfix in the backward log scan logic, precisely the part that assigned a prev_lsn
    pointer to know from where to fetch the preceding log record. This bug
    was so far undetected because no test case had to scan all the way to
    the beginning of the log file, apparently. The bug appeared only after
    the device manager was removed, currently in the volrefact branch.
    Changed debug message mechanism to work with debug flags (like old Shore-MT)
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Log refactoring: fixed prime mechanism so logbuf_core can be initialized independently
    Updated/reorganized prime methods in log manager code
    Implemented/fixed backward log scan on log_core
    Fixed fetch method in log_core
    Reintroduced logbuf_core into new refactored architecture and fixed some compilation bugs
    Log refactoring: pulled out log_storage into its own class
    Log refactoring: made log_core and logbuf_core implementations of log_m
    switch to the new log buffer
    slight comment change
    refactoring w_rc_t
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Modify delay loop to autocalibrate for somewhat innaccurate timers.
    Added an optional artificial delay after the log is flushed (default zero)
    fixed test_intent_lock so retries when gets a timeout
    Zero branch from subversion rev 11038
    Added pinned_for_restore field to bf_tree_cb_t
    Added small useful functions to bf_tree and fixable_page_h
    Fixed ARIES restart with proper alloc & stnode logging
    Setting page tag properly for alloc pages
    Various fixes to traditional ARIES restart
    Correct recovery of dirty pages in nodb mode
    Updated page-image compression to use log volume
    
    ...instead of number of log records
    Added page-image compression
    
    - Generate a page_img_format log record for every N updates on a page.
    This increses log volume but reduces the length of the per-page REDO
    chain during both restart and restore recovery. It's also very useful in
    nodb mode in the page fetch operation.
    Added logrec flags for cpsn and root_page
    
    - Also setting the flags properly in xct_logger
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    bf_tree cleanup: removed unused methods and flags
    Added evict argument to unfix() + bugfix on alloc/stnode
    
    - Allocation and stnode pages now use bufferpool fix call to load their
    pages. This fixes a recovery bug: since REDO leaves the restored
    page in the buffer pool, fix call is required in the constructors of
    alloc and stnode caches.
    - To avoid leaving an out-of-date page lingering in the buffer pool,
    we use an unfix call which evicts the page.
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed unused and unecessary header files
    Big restart cleanup/refactoring/fixing
    
    - Adapted _fix_nonswizzled for more general usage
    - Removed all code related to installing volumes in buffer pool and
    preloading root pages. These are loaded on demand by fix_root, which now
    simply calls the more general _fix_nonswizzled
    - Cleaned up SPR methods to not read a page and not use backup
    - Fixed initialization and persistence of alloc and stnode caches
        - Constructor simply uses fix to rebuild caches from DB pages
        - Fixed per-page chains using custom sysevent logging; this means
        that propagation and single-page recovery are now working as
        expected
        - Fixed redo methods, which should only update the page image and
        not the in-memory decoupled structures
    - Small refactoring on restart workflow: removed restart() method and
    use simpler log analysis. Also deleted _do_restart in sm.cpp
    - Some parts of the code relied on testing whether a log record has a
    non-null pid. Since we implemented extent-based allocation, the pid 0
    refers to a valid page and must be treated like any other. In order to
    distuinguish system transactions that do not reflect changes on any
    page, but only to system state, e.g., restore_begin, we need a flag
    for "pageless" log records.
    - Little hack on log_storage initialization to deal with the lack of a
    min_chkpt_rec_lsn on decoupled infrastructure.
    - Removed code that determined if a checkpoint was "valid" before taking
    it -- proper concurrency control should be enough.
    - Removed some of the legacy "in-memmory" code in bf_tree_m.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Restart cleanup [part 2]
    
    - Removed flags from buffer control blocks: _in_doubt and
    _recovery_access
    - Removed global LSN variables (redo_, commit_, last_)
    - Cleaned up restart methods
    - Restart still not working. Moving towards relying on SPR only, using
    data collected on log analysis to just keep track of restart progress
    and redo pages asynchronously (schedules).
    Restart cleanup [part 1]
    
    - Removed the multitude of restart modes. From now on, a single restart
    pipeline will be executed with small variations depending on options
    set.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Reverted method fixable_page_h::setup_for_restore
    
    Previous implementation would initialize page with metadata from the log
    record, but this should not be required, because correct log replay must
    guarantee that the page state is compatible to what each log record
    expects. Method now only sets the page pointer (_pp) of the handle.
    Updated setup_for_restore on fixable_page_h
    
    Passing whole log record to setup_for_restore in order to initialize
    all attributes of the page correctly.
    
    NOTE: This shouldn't actually be necessary, since the page state should
    have been already correct from previous redo operations. Even in the
    backup-less case, proper formatting and initialization should ensure the
    correct state. This hack was required to work with B-tree splits and
    merges, but it still seems to be broken. This commit may get removed in
    the future, once I understand initialization and splits/merges better.
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Updated handling of CLSN field of pages
    Some cleanup and also enable some M4 mix mode code path.
    Modified test code so it is easier to merge with changed code from master.
    Added different recovery modes for M2: minimum logging and full logging.
    Added a few more test cases in test_concurrent_restart.cpp
    A few bug fixes and added more comments in code.
    More fixes in 'Instant Restart' milestone 2 code.
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    Check in the initial implementation of REDO and UNDO. Also added startup() and shutdown() methods to ss_m object.
    log_page_evict to update parent page LSN without EX latch
    complex testcases for SPR and bug fixes
    Incremental check-in for the work in Checkpoint and Log Analysis.
    hierarchical eviction in bufferpool
    Incremental check-in to local repository for changes in checkpoint and Log Analysis (Recovery)
    forgot comment on what latch mode fixing a non-buffer pool page gives you
    changed fixable_page_h to use a separate _bufferpool_managed flag
    instead of using the convention that _mode = NL for non-buffer pool
    managed pages; this allows us to use latching mode EX with non-buffer
    pool managed pages.
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    fixing up comments, related assertions
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    crabbing from Q is now handled by fixable_page_t correctly
    changed upgrade_latch_conditional to allow upgrading from Q to S/X
    new function, change possible after fix
    Added subtest cases to check that it works; currently failing as expected
    (no QSX latch yet)
    added basic Q ticket plumbing
    added a temporary static global variable for using Q mode instead of S mode
    made rest of routines do reasonable things with pages in Q mode
    added a new error code for Q mode failing
    re-flowed some comments to use new line limit
    made fix routines handle Q mode
    cleanup includes
    minor code cleanup
    un-inlining functions in page_bf_inline.h
    cleaned up documentation of assignment operator for fixable_page_h
    cleanup includes, friends
    comment sections
    move last of buffer manager's direct dependence on btree_page_h
    Beginning to install child slot interface between fixable_page_h and the
    buffer manager
    miscellaneous code cleanup
    mostly code reformatting
    Fixing includes
    changes from Alistair review feedback
    cleaned up generic page header's fields
    pulled down some more B-tree fields
    removed unused private store page field
    moved down two B-tree fields
    accessors from fixable_page_h to generic_page_h
    new class generic_page_h that is the superclass of all page handle classes
    renamed:    src/sm/generic_page_h.cpp -> src/sm/fixable_page_h.cpp
    renamed:    src/sm/generic_page_h.h -> src/sm/fixable_page_h.h
    generic_page_h -> fixable_page_h
    removed/changed incorrect/unneeded references to generic_page_h
    removed use of generic page header and data size constants
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    fixed extremely dubious casting between page handles by introducing a
    new class, borrowed_btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
    page_p -> generic_page_h
    removed pragma interface/implementation
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    stnode_p -> stnode_page_h
    alloc_p-> alloc_page_h
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Removed a declared method (insert_slot) that had no definition or use.
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    Fix build on centos (not sure why it broke)
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Trying to make smthread_t fully static (huge commit from hell)
    Removed SM level 1
    Addressed code review feedback on 78
    Added comment
    Private lock hashtable to quickly check if the lock is already taken
    Follow-up cleanings
    OKVL terminology change and optimizations
    Remove pragma implementation and pragma interface (fixing JIRA ZERO-138)
    Many small changes to eliminate compiler warnings. Work-in-progress.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    Updated references to tickets to give ticket name and both jira and trac numbers.
    new function, lock_m::give_permission_to_violate, that a transaction may
    use to give permission to other transactions to violate its locks.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Replaced uses of ArchiveScanner with new ArchiveScan
    Commented archive activation only after warmup
    Some assertions and new default values for log archiver
    Log archiver starting on first available log partition
    Log archiver only runs if buffer pool is warmed up
    ArchiveScan optimizations
    
    - SprIterator now has ArchiveScan as member rather than allocate it on
    the heap
    - LogArchiver now manages ArchiveIndex using shared_ptr
    - ArchiveScan does not heapify its inputs if there is only one PID to
    fetch; inputs can be consumed in sequence from first to last.
    Fixed recovery in bf_tree_m with nodb==false
    Fixed several bugs on log archiving
    
    - Run merging now works properly, with the correct initialization of the
    index and correct definition of runLSN  boundaries, taking into account
    the different levels and the potential absence of runs in a certain
    level.
    Updated log archive truncation and run deletion
    
    - Online run deletion is hard to implement; added comments about that.
    - Using just offline deletion during truncation for now -- this had to be
    fixed.
    Removed virtual methods from archiver workspace memory manager
    Added maxPID filter to log archive runs
    Correct recovery of dirty pages in nodb mode
    Log archive flush must also flush log_core
    Fixed log archiver and consumer
    
    - Archiver should join after consumer adn before block assembler
    - Consumer's next method should call nextBlock on demand
    Forgot to remove ERROUT's
    Fixed log archiver shutdown
    
    - Reader thread now uses worker_thread
    - Shutting down consumer first so that we can exit before current log
    archive activation loop finishes
    Fixed BlockAssembly init in mergeruns
    Decoupled BlockAssembly from log_core with compression option
    Compressing btree split logrecs when archiving
    
    - Instead of simply duplicating the logrec on both pids involved, we
    eliminate the redundant information for each pid.
    Added a bunch of assertions to log archiver code
    
    - Also wrote new mem_mgmt test
    Fixed bug on page image compression
    Added cache for open files in ArchiveIndex
    
    - This should reduce the overhead of opening and closing files in log archive index probes
    - TODO keep opened files when pin count is zero and use some policy to
    close unused files
    Renamed RunFileStats to RunId
    Unified classes ArchiveIndex and ArchiveDirectory
    Fixed archive merging and implemented merger daemon
    Fixed truncation with empty log archive runs
    Unified construction of ArchiveDirectory and ArchiveIndex
    Moved log archive classes into new files
    
    - Chopping up the huge logarchiver.cpp
    Moved nested classes out of LogArchiver
    Fixed ArchiveDirectory block appends for multiple levels
    Fixed test_restore
    Removed buggy and deprecated archive mode without buckets
    (Re)Implemented log archive run merging
    Fixed multi-level run management
    Cleaning up some compiler warnings
    Implemented multi-level log archive
    Added level number to log archive run file name
    Removed more headers, fixing their previous uses
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Removed most dependencies on sthread_t
    Trying to make smthread_t fully static (huge commit from hell)
    Removed sthread priorities
    Goodbye fileoff_t!
    Removed use of sthread IO from logarchiver.cpp
    Log archiver bugfix
    
    - Initialization was completely ignoring highestLSN
    Assorted bugfixes to restore code
    Removed option sm_archive_block_size
    
    - Log archived currently only supports a fixed block size (for some
    reason I can't remember), so it does not make sense to offer such
    option. Removing it to avoid any future frustrations.
    Fixed log archive truncation
    
    - Regex must use perl mode instead of basic
    - isLogTooSlow condition expanded to include case of crossing log file
    borders (which is expected on truncation)
    Options to truncate log archive and run benchmark for a given log volume
    Fixed log truncation
    
    - Now it works properly and chkpt files as well as log archive runs are
    cleaned correctly.
    Recycling chkpt files regardless of log-file recycling
    Using boost filesystem in log archiver directory
    Supporting reformat flag in log archiver
    
    - Log folder is emptied using boost filesystem when reformat==true
    Restore: removed faulty assertion and changed default arguments
    Added assertion to existing bug
    Fixed log archiver run counting
    
    - Using centralized typedef run_number_t, which is now 32 bits to avoid
    any overflow or cast problems
    Kits: removed redundant options logdir, archdir, dbfile
    
    - Options are given directly as --sm_* arguments and KitsCommand doesn't
    have to worry about them
    Log archiver ignores any log record with is_redo() == false
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Refactored log_storage constructor and partition management
    
    - Constructor greatly simplified with boost::filesystem
    - Partitions managed in a simpler way, where all active partitions are
    found with get_partition and open calls are invoked directly on the
    partition_t object.
    - Updated log path functions to use string & boost instead of char*
    - Truncation of last partition moved inside partition_t as a static
    method
    - General decluttering & clean-up
    Removed class ErrLog and replaced its uses with std::cerr
    Removed auto_delete stuff
    Removed size arguments from kits_cmd
    
    - All size arguments passed directly as sm_* options, most of which in
    MB
    Added log records to log archive's ignore list
    
    - And enhanced some debug messages
    Fixing findRun(lsn_t) bug
    if the given lsn is equal or greater than the maximum archived lsn, it was returning the index of the last run. Now it returns an invalid index (aka lastFinished + 1). The caller must consider this case.
    Fixing some bugs related to log archiver.
    1. In pushIntoHeap(), if the push fails, it would verify if the heap is empty after selection(). This check should be made before the call to selection()
    2. In emptyHeapAndCheck(), it would only compare log records based on the shpid. A log record t_format_a_page would have lpid 0.0 and would be considered to be the same as another log record with lpid 1.0, for example.
    Adding ignore flag to LogConsumer()
    LogConsumer constructor was initializing an ignore-list of log records to be ignored during the log scan.
    While this behavior is default for the LogArchiver, it is not desired if we are going to use the LogConsumer to scan the log for log_analysis _and/or chkpt.
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Eliminated multseg restore techniques
    
    - New "preemptive" technique is much simpler and achieves the same goal
    - Updated log archive probes to not use min/max read and segment size
    Implemented preemptive adaptive restore technique
    
    - Every segment restore by default opens a log archive scan until EOF,
    and multiple adjacent segments are restored until a new request pops up
    in the scheduler.
    - The goal is to restore one segment at a time during the initial phase
    of restore, prioritizing latency. As the working set is restored in the
    buffer, the algorithm then behaves more like single-pass restore,
    achieving higher bandwidth.
    - This simple and effective technique should replace our complicated
    multiple-segment technique. Thanks to Goetz for suggesting it.
    Assorted fixes and cleanups
    
    - Fixed doMerge function to process whole input archive
    - Deleted old code
    - Added W_DO to mount redo
    Fixed block reads with varying LA read size
    Fixed short I/O problem on multiple-segment restore
    Updated run scanner to use arbitrary read sizes
    
    - Now that log archive runs contain contiguous log records (like
    partitions in the transaction log), we are not restricted to reading the
    log archive using the block size that was used when it was built.
    - This give much better I/O performance, since we can actually control
    the read size on the log archive using the maxReadSize option; instead
    of only controlling the number of segments to restore at once.
    Updated backup prefetcher
    
    - Prefetching now controlled by RestoreMgr instead of scheduler
    - Changed how prefetching is performed in the restore logic. Got simpler
    code and better performance
    First implementation of asynchronous merge daemon
    
    - Currently only supporting a very restrictive use case of the restore
    experiments, mostly due to the complex and unflexible coordination
    between the various log archive components (directory, block assembly,
    and writer thread)
    Tiny bugfix on parseLSN
    
    - Delimiter character should be searched in reverse order, because given
    log archive path may contain it in directory names.
    New log archive file format
    
    - Log records are not stored contiguously in runs, with a skip log
    record determining the EOF. I.e., the same format as log files. The only
    difference is that index blocks are stored at the end.
    - The old format kept log record in blocks in the same format as
    produced by BlockAssembly. However, the format is not beneficial for
    scans on the log archive, since unless opening a file at the exact
    beginning of a block, I/O sizes will be smaller than a block. The block
    format was maintained for index blocks, however.
    - The log archive generation methods (mostly in the WriterThread) had to
    be changed. For RunScanner, a LogScanner object is required to parse the
    continuous stream of log records.
    Fixed small bug on restore
    Changed log archive index bucket entries
    
    - Instead of referring to the firt PID ocurring in each bucket, log
    archive index entries now contain the actual bucket boundaries, even if
    they don't exist in the file.
    - This allows restore scans to open at the correct point and not earlier
    when opening on a segment boundary that matches the bucket boundary.
    Removed old methods probeFirst and probeNext
    Fixed log archive scan to use correct segment borders
    
    - For the first segment which overlaps with metadata, special treatment
    is required on the restore part. In a previous commit, I made it ignore
    the first pages by opening the scan directly on the first data pid.
    However, this broke the scan because the end of the scan (previously
    given by segmentSize) was not adjusted accordingly.
    - Other than adjusting both the begin and end boundaries, these must be
    independent from the "segment size" parameter of the scan, which is used
    only to expand the length of the scan into multiple segments. To fix
    that, I reintroduced the endPID argument. Now, startPid-endPid tell
    where the scan must begin and finish. If multiple-segment scanning is
    desired, then the segmentSize parameter tells which valid values can be
    assumed by endPID.
    Changed output of MergeHeapEntry for better readability
    Fixed race condition in ArchiveDirectory
    
    - For a brief period of time, writer thread closed the current run
    before it opens a new one. If during this time window, a flush request
    (from archiver thread) tries to close the current run, it will throw a
    file not found error.
    - Fixed by implementing an atomic closeCurrentRun method which uses a
    mutex and closes and opens a new run in the same method.
    New archive index probe method and multiple-segment restore
    
    - Whole probing/scanning mechanism of log archive was updated and is
    much simpler now, also supporting multiple-segment restore.
    - Open method now takes a start pid and the number of page ids to be
    scanned (segment size), as well as a min and a max read size.
    - Probe method returns a list of probe result objects, which simply
    contain a start offset and an end page ID on which to stop scanning.
    In order to achive reads greater than the given min size, the end pid
    is adjusted based on neighboring segments, but going no further than the
    max read size.
    - After initial probe, open method readjusts endPid of all run scanners
    based on the maximum value collected.
    - Restore manager was also updated to work with the new mechanism.
    Fixed generation of archive index buckets
    
    - Bucket list must be initialized before producing blocks, in order to
    keep track of correct offsets and page IDs. Moved "run switch" logic
    from finish to start method of BlockAssembly to fix it.
    Fixed bucket tracking on log archive index
    
    - The variable bucket mode, where index entries contain fixed ranges of
    page id with variable amount of log records in it, was not being computed
    correctly. Fixed now.
    New multiple-segment restore scheme
    
    - Mechanism is now incorporated into the log archive scan, which
    recieves minReadSize and maxReadSize as parameters. When probing on
    eachr run, the end of the scan is then adjusted so that the read size
    fits within the given boundaries.
    Removed multiseg restore code (new one coming up)
    Fixed buffer overflow on parseLSN
    
    - It turns out that low part of LSN has 48 bytes, so we need 15
    characters to parse it.
    Fixed bug on log archiver
    
    - Global lastLSN variable, which was kept in the archiver index to
    determine the filename of the last run, was subject to a race condition
    in which a concurrent probe on the last finished run could get the wrong
    LSN boundaries. Added redundant lastLSN field to RunInfo objects to fix.
    Fixed rare bug with log archiver
    
    - Sometimes the reader gets an LSN with the low part as zero (i.e.,
    beginning of partition), but it starts reading before the log manager
    actually creates the file and inserts log records. To avoid that, the
    archiver is not activated when it has zero in the low LSN.
    Extended LA index code for future improvements
    
    - Extensions below were implemented, but they don't change the behavior
    of restore or archiving yet. I am hoping they will facilitate future
    improvements that I'm planning.
    - Opening an archive scan actually creates a list of ProbeResult objects
    before constructing a heap. This will allow us to adjust the number of
    segments to restore before opening any run file, based solely on index
    information.
    - For the same reasons as above, also extended ProbeResult to include
    the offset and PID of the end of the scan, and extended the probeInRun
    method accordingly.
    - Binary search in findEntry now returns the index of the entry on the
    entry array, instead of the offset directly.
    - Field ioUnit was added to ArchiveScanner, but it's not used so far.
    Add skip log record to the end of log archive blocks
    
    - Instead of relying on the actual block size on the block header, the
    scanner now stops when it reaches a skip log record.
    - This mechanism provides a cleaner way to open a scan on an arbitrary
    file offset and scan forward from there, without having to zero-out
    blocks.
    Fixed bug on variable-bucket scanner
    
    - Properly zeroing block when read size is already a multiple of the IO
    alignment
    Using stat to count total volume of archive log read
    
    - Instead of counting the number of reads, we now accumulate the size of
    each read in bytes.
    Fixed small bug on archive scanner
    
    - Return zero as the run scanner offset in case the PID is null or lower
    than the PID in the first index entry.
    Fixed small bugs with empty runs
    Removed obsolete ArchiveMerger class
    Implemented variable-bucket log archive index
    
    - This new index is used if a parameter bucketSize > 0 is passed to the
    cosntructor. If it works really well we may make it the default and
    remove code exclusive to the "old" index.
    - Instead of keeping entries in the index with offsets in fixed
    increments of the block size and the first PID which happens to occur in
    each block (i.e., just like a B-tree), this new index records the first
    page ID of each logical "bucket" and whatever arbitrary offset this page
    ID occurs in the file. A bucket is a set of page IDs belonging to fixed
    logical ranges (e.g., page IDs 0-99, then 100-199, and so on). For use
    with instant restore, a bucket should be the same size of a segment.
    - The advantage of the new index is that only the amount of log required
    to restore a segment is read from the log archive. In the old
    implementation, segments with few updates caused reads of a whole block
    (e.g., 1MB) where actually only a few bytes where used. The
    multiple-segment technique implemented in an earlier commit did not work
    very well for many runs. We hope this new index will achieve the goal of
    better read efficiency reagrdless of the number of runs.
    - In essence, this index is superior because it allows us to jump
    directly to the offset of a segment.
    Fixed bug on multiple-segment restore
    
    - End PID of log scan must be set before advancing the heap to the first
    PID
    - Added a bunch of debug messages which helped debugging this error.
    Fixed bug on LSN parsing
    
    - Buffer was not initialized
    Reuse one log archive scan to restore multiple segments
    
    - Implemented a technique taht checks when opening a scan if multiple
    segments can be restored based on the page IDs contained in the first
    block read from each run.
    - The technique required a new restoreSegment method, which is more
    generic and can now be reused for the single-pass loop and, later, for a
    generic log replay class.
    Fixed series of bugs on log archiver
    
    - Mostly related to log truncation, which creates a lot of special cases
    - Fixing these bugs was a painful process, so in retrospect, such
    truncation features were probably not very useful.
    Fixed sharp backup taking
    
    - To make sure that a sharp backup is taken from the current tail of the
    recovery log, a stronger version of log archive flushing was
    implemented, in which not only we wait for all log records to be
    consumed and written out to archive blocks, but also forcibly close the
    currenr run and create a new one. This also makes sure that the new run
    has the requested LSN as its upper boundary.
    Fixed logrec duplication in log archiver
    
    - Multi-page log records such as btree_split neeed to be duplicated in
    the log archiver so that they can be reached when retoring either page
    independently.
    - The previous code had a bug in which the duplicated copy could end up
    in a different run, meaning that its LSN would be below the low boundary
    of the new run.
    - To fix that, duplication is now handled directly in the ArchiverHeap
    code, and we guarantee that both log records are added as an indivisible
    unit to the same run.
    Fixed small bug on log archiver
    
    - Unsigned comparison was resulting in lastFinished not being set
    correctly
    Fixed bug with empry runs on archive index
    
    - When serializing run info object, we must first check if it isn't an
    empty run. This is not required for normal the archiving process, but it
    can occur on log truncation, which calls closeCurrentRun directly from
    sm.cpp with an empty run.
    Bugfixes and new timers on log archiver and restore
    
    - Added some tstat timers to log archiver to analyze its performance.
    - Added missing W_DO/W_COERCE wrappers to some method invocations.
    Restore now using direct I/O for reads
    
    - Reading backup segments and log archive blocks is now performed with
    direct I/O (O_DIRECT). This decision is not driven by performance but by
    the simple fact that we want our measurements to account for real I/O
    delays. Otherwise, it is likely that most reads will be served from the
    kernel page cache.
    Pruning log archive probes based on first PID in runs
    
    - If there is a correlation between PID and LSN, which is typical in
      OLTP workloads, then recent runs most likely only apply to the highest
      segments. In that case, the last PID in the segment will be lower than
      the first PID in the run.
    - Combined with the last commit, this shoud provide effective pruning
      for typical workloads such as TPC-C.
    Added some stats to investigate restore bandwidth
    
    - Counting the amount of time spent in each phase of the restore loop:
    read backup, replay, and write
    - Other helpful stats such as number of log archive reads and backup
    reads
    Fixed small bug on log archiver
    
    - When reading a skip log record which causes a truncation, log scanner
    must be reset properly.
    Small fix on archiver
    
    - join invocation in shutdown must issue a memory fence
    - Removed some unused code and outdated comments
    Fixed embarassing bug on log archiver
    
    - The end boundary of a run file was being generated as simply the LSN
    of the last log record in the last block, which makes absolutely no
    sense. The boundary should be the *maximum* LSN within that run. To fix
    that, I changed the BlockAssembly behavior to keep track of the max LSN
    in each block (instead of the last), and the WriterThread to keep track
    of the maxLSN among all blocks of the current run.
    
    (I guess the bug hasn't been detected yet because all my tests used ony
    one run)
    Fixed small bugs on log archiver
    
    - Correctly consuming from end of a partition to the next one (blockPos
    must be reset to zero and we must verify that log scanner is not in the
    middle of a truncated log record)
    - Log archiver thread must shutdown and join before consumer and block
    assembly shutdown.
    Fixed log archiver and log truncation to work together
    
    - A truncated log introduces a bunch of special conditions in the log
    archiving process:
      - It must generate empty runs to account for the hole beteen the
      truncated LSN and the next partition.
      - It must tolerate empty runs.
      - It must support manually unsetting the eager flag and activating
      until an LSN larger than the current log LSN.
    
    These and other tricks were implemented to make log truncation work with
    log archiving and vice-versa.
    Changes to be amended
    Added stats for log archiver activations
    Redesigned restore/archiver synchronization mechanism
    
    - When a volume is marked as failure, restore now simply invokes a flush
    request (synchronously), which causes the whole heap to be written out
    into run files. This must be done after the failure LSN has been
    consumed.
    - The previous mechanism was wrong because we cannot simply start a new
    run at will. This causes all following runs to be smaller than the
    workspace capacity.
    - This also has the implication that the log archiver does not need to
    treat "restore_begin" log records differently. In fact, they can be
    ignored now.
    - The flushing mechanism itself is also simpler now. We simply consume
    the whole heap and wait until the write buffer is empty -- no need to
    shutdown the writer thread.
    - Furthermore, the logic of the `run()` method in the log archiver was
    broken down into smaller, self-contained methods, making the code more
    readable and modular.
    Implemented mechanism to read only whole blocks in archiver
    
    - When the option to read only whole blocks is set, the log archiver
    only activates if there is at least one block worth of log to be read.
    Furthermore, it adjusts the endLSN parameter passed to the consumer so
    that it is always at a block boundary, such that only whole blocks are
    read instead of partial ones.
    - This eliminates the assumption that endLSN is always a valid log
    record. Thus, the consumer and scanner had to be adapted to handle that
    case. The scanner now returns a length parameter, which helps the
    consumer decide whether it should request a new block or not.
    - However, there are cases where the log is either growing too slow or
    it has stopped altogether. To avoid the log archiver getting stuck
    because it only reads whole blocks, a wait mechanism was implemented. If
    the activation window is too small, the archiver waits a certain grace
    period. If after that, the current durable_lsn of the log is still equal
    than the current activation's endLSN, then the log is growing too slow,
    and the consumer proceeds with partial blocks. This happens at least at
    the end of an experiment, where transactions have finished and we are
    waiting for the archiver to complete.
    - Added a stat to count how often this "log too slow" situation
    happens. The grace period, which is an SM option, should be increased if
    it happens too often.
    Log archiver does notactivate for small log ranges
    
    - Activation only occurs if the LSN range for which the log will be
    processed is at least one block long. Otherwise the device bandwidth is
    wasted and there is too much activation overhead compared to the amount
    of log actually sorted.
    Fixed bugs on log archiver consumer
    
    Previous mechanism was not working when the (fake) skip log record
    spanned two neighboring blocks. Changed the whole mechanism to not rely
    on fake skip log records but solely on nextLSN, which is what I should
    have implemented from the start.
    
    - Reader does not insert fake skip; it simply stops readin when the
    endLSN is contained in the block just read (or if it's the first byte of
    the next block).
    - LogScanner does not treat skip log record in any special way. It is up
    to the caller to see that it got a skip and stop invoking the scanner on
    the same block.
    - Also fixed nasty little bug when a log record ignored by the log
    scanner fits exactly at the end of a block (such that toSkip ==
    remaining in the code)
    Fixed activation mechanism to avoid lost signal
    
    - ArchiverControl was sending the activation signal inside an if-clause
    which might have been false. Removed the clause so that signal is always
    sent. However, signal may still be lost if thread is not listening.
    Holding on that problem for now to see if it actually happens.
    Fixed bug on btree split log record
    
    - Prev pointers were switched (prev2 pointing to previous update on
    page1 and vice-versa). Fixed constructor method and its invocaiton to
    produce the correct assignment.
    
    - Aldo fixed log archiver to correctly set previous pointer on
    duplicated multi-page logrec.
    Changed selection behavior on log archiver
    
    - Instead of consuming a single block, selection keeps removing from
    heap until there is space to insert new records or the heap is empty.
    Restore now waits for required logrecs to be archived
    
    - Log archiver now supports a flush mechanism, by which threads can
    request that all log records up to a certain LSN be processed and
    persisted.
    - Restore manager uses this mechanism to wait until all og records up to
    the media failure (i.e., the LSN of restore_begin) have been archived.
    Only then can correct restore be guaranteed.
    Fixed memory leaks in archiver scanner
    
    - RunScanner was not being deleted properly when it started off as
    inactive (i.e., when it does not contain the probed PID), since it was
    not added to the heap.
    
    - Fixed other minor memory leaks and deletes
    Fixed in-block position handling in archiver
    
    - Eliminated unnecessary (and buggy) prevPos variable from reader thread
    - Fixed initialization of pos to start in middle of block in LogConsumer
    constructor
    - Other minor clean-ups and debug messages
    Fixed archive index building and loading
    
    - Changed building mechanism to support multiple runs being indexed
    while writer thread only writes out one at a time. The previous
    assumption that the last run entry on the index was always the one being
    (1) appended to by BlockAssembly and (2) written out by WriterThread was
    completely wrong, since both threads run independently without
    synchronization. New mechanism makes use of a "lastFinished" array
    index, which points to the last entry already serialized by the writer
    thread. All entries up to this one can be probed -- the remaining ones
    were created by BlockAssembly but not serialized yet. (Fixes #5)
    
    - Removed filter mechanism of RunInfo objects. The goal was to eliminate
    runs that are known to not contain a given PID from a probe. However, the
    strategy proved not very effective in practice, and no one was
    working on it. Without filter information, RunInfo is much leaner and
    easy to serialize/deserialize.
    
    - Fixed serialization and deserialization of the archive index,
    following the new design.
    Renamed log archiver shutdown method
    
    start_shutdown implies an asynchronous shutdown, but since we changed
    the shutdown mechanism to be synchronous, the method should be called
    simply "shutdown()"
    Several bug fixes on eager log archiver
    
    - Reader thread cannot run eagerly, because endLSN must be in sync with
    log archiver. This is because log consumer expects a skip log record on
    the endLSN position, and it must be artificially inserted by reader.
    - Reader activation fixed to use a single signal instead of a loop.
    Thanks to proper lock acquisition, we guarantee that the signal is
    always caught.
    - Reader correctly fetches partial blocks across activation cycles,
    i.e., if then endLSN is in the middle of a block, following read will
    fetch data into the rest of the block, so that scanner continues from
    the same offset where it left off.
    - LogArchiver keeps track of the endLSN of the last activation, to avoid
    being activated on a region which was already covered before. This is
    important for cases when the archiver runs faster than the log grows.
    - Shutdown of log archiver is synchronous now, i.e., it sends
    synchronous shutdown to all sub-components and joins on all threads.
    - Writer thread forked from the beginning rather than on demand.
    Eliminated writerForked flag and fixed shutdown.
    - Small fix on heap workspace deallocation (array delete was wrong)
    - Added log archiver shutdown to SM destructor.
    Flushing current archive run on volume failure
    
    When log archiver sees a restore_begin log record, it increments the
    current run number, forcing the early start of a new run and thus
    decreasing the delay until the archive becomes available during a media
    failure.
    Implemented non-instant restore and eager archiving
    
    - Added "instant" flag to restore manager. On-demand requests are only
    satisfied if the segment is restored AND the flag is true. This allows
    us to run experiments with traditional restore.
    
    - Eager archiving means that the reader thread and the sorter thread of
    the log archiver keep running indefinitely in a loop until shutdown. The
    lazy behavior (old one, current default) means that these threads must
    wait for an activation signal.
    Fixed memory leaks on log archive scanner
    Fixed some leaks and valgrind errors
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Applied changes from llesrch/archindex
    
    Changes to Log Archive Index:
    - New bit vector to filter page IDs within a run
    - Implemented deserialization
    - New tests for serialization
    - Improved log factory
    - Bugfixes
    Fixed restore manager
    
    - Fixed archive scan boundary cases (first PID or LSN, beyond end, etc.)
    - Fixed restore progress control to handle non-used segments (no log
    replay)
    - Restore ignoring/forbidding requests on first pages of the volume
    (i.e., alloc pages, volume descriptor, etc.)
    - Sending restore signal after each segment to waiting threads
    Duplicating multi-page logrecs on log archiver
    
    Multi-page log records are replayed once for each page involved. In the
    case of Restart and Single-page recovery, this is achieved by merges and
    bifurcations in the per-page log chain. For Restore, however, we must
    replicate the log record so that is replayed for each page involved.
    Small bugfix on archive index
    
    If queried LSN is equal to the first LSN of the first run, first run
    should be returned on findRun()
    Updated log archiver and restore for new PID
    
    Comparisons between lpid_t values are now valid.
    Fixed sort behavior of log archiver
    
    Apparently the method w_heap::AddElementDontHeapify was not working,
    since it was producing some log records out of order -- after using
    AddElement exclusively, order is correct.
    Reverted method fixable_page_h::setup_for_restore
    
    Previous implementation would initialize page with metadata from the log
    record, but this should not be required, because correct log replay must
    guarantee that the page state is compatible to what each log record
    expects. Method now only sets the page pointer (_pp) of the handle.
    Wrote the first pieces of restore code
    
    - Added a request cache to allow read requests to be fed directly after
      restore, thus eliminating the need for an extra read.
    - Implemented logic to check and wait for a segment to be restored.
    - Implemented basic restore loop with replay logic and request
      fulfilling (backup-less restore for now)
    - Implemented basic FIFO scheduler that restores in single-pass order if
      no requests are available
    
    (Still untested and incomplete)
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Fixed bugs on log archiver
    
    - Shutdown of consumer and block assembly should only occur after the
      archiver main loop has emptied the current heap (i.e., right before
      the run() method returns)
    - MergeHeapEntry does not need extra parameter for the PID -- it's
      contained in the given RunScanner
    - findEntry should not return an error if first entry on a run has PID
      greater than the one being queried
    - Added methods for restore interfacing: getDirectory() and
      getNextConsumedLSN()
    Fixed bug on log archiver
    
    For some reason, a fork call on the writer thread returns stOS because
    it is apparently already forked. I don't know why that is happening -- I
    guess the fork occurs implicitly somehow? Fixed for now by ignoring the
    return code of fork()
    Removed warnings from logarchiver.cpp
    Fixed bug in archive index binary search
    
    Entry past the last one in a run info was bein illegally accessed,
    resulting in undeterministic behavior (test sometimes passed, if the
    memory region past the end of the list happened to be valid).
    Fixed activate/shutdown behavior of LogArchiver
    
    To allow better control of log archiver execution, the activate method
    (if called with wait=true) now makes sure that archiver thread received
    the signal by using a 'listening' flag, which is set by
    waitForActivation(). Activation then only sets activate = true if
    listening is true. Thus, we can guarantee that return from an activate
    call actually kicked off the archiver thread.
    
    The other problem (at least for tests/experiments) is then how to wait
    for a certain LSN to be archived. This is fixed by monitoring the last
    LSN consumed and making sure that all consumed LSNs are archived before
    shutdown finishes. This is guaranteed because (1) selection empties the
    heap before the log archiver returns, and (2) writer thread consumes and
    writes out all pending blocks before exiting.
    Removed unused lastPID from BlockAssembly
    Fixed bugs in ArchiveIndex
    
    The whole probe logic was full of bugs. The binary search for entries
    within a run as well as the linear search for a single run were both
    wrong.
    Fixed RunScanner to deal with index blocks
    
    If an index is build during run generation, its data is stored at the
    end of the run file, in N blocks appended after the actual data blocks.
    This commit extends RunScanner to stop scanning when the index blocks
    are reached, by keeping track of the total number of data blocks. To
    that end, I implemented a simple method to read metadata from the last
    block of the file and, together with the file size, determine the number
    of data and index blocks.
    Fixed bugs on RunMerger
    
    - Fixed run boundaries so that end is exclusive and begin is inclusive
    - Fixed logic of advancing individual run scanners within the RunMerger heap
    Check for open block on BlockAssembly shutdown
    LogArchiver: optional index creation and list files
    
    - Implemented method to list files in the log archive.
    - Added boolean option to ArchiveDirectory constructor to make index
    building optional (useful for tests at least)
    Fixed compilation errors on prev commit (sorry!)
    Moved implementations from logarchiver.h to cpp
    
    The logarchiver.h header is getting very large, especially with all
    methods implemented inline. Moved some of them to the cpp file.
    Removed "returnRC" mechanism from log archiver
    
    The threads used in the log archiver make use of a "returnRC" flag to
    store any error codes encountered during execution. The idea was to
    detect errors on asynchronous threads without interrupting the execution
    of the main thread. However, the mechanism didn't make much sense, since
    we only checked for such errors when the thread exited, and we used the
    W_COERCE macro for that. This means that early detection of such errors
    was not being useful in any way. Therefore, I removed the returnRC
    mechanism and errors are thrown immediately using W_COERCE. Since our
    project is more experimental/research prototype, we don't have to be so
    worried about catching errors early on in the hope of fixing them.
    Implemented basic ArchiveScanner [untested]
    
    Implemented basic archive scanning functionality, with all related
    classes:
    - RunScanner is a basic scanner of log records of a single run
    - RunMerger manages a heap of RunScanner objects, also providing a
    log record iterator interface. This provides a single sorted stream from
    a collection of archive runs.
    - ArchiveScanner is the main entry point and the orchestrator of these
    two sub-components. It provides an open-next-close interface and takes
    care of (1) querying the archive index to know which runs and blocks to
    read, (2) constructing RunScanner objects and positioning them in the
    correct log record, and (3) adding these objects to the heap and
    executing heap operations upon each "next" invocation.
    
    These classes have not been tested yet. Individual tests for each
    component (index, run scanner, run merger, and archive scanner) will be
    implemented soon.
    Removed FactoryThread from LogArchiver
    Small bugfixes on log archiver
    
    - Fixed behavior of ArchiveIndex, which must know its startLSN at startup.
    - Fixed closing of current run on ArchiveDirectory
    - Fixed small bug on BlockAssembly (not using "dest" member properly)
    Fixed shutdown on LogArchiver
    
    Added mfence on shutdown method to make sure finished flag is
    propagated. Added "selfManaged" flag which, depending on how LogArchiver
    was constructed, deletes the sub-modules (dir, heap, consumer, assembly)
    as well during its desctruction.
    Fixed bug on ArchiverHeap
    
    Added new test case for heap (testHeapReal), which empties heap
    every time it gets full. In this case, filledFirst flag of ArchiverHeap
    must be set it the top() method leaves an empty heap.
    Fixed small bug on LogConsumer
    
    Position within the current consumer block was not being reset in the
    method nextBlock()
    Fixed minor bugs in log consumer
    Updated log archiver constructors
    
    Constructors now rely on sm_options to initialize their state.
    Additionally, LogArchiver can be constructed by passing instances of
    ArchiveDirectory, LogConsumer, ArchiverHeap, and BlockAssembly. This
    modularization will be useful for tests and experiments.
    Removed option to generate unsorted log archive
    
    The copy() method was used instead of replacement selection in the BTW
    paper to compare the overhead of partially-sorted with traditional log
    archiving. We probably won't be using it again, and it actually needs
    to be rewritten since the latest refactorngs, so I'm removing it for
    now.
    Removed dependency bet. ArchiverHeap and BlockAssembly
    
    Eliminated queueing mechanism on writer thread. Run boundaries now set
    by adding the last LSN of each block to the block header in the assembly
    process. When run file is closed, the writer thread then knows the run
    boundary by keeping track of the las LSN of the last written block.
    Small bugfix on log archiver
    Isolated file system functionality of log archiver into its own class
    Decoupled LogConsumer from LogArchiver (untested)
    Isolated heap functionality from LogArchiver
    Implemented simplistic log archive index (untested)
    Abstracted log archiving output into class BlockAssembly
    Removed defragmentation code from log archiver
    Copied log archiver files from old plog branch
    Basic infra for clustering and extent-to-store assigment
    
    - Restart still not working due to problems with logging the
    append_extent operation. I'll probably fix this by doing a little
    refactoring.
    Mover XctLogger's PagePtr template argument into new log_p method
    
    - XctLogger no longer a class template
    - Renamed log methods that take PagePtr argument into log_p (required to
    not mess up with template argument deduction)
    XctLogger methods now return LSN of inserted logrec
    
    - ... instead of rc_t
    Using template for page class in logging functions
    
    - code not linking properly yet -- still to be fixed
    Replaced log "stub" calls with generic Logger
    Trying to make smthread_t fully static (huge commit from hell)
    Updated & fixed some tests
    Added only_if_hit argument to buffer fix call
    
    - Using it for opportunistic adoption.
    Removed 'undo' parameter from B-tree methods
    Fixed some B-tree bugs
    
    - 1) Steal operations when splitting, growing, etc. must always use the
    "opaque" version of child pointers, otherwise a swizzled pointer will be
    implicitly unswizzled without setting the _swizzled flag on the child,
    leading to an inconsistent state.
    - 2) When moving records to a new foster child during split, first
    branch key was actually copied twice: once in pid0 and once in the first
    element slot. This results in a duplicated child pointer, which works ok
    (or rather, the error is masked) until we activate swizzling.
    - These bugfixes should finally fix swizzling and eviction. They cost me
    quite a few hours of hair-pulling frustration.
    Fixed eviction and swizzling
    
    - Fixed maintenance of parent CB pointer on the buffer hash table, so
    that it is kept consistent at all times. This means that eviction cannot
    get stuck due to "invalid parents" anymore.
    - Not really confident that everything works yet, but at least it seems
    like we can finnally run benchmarks on small buffer pools, with or
    without swizzling.
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Removed crash.{h,cpp} and usages of LOGTRACE and SSMTEST
    Removed old FUNC macro
    Fixed some assertion bugs
    
    - PageID 0 is actually a valid one, so cleaner should not assert that
    - sx_append_extent was switched to use sysevent instead, but the ssx
    object was still being created, leaving an open (chained) ssx in the xct
    state, which was causing a nasty bug when interting log records form the
    parent UX.
    Restart cleanup [part 3]
    
    - Cleaned up restart and log analysis methods
        - Cleaner code, less debugging, simpler methods
        - chkpt_t as member object populated by log analysis
    - Cleaned up fix methods
        - Stripped down _fix_nonswizzled and removed fix_direct
        - deleted all code related to SPR from fix methods
    - SPR now handled by vol_t
        - Method read_page_verify automatically invokes single-page recovery
        when reading a page if the checksum does not match or if the given
        EMLSN does not match the page LSN.
    - Concurrent REDO of restart relies solely on single-page recovery
        - Method redo_concurrent_pass simply fixes and unfixes each in-doubt
        page; recovery is implicit
    Removed support for multiple volumes [part 2 - big commit]
    
    - Removed type vid_t and all its usages
    - Typedef PageID replaces both lpid_t and shpid_t
    - Typedef StoreID replaces both stid_t and snum_t
    Removed support for multiple volumes [part 1 - big commit]
    
    - Removed old volume manager (vol_m) and adapted all usages to use a
    single vol_t
    Properly setting parent pointer on btree operations
    
    - Any operation that changes the parent of a note (adoption, split, and
    growth) must update the hashtable to reflect the changes. Otherwise, the
    eviction algorithm cannot find parents and therefore cannot evict.
    Fixed bug on btree split log record
    
    - Prev pointers were switched (prev2 pointing to previous update on
    page1 and vice-versa). Fixed constructor method and its invocaiton to
    produce the correct assignment.
    
    - Aldo fixed log archiver to correctly set previous pointer on
    duplicated multi-page logrec.
    Fixed bugs on B-tree split
    
    - Range deletion was not processing ghost records correctly
    - Strange bug with _ux_assure_fence_low_entry. Commented out for now
    since I don't really understand why this method is required.
    Fixed B-tree split by deleting body space
    
    B-tree items consist of a head, which is a fixed-length header stored in
    the head array from left to right, and a body, which can be
    variable-length (but multiple of sizeof(item_body)) and is stored right
    to left.
    
    The previous split operation only deleted entries from the head array,
    without properly deleting the associated bodies.
    Fixed bug on btree split log record
    
    In order for page LSNs to be updated correctly, the constructor stub in
    logdef.dat must have its first two parameters named exactly "page" and
    "page" (weird, old Shore stuff...)
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    New version of btree split with SSX
    
    Using an SSX to implement btree split in order to avoid undo of bulk
    delete on foster parent. For single-page recovery, chains of both pages
    involved should lead to the same log record. Whether to redo foster
    parent or child depends on the page id of the given fixable_page_h. For
    restore, we will simply duplicate multi-page log records so that both
    pages are restored independently.
    New implementation of B-tree split
    
    Existing B-tree split (three options implemented by Wey for minimal and
    full logging) were not working with restore because they either had
    dependencies to the buffer pool or between pages. We should strictly
    follow the phisiological loggin principle that pages can be restored
    independently, which is crucial for instant restore. Furthermore, full
    logging is a requirement of restore in general.
    
    See the comments on the new methods for more details.
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Added store number to page headers
    
    Since we will be removing store number from page IDs, we need an
    additional field to store it inside page headers, given that some
    operations require the store number of a page (e.g., locking and
    recovery)
    
    The size of the page header should not change because the 2 bytes used
    by the store number will also be removed from the page ID in a later
    commit.
    
    (This commit is part of a larger refactoring -- code not expected to
    work)
    Fixed bug on plog iterator
    Fixed usage of debug macros
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Removed old bf_m code
    Fixed an infinite loop bug, also update the 'known issues' list in Recovery.docx to track the I/O layer issues discovered by Caetano.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    removed unneeded function, init_as_empty_child, in favor of existing format_steal
    merge with bufferpool change
    System-transaction refactoring for page split, rebalance, merge, adopt, deadopt, and allocation
    updated comments for search_node
    fixed a couple of uses of search_node to better use new orthogonal interface
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    page_s -> generic_page
    Fixed issues 139-142 related to issue 112.
    The fix is by default to assume user wants the disk page identifier, which uniquely identifies a page (whether that lives in memory or disk). If user wants to use swizzled pointers (fast path) then she has to explicitly request an opaque pointer which can be either a memory frame id or a page id depending whether the page is swizzled or not. This solution requires less drastic changes and is less error prone.
    Delete the shore-kits directory (it is no longer needed) and add
    HP copyright notices in all files for the sm directory.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    fixed bug ZERO-112 (btree code mixes swizzled pointers with disk pointers) by always comparing disk page pointers. Previous fix was to always compare memory frames but that fix was racy.
    fixed bugs related to mixing pages identifiers and memory addresses (swizzled pointers to pages)
    Updated references to tickets to give ticket name and both jira and trac numbers.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Added Google-test 1.7 and google cpplint
    add blank testcase; supress unused variable messages
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Fixes so that we can do a complete out of tree build.  Also
      other minor improvements.
    
    {examples,experiments,src/**,tests}/CMakeLists.txt: auto-generated file include paths
       Generate files in the binary directory only, and only generate them once rather
       than N different custom commands.
    
    experiments/experiments.h: move log/data stuff to /dev/shm
    
    experiments/random_inserts/select_only.cpp: improve usage message
    
    src/sthread/srwlock.cpp: add { } to eliminate compiler warning
    Zero branch from subversion rev 11038
    Missing update from last commit
    CMake compiling less stuff when calling "make"
    
    Calling "make" (or, equivalently, "make all") would cause all
    alternative versions of the SM to be build as well (e.g., no_swizzling,
    plog, etc.). It would also compile all test variations (such as
    no_swizzling).
    
    I modified the cmake setup to eliminate alternative SM targets using
    the EXCLUDE_FROM_ALL property. Alternative test setups are also
    commented for now.
    Updated testutil.cmake to add a new X_ADD_COMPILEDEF_TESTCASE function that will compile and run a test with a specified COMPILE_DEFINITIONS property.
    Updated X_ADD_TESTCASE to call X_ADD_COMPILEDEF_TESTCASE for each argument beyond "the_libraries".
    Updated testutil.cmake and btree_test_env.h to specify an alternate configuration
    so that tests will be run twice, once with default_swizzling set to true
    and once set to false.
    Added comment to CMakelists.txt saying that this option exists.
    Updated definition of X_ADD_TESTCASE, per Alistair's suggestion.
    Alistair's suggestions from code review.
    Updated testutil.cmake to add a new X_ADD_SM_TESTCASE function that will compile and run a test both with and without a specified COMPILE_DEFINITIONS property.
    Zero branch from subversion rev 11038
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    Fixed compilation of tests
    Moved all non-sm test files into "common" directory
    refactoring w_rc_t
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    More RAW Lock Manager stuff. Still not used
    Fixed compilation of tests
    Remove deadcode
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    fixed warnings
    RAW-style lock manager
    More RAW Lock Manager stuff. Still not used
    Moved all non-sm test files into "common" directory
    More RAW Lock Manager stuff. Still not used
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    fixed warnings
    More RAW Lock Manager stuff. Still not used
    Moved latches to sm and fixed test compilation
    Cleaned up tests
    
    - Removed tests of deleted components and deprecated types
    Removed old tests and commands that used sthread IO
    Test cases: cleaned up and fixed compilation bugs
    Moved all non-sm test files into "common" directory
    Removed old util libraries from some CMake files
    refactoring w_rc_t
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Implement atomic_ops in terms of lintel::Atomic<>.
    This 99% removes atomoc_ops directory. A bit is still temporarily left as physical, but not logical, artifact).
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    * Add support for controlling location of log dir via a program option
      * Fix bug in mmap code that was resulting in unmapping pages that were not
        owned by the code, potentially unmapping thread code and stack pages leading
        to segmentation faults.
    
    CMakeLists.txt: find lintel
    
    experiments/CMakeLists.txt: include lintel, define experiment libraries variable
    
    experiments/*/CMakeLists.txt: link with standard set of experiment libraries
    
    experiments.h: add program option
    
    select_only.cpp: use program option
    
    dynarray.cpp: fix bug by not subtracting MM_PAGE_SIZE from align; if align == MM_PAGE_SIZE this
      results in additional alignment of 0, but kernel may mis-align by actual page size.  Also error
      out on mmap/munmap failures (thought this was the problem, it wasn't, but many callers aren't
      checking the return code)
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Fix build bug
    add blank testcase; supress unused variable messages
    Moved all non-sm test files into "common" directory
    OKVL terminology change and optimizations
    Eliminate signed/unsigned comparison warnings.
    renamed w_okvl to ovkl_mode
    Added testcases, code cleaning, and many more comments
    Addressed some of the comments
    removal of unused error codes; bug fix to capitalization of all error messages
    refactoring w_rc_t
    Removed regex package
    TPCC
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Copied AtomicCounter.hpp from Lintel and removed dependency
    Make build on ubuntu 13.10 work
    
    mostly 1) compiler is pickier, so cover for more silly cases
    and 2) linker is pickier, so more care in link order
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    Zero branch from subversion rev 11038
    Moved all non-sm test files into "common" directory
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Moved all non-sm test files into "common" directory
    Zero branch from subversion rev 11038
    Fixed restart tests
    Fixed crash test threads in btree_test_env
    Fixed compilation of tests
    Moved latch/mutex stuff out of sthread files
    Updated & fixed some tests
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    Test cases: cleaned up and fixed compilation bugs
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Updated btree_test_env and lock mgr tests
    Added chkpt_t test and fixed bugs found so far
    Updated btree_test_env for single-volume infrastructure
    Making tests use disk instead of memory
    New metadata management (stnode and alloc caches) [big commit]
    
    - Allocation is now based on extents of 32k pages, where the first page
    contains the bitmap for that extent. New extents are simply appended, so
    that DB expands dynamically without a fixed quota. This also means that
    restart and restore don't have to treat metadata pages differently,
    since allocation log records apply to the alloc_page of the
    corresponding extent.
    - Extents can be assigned to stores, so that pages of a store are
    clustered. For that end, stnode page was exteded so that it keeps track
    of the last extent allocated to each store. Store number 0 is reserved
    for extents which are not assigned to any store.
    - Both stnode and alloc caches now work in a decoupled way, i.e., they
    only manage internal data structures and generate log records on the
    corresponding page IDs. This means that the actual metadata page contents
    are not managed directly, and pages are not written directly, but
    updated by the decoupled cleaner.
    - Since decoupled checkpoint and cleaner were not merged in from Lucas'
    branch yet, the code is currently not working for shutdown and restart,
    i.e., it only works for newly loaded datasets.
    - Removed BackupManager and bf_fixed
    - Removed methods related to flushing buffer/log until a certain LSN
    - Cleaned up SM methods related to disk info, quota, etc.
    - Removed the "StoresToFree" and all related stuff from xct_t. This
    seems to be legacy code. Current stnode cache does not support deletion
    of stores anyway.
    - Removed all stuff related to store_operation. Any operation related to
    stores should be its own system transaction in stnode_cache_t.
    - Removed volume header since metadata is covered by the first (alloc)
    page of each extent and the stnode page with PID 1.
    - Enforcing only one mounted volume at a time with an assertion. In the
    near furute, we'll eliminate support for multiple logical volumes.
    Bug fixes on restart tests.
    Added test for volume manager operations
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Removed raw device stuff and unused vhdr fields
    
    The distinction between raw and non-raw volumes does not make much
    sense, because nothing important was really done based on it. Also see
    comments.
    
    Removed fields quota and page_sz from volume header, since these are
    redundant.
    Some whitespace changes
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Replaced l0 with lvid_t::null
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Removed device manager and its uses
    
    Shore/Zero always had the concept of a device, which was supposed to be
    composed of multiple volumes -- in the same way a linux device is
    composed of multiple partitions. However, this destinction was never
    really realized, and a device was always assumed to contain just one
    volume.
    
    In a refactoring which was supposed to be done many years ago, I removed
    the device manager and all its uses, delegating to volume operations
    where applicable. It seems like things will keep working as expected,
    but more tests will be required to see if anything is broken by this
    change.
    Added archive dir option to btree_test_env
    Updated plog tests
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Test classes for atomic commit protocol
    Removed old bf_m code
    Create global 'itoa' function and eliminate the local copies.
    Check in the partically implemented performance test code, so I can check in the rest of the M3 code.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    switch to the new log buffer
    Moved a test helper function 'delete_records' to btree_test_env.h so it can be used by all test suites.
    Added logic in log analysis to handle possible save_point and partial rollback in in-flight transactions.
    Accepted test code merge from master and added some comments.
    Fixed issue in test code for multi-thread access.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Added Test calls to MultiIndexConcTrans, most of them still disabled, need to look into accept/reject logic for m2
    Finished first multi-index test case (failing), disabled a newly failing test case.
    Added populate_records to test environment, removed definitions in test suites, amended all calls.
    Fixed the 'checkpoint' related bug for M2, also clean up some debug outputs.
    Copied the last failing test to test_restart_bugs.cpp.
    Fixed an bug in the test environment that was causing a segfault
    Amended test calls in test_restart and test_restart_bugs to use new options parameter, removed the interface with the old parameters from the test environment
    Small fixes
    Cleaned up, added a new test case
    Added test_restart_options as container for restart options
    Fixed test cases.
    Added access to recovery mode and shutdown mode in btree_test_env, modified and enabled some test cases
    Moved thread handling from test_restart_bugs to the test environment (btree_test_env) so every test suite can use it. Moved a passing test from test_restart_bugs to test_restart.
    More bug fixes for Instant Restart milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    RAW-style lock manager
    New testcase for SPR and bug fixes
    more testcases, backup folder option, bug fix
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    Removed regex package
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    pulled out btree_page_h class
    un-inlining functions in page_bf_inline.h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Remove unused files and patch for tests
    
    bf.cpp, bf_core.cpp, bf_htab.cpp, bf_htab_test.cpp, and bf_prefetch.cpp
    all seem to be unused; so I'm removing them all.
    
    btree_test_env.* puts some of the tests in your build directory, which
    may be on NFS; this makes some tests slow.  I changed it to allways
    use /dev/shm/$USER/btree_test_env/; this speeds tests on Debian 33% and
    immeasuribly so on CentOS
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    LogFactory tests.
    Test cases: cleaned up and fixed compilation bugs
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    new_search->search, replace search_leaf with search
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed some tests
    Updated & fixed some tests
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Test cases: cleaned up and fixed compilation bugs
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Moved EvictionContext into bf_tree_evict.cpp
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    New testcase for SPR and bug fixes
    hierarchical eviction in bufferpool
    forgot to add
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    Fixed test cases.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fixed tests to comply with new max_entry_size accounting
    Fix for coding convertion style:
    1. Position of '{'
    2. local variable name
    Eliminate duplicate code into a shared function in test_restart.cpp
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    Picking up more changes from the merge with the Hideaki 2012 branch.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Updated & fixed some tests
    Test cases: cleaned up and fixed compilation bugs
    Fixing some bugs related to log archiver.
    1. In pushIntoHeap(), if the push fails, it would verify if the heap is empty after selection(). This check should be made before the call to selection()
    2. In emptyHeapAndCheck(), it would only compare log records based on the shpid. A log record t_format_a_page would have lpid 0.0 and would be considered to be the same as another log record with lpid 1.0, for example.
    Assorted small fixes
    
    - Converted an ERROUT into DBG
    - Updated log archiver tests for last commit
    - Fixed logrec null_pid() method
    Updated tests
    
    - Log archiver new API
    - Deleted buffer test for SwitchParent, which changed in the new
    eviction algorithm
    Renamed log archiver shutdown method
    
    start_shutdown implies an asynchronous shutdown, but since we changed
    the shutdown mechanism to be synchronous, the method should be called
    simply "shutdown()"
    Applied changes from llesrch/archindex
    
    Changes to Log Archive Index:
    - New bit vector to filter page IDs within a run
    - Implemented deserialization
    - New tests for serialization
    - Improved log factory
    - Bugfixes
    Small update on log archiver test
    
    Lower sleep times to 1ms when waiting for archiver to finish
    Fixed log archiver tests
    
    - Adjusted for new log archived activation behavior
    - Removed code from inside assert function (not called in release build)
    Added simple test for ArchiveIndex
    
    Using a single run and a fake (LogFactory-generated) archive.
    Updated Log Archiver test with RunMerger test cases
    
    - One "sequential" test uses runs generated by LogFactory, which are
    strictly increasing in both PID and LSN order. Thus, all log records of
    run n are produced before all of n+1 during merge. This allows to catch
    many bugs, but is not realistic.
    - The "full" test populates a B-tree and generates an archive using the
    complete LogArchiver infrastructure. Then it consumes the merged input
    from all produced runs. This is a realistic test case.
    Implemented RunScanner test
    Updated log factory and log archiver test
    
    - Fixed API of log factory to use void*
    - Fixed bug in log factory stats (version constants declared but not
    defined)
    - Fixed minor bug in test_logarchiver (getRC() removed)
    - Added (still incomplete) RunScanner test using log factory
    Added test for full log archive pipeline
    
    Added a test that instantiates all log archiver sub-modules and
    archives a whole log directory. Just checking for errors now.
    Verifications to be added when archive scanner is implemented.
    Fixed bug on ArchiverHeap
    
    Added new test case for heap (testHeapReal), which empties heap
    every time it gets full. In this case, filledFirst flag of ArchiverHeap
    must be set it the top() method leaves an empty heap.
    Fixed small bug on LogConsumer
    
    Position within the current consumer block was not being reset in the
    method nextBlock()
    LogArchiver test suite w/ simple LogConsumer test
    Copied log archiver files from old plog branch
    Fixed some tests
    Fixed test_checksum and test_insert_many
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Test cases: cleaned up and fixed compilation bugs
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    pulled out btree_page_h class
    changes from Alistair review feedback
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Test cases: cleaned up and fixed compilation bugs
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Applied changes from llesrch/archindex
    
    Changes to Log Archive Index:
    - New bit vector to filter page IDs within a run
    - Implemented deserialization
    - New tests for serialization
    - Improved log factory
    - Bugfixes
    Identation and comments.
    Replaced tab with spaces in logfactory code
    Updated log factory and log archiver test
    
    - Fixed API of log factory to use void*
    - Fixed bug in log factory stats (version constants declared but not
    defined)
    - Fixed minor bug in test_logarchiver (getRC() removed)
    - Added (still incomplete) RunScanner test using log factory
    Zero logrec_t and versions.
    Change fake_logrec_t in LogFactory to reflect the current format of logrec_t in Zero.
    LogFactory now checks for compatibility between its version and log_storage versions.
    Stats now include version info as well.
    Stats version info is also checked by LogFactory constructor.
    Corrected some minor bugs (changes not staged in  previous commit).
    Fixed and updated LogFactory
    
    - max_page_id is incremented linearly instead of using a ratio growth.
    This is because (1) certain ratios cause a bug and the page ID never
    grows (i.e., 100 pages and growth 0.5%) and (2) a linear growth is more
    repredentative of real workloads.
    - Added "sorted" option to generate log records sorted by pageID (useful
    for testing log archive)
    - Updated CMake files to compile tests with logfactory as a library
    - Fixed compilation errors and warnings
    - Replaced some of the "uint_t" usages by plain "unsigned"
    Deleted old LogFactory and added new refactored LogFactory.
    Updated & fixed some tests
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Fixed B-tree verify
    
    - Using root PID instead of store ID to map pages into verification
    contexts.
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fix for max_entry_size accounting issue
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    Replaced all occurrences of volid+snum with stid_t
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    OKVL terminology change and optimizations
    dropping solaris support
    renamed w_okvl to ovkl_mode
    Addressed some of the comments
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Added an optional artificial delay after the log is flushed (default zero)
    fixed test_intent_lock so retries when gets a timeout
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Moved latches to sm and fixed test compilation
    Fixed compilation of tests
    Including <random> for gcc 6
    Updated application tools: kits, propstats, and stress_cleaner
    Updated stress_cleaner program
    
    - Allows reading page accesses from a trace file or generate them
    randomly
    - Optimized candidate handling
    Added stress test for page cleaner
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Test cases: cleaned up and fixed compilation bugs
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Updated test cases for page ID refactoring
    Removed old bf_m code
    Modified test code so it is easier to merge with changed code from master.
    New testcase for SPR and bug fixes
    more code comments
    SPR dumping feature, new testcase, and bug fix
    Moved latches to sm and fixed test compilation
    Fixed compilation of tests
    Remove deadcode
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Updated btree_test_env for single-volume infrastructure
    Removed lvid_t and made vid unique
    
    Instead of generating, storing, and handling lvid's, we now simply store
    the vid inside the volume header and make it unique across volume
    creations by maintaining a global highest vid.
    
    TODO: Support recovery of highest vid by placing it into checkpoints,
    logging volume creations, and processing them in log analysis.
    Added archive dir option to btree_test_env
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Test classes for atomic commit protocol
    Continue working on performance test program for Instant Restart, also a few bug fixes.
    Initial code for Instant Restart performance test, work-in-progress.
    Create global 'itoa' function and eliminate the local copies.
    Check in the partically implemented performance test code, so I can check in the rest of the M3 code.
    Fixed based on code review comments.
    Also when loading a page, if force load, acquire latch before copying over the last update lsn for the page.
    Fixed root page loading for backward scan.
    Several bug fixes and test code cleanup, mainly for M2.
    Temperary comment out log buffer GDBOUT, too noisy in debug build.
    Identified the test code has default 'lock off'.
    Added a few very primitive M3 test cases.
    Moved a test helper function 'delete_records' to btree_test_env.h so it can be used by all test suites.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Added Test calls to MultiIndexConcTrans, most of them still disabled, need to look into accept/reject logic for m2
    Finished first multi-index test case (failing), disabled a newly failing test case.
    Added populate_records to test environment, removed definitions in test suites, amended all calls.
    Amended test calls in test_restart and test_restart_bugs to use new options parameter, removed the interface with the old parameters from the test environment
    Build break fix
    Small fixes
    Cleaned up, added a new test case
    Added test_restart_options as container for restart options
    Fixed test cases.
    Added access to recovery mode and shutdown mode in btree_test_env, modified and enabled some test cases
    Added helper for deleting many records to cause page merge, added a few test cases
    Adjusted large data insertion for multi-thread, added 3 test cases.
    Moved thread handling from test_restart_bugs to the test environment (btree_test_env) so every test suite can use it. Moved a passing test from test_restart_bugs to test_restart.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    New testcase for SPR and bug fixes
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    Removed regex package
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    un-inlining functions in page_bf_inline.h
    Updated testutil.cmake to add a new X_ADD_COMPILEDEF_TESTCASE function that will compile and run a test with a specified COMPILE_DEFINITIONS property.
    Updated X_ADD_TESTCASE to call X_ADD_COMPILEDEF_TESTCASE for each argument beyond "the_libraries".
    Updated testutil.cmake and btree_test_env.h to specify an alternate configuration
    so that tests will be run twice, once with default_swizzling set to true
    and once set to false.
    Added comment to CMakelists.txt saying that this option exists.
    Added to btree_test_env.h :
     22 #ifdef ALTERNATIVE_FEATURES
     23 #define DEFAULT_SWIZZLING_OFF
     24 #endif //ALTERNATIVE_FEATURES
    
    and updated CMakeLists.txt to use ALTERNATIVE_FEATURES instead of DEFAULT_SWIZZLING_OFF.
    This has the added benefit that when add new features we won't need to edit CMakeLists.txt .
    Removed debug printf that I forgot to remove earlier.
    Updated definition of X_ADD_TESTCASE, per Alistair's suggestion.
    Updated testutil.cmake to add a new X_ADD_SM_TESTCASE function that will compile and run a test both with and without a specified COMPILE_DEFINITIONS property.
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Remove unused files and patch for tests
    
    bf.cpp, bf_core.cpp, bf_htab.cpp, bf_htab_test.cpp, and bf_prefetch.cpp
    all seem to be unused; so I'm removing them all.
    
    btree_test_env.* puts some of the tests in your build directory, which
    may be on NFS; this makes some tests slow.  I changed it to allways
    use /dev/shm/$USER/btree_test_env/; this speeds tests on Debian 33% and
    immeasuribly so on CentOS
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Moved a test helper function 'delete_records' to btree_test_env.h so it can be used by all test suites.
    Fixed a core dump bug, changed the test API btree_populate_records() to take a different input parameter, same change to delete_records().  Also fixed a bug in btree_populate_records() where the data portion was not NULL terminated.
    Added Test calls to MultiIndexConcTrans, most of them still disabled, need to look into accept/reject logic for m2
    Fixed and reenabled disabled test_restart test cases, some in test_concurrent_restart still disabled because of eWRONG_PAGE_LSNCHAIN error
    Some minor fixes.
    Added populate_records to test environment, removed definitions in test suites, amended all calls.
    Amended test calls in test_restart and test_restart_bugs to use new options parameter, removed the interface with the old parameters from the test environment
    Fixed test cases.
    Moved test cases reproducing bugs that are now fixed from test_restart_bugs to test_restart
    Modified test code so it is easier to merge with changed code from master.
    Cleaned up both restart test suites (Deleting redundant code, both shutdown scenarios for all, reformatting...)
    Fixed bug on 'failed to generate log record' for deletion compensation (insert).
    Updated some comments
    Added helper for deleting many records to cause page merge, added a few test cases
    Bug fix for Zero-183, it works in debug mode but still having issue in retail build, need more investigation.  Also Zero-183 has multiple issues, this check-in only addressed one of them.
    Adjusted large data insertion for multi-thread, added 3 test cases.
    Initial implementation of full logging for page balance operation, code is not tested at this point.
    Added some comments
    Added several test cases to test_restart
    Reenabled test
    Added first multi-threaded test case containing an in-flight transaction.
    Moved thread handling from test_restart_bugs to the test environment (btree_test_env) so every test suite can use it. Moved a passing test from test_restart_bugs to test_restart.
    Created a new test suite containing failing tests only
    Modified test case for uncommitted in-flight transaction. Added an additional insert to the in-flight transaction. Test is not passing because of a bug in the code to handle restart after simulated crash.
    Added internal delay test hook for REDO and UNDO phases.
    More work on test plan design doc
    2 more test cases.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    More bug fixes, all existing crahs and restart test cases (27 of them) are passing now.
    More bug fixes in Checkpoint-n-Recovery code, especially the _rec_lsn (initial dirty LSN).
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    commented out failing testcase
    Enabled restart testcases. ReviewBoard Request 69
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fixed tests to comply with new max_entry_size accounting
    Fix for coding convertion style:
    1. Position of '{'
    2. local variable name
    Eliminate duplicate code into a shared function in test_restart.cpp
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    Test cases: cleaned up and fixed compilation bugs
    Copied AtomicCounter.hpp from Lintel and removed dependency
    RAW-style lock manager
    Fixed test_restore
    Fixed compilation of tests
    Implemented multi-threaded restore
    
    - RestoreMgr now supports multiple cuncurrent restore threads, which
    coordinate using a new three-state bitmap and the scheduler.
    Assorted bugfixes to restore code
    Removed option sm_archive_block_size
    
    - Log archived currently only supports a fixed block size (for some
    reason I can't remember), so it does not make sense to offer such
    option. Removing it to avoid any future frustrations.
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Test cases: cleaned up and fixed compilation bugs
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Removing bf_uninstall flag from vol_t::dismount()
    The bf_fixed page of a volume is not recovered during restart. For now we keep this assumption and we must guarantee that the bf_fixed is flushed even during dirty_shutdown.
    Renamed log archiver shutdown method
    
    start_shutdown implies an asynchronous shutdown, but since we changed
    the shutdown mechanism to be synchronous, the method should be called
    simply "shutdown()"
    Added test for vol_t::take_backup method
    
    Test generates a backup and uses utility function verifyVolumesEqual to
    varify that logical content of backup and original DB file is the same.
    Incorporated backup access into restore
    
    Restore loop now loads segments from a backup file, if one is available,
    and extracts the minimum LSN in order to query the log archive.
    Added options to tweak restore behavior
    
    - trySinglePass: if true, restore scheduler will return page IDs in
    sequential order if there are no requests available, meaning that
    single-pass restore is performed together with on-demand restore.
    - reuseRequestBuffer: if true, read requests from the volume manager
    may reuse the restore buffer and copy requested page contents into the
    target frame in the buffer pool after restore. This avoids an additional
    read of a page which was just recently on main memory.
    
    These two behaviors used to be on by default
    Updated restore test with multi-page test
    Added simple single-page test for restore
    Added simple initial test for restore manager
    
    Very simple, full pipeline test for now -- just tries to perform
    a read on the first page of the volume
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed flag SM_LEVEL
    Removed SM level 1
    Removed old bf_m code
    RAW-style lock manager
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    dropping solaris support
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    Updated references to tickets to give ticket name and both jira and trac numbers.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Moved latches to sm and fixed test compilation
    Cleaned up tests
    
    - Removed tests of deleted components and deprecated types
    Got rid of old "plog" stuff
    Updated & fixed some tests
    Added stress_btree program
    
    - Performs random insertions, updates, and reads on a single B-tree
    using multiple threads
    Updated command infrastructure for stress_cleaner
    
    - Allow linking with new zapps_base library
    - Make setup of SM options a static method, so that other programs can
    use it -- no just commands
    Added stress test for page cleaner
    Test cases: cleaned up and fixed compilation bugs
    Added stress test for Aether (carray & log buffer)
    
    - Concurrent threads generate garbage log records with a random size
    according to a normal distribution and insert them into the log
    Some cleanup on partition_t and log_storage
    
    - Removed methods used by old logbuf_core
    - Removed LOG_DIRECT_IO stuff
    - Removed *some* dependency between partition_t and "owner" log_storage
    - Removed logbuf test cases
    Removed old util libraries from some CMake files
    Adding page_cleaner source files and test files.
    Adding checkpoint tests.
    Added simple initial test for restore manager
    
    Very simple, full pipeline test for now -- just tries to perform
    a read on the first page of the volume
    Added test for volume manager operations
    CMake compiling less stuff when calling "make"
    
    Calling "make" (or, equivalently, "make all") would cause all
    alternative versions of the SM to be build as well (e.g., no_swizzling,
    plog, etc.). It would also compile all test variations (such as
    no_swizzling).
    
    I modified the cmake setup to eliminate alternative SM targets using
    the EXCLUDE_FROM_ALL property. Alternative test setups are also
    commented for now.
    LogFactory tests.
    Corrected some minor bugs (changes not staged in  previous commit).
    Fixed and updated LogFactory
    
    - max_page_id is incremented linearly instead of using a ratio growth.
    This is because (1) certain ratios cause a bug and the page ID never
    grows (i.e., 100 pages and growth 0.5%) and (2) a linear growth is more
    repredentative of real workloads.
    - Added "sorted" option to generate log records sorted by pageID (useful
    for testing log archive)
    - Updated CMake files to compile tests with logfactory as a library
    - Fixed compilation errors and warnings
    - Replaced some of the "uint_t" usages by plain "unsigned"
    Added log archiver files to CMake
    Improved Singe Page Recovery REDO on page rebalance operation, start from page last write intead of page allocation.
    Implemented self-contaned log record for Single Page Recovery page rebalance REDO so no need to have recursive call.
    Many changes in test_restart_performance test case.
    Implemented separate crash shutdown and restart for performance testing purpose.
    Multiple bug fixes.
    Separated commit processing of plog_xct_t and xct_t
    First stub for a plog test suite
    Fix for the new logbuf backward scan, also modified test_logbuf_XXX to use the new log buf (instead of the traditional log buf)
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Fixed a potential race condition in page loading.
    Remove transaction from transaction table as soon as possile during backward log scan Log Analysis.
    Added execution-time-out to Instant Restart performance test code, and also some cleanup work.
    Bug fixes, also addressed the test break issues in test_logbuf and test_logbuf_scan.
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Continue working on performance test.
    Initial code for Instant Restart performance test, work-in-progress.
    Create global 'itoa' function and eliminate the local copies.
    Check in the partically implemented performance test code, so I can check in the rest of the M3 code.
    Fixed a on_demand restart (M3) bug which involves multiple pages during page loading (on_demand REDO) when the minimal logging page rebalance is used.
    This  check-in was not planned, it was forced in order to merge changes from master.
    Added a new test file for Restart performance test, no actual test case implementation with this check-in.
    switch to the new log buffer
    Added comments regarding failure on failure with on-demand restart.
    Split test_concurrent_restart.cpp into 2 test suites, one for single thread/index, and the new one for multi-index/threads.
    Change _loser_txn flag in the transaction object from a bool to enum, so it reflects normal txn, loser txn and loser txn in the middle of rolling back (on-demand UNDO).
    Disabled test suite test_concurrent_restart again
    Reenabled test_concurrent_restart, disabled failing test cases (bug fix coming soon from Wey)
    Disabled test suite test_concurrent_restart, was causing errors
    Created a new test suite containing failing tests only
    Several bug fixes for 'Instant Restart' milestone 2.
    Updated test plan design document.
    Working towards making 'Instart Restart' milestone 2 working, work-in-progress.
    Modified test driver to accept recovery mode option.
    Added a new test suite 'test_concurrent_restart' which has one test case currently, more will come later.
    A few minor changes in 'Instant Restart' code.
    Minor updates in the 'Instant Restart' milestone 2 design document based on the actual code implementation.
    Updated design documents, a few bug fixes, also enabled test_restart test suite
    Temporary disable test_restart, not done testing yet.
    merged okvl branch
    Many bug fixes for 'Checkpoint-n-Recovery' milestone 1 task, also updated the design document to reflect some of the design changes.
    RAW-style lock manager
    New testcase for SPR and bug fixes
    removed latch branch specific review board configuration, disabled
    fix_with_Q test as it should not be passing yet
    more testcases, backup folder option, bug fix
    testcases for backup manager
    Implemented checkpoint operation based on 'Recovery' milestone 1 design document.
    SPR dumping feature, new testcase, and bug fix
    new storage manager test case, test_fix_with_Q
    at moment, contains absolutely no subtests
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    Added a new test suite 'test_restart' to test various basic restart scenarios.
    A simple bug fix in checkpoint.cpp to abort checkpoint if in the middle of shutting down.
    disabled test_crash test case, set repository back to tested
    Updated testutil.cmake to add a new X_ADD_COMPILEDEF_TESTCASE function that will compile and run a test with a specified COMPILE_DEFINITIONS property.
    Updated X_ADD_TESTCASE to call X_ADD_COMPILEDEF_TESTCASE for each argument beyond "the_libraries".
    Updated testutil.cmake and btree_test_env.h to specify an alternate configuration
    so that tests will be run twice, once with default_swizzling set to true
    and once set to false.
    Added comment to CMakelists.txt saying that this option exists.
    Added to btree_test_env.h :
     22 #ifdef ALTERNATIVE_FEATURES
     23 #define DEFAULT_SWIZZLING_OFF
     24 #endif //ALTERNATIVE_FEATURES
    
    and updated CMakeLists.txt to use ALTERNATIVE_FEATURES instead of DEFAULT_SWIZZLING_OFF.
    This has the added benefit that when add new features we won't need to edit CMakeLists.txt .
    Updated definition of X_ADD_TESTCASE, per Alistair's suggestion.
    Alistair's suggestions from code review.
    Updated testutil.cmake to add a new X_ADD_SM_TESTCASE function that will compile and run a test both with and without a specified COMPILE_DEFINITIONS property.
    Fixed a logic error in btree_p::compare_with_fence_high (const char* key, size_t key_len) that struck when the search key exactly matched the page prefix.
    Add test_btree_durability
    Add (commented out) failing test_btree_insert_100K.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Implement atomic_ops in terms of lintel::Atomic<>.
    This 99% removes atomoc_ops directory. A bit is still temporarily left as physical, but not logical, artifact).
    Reenable test_intent_lock as it passes now
    made test_elr less sensitive to system slowness
    Comment out test that breaks on debian; yes it is evil, but it is blocking other things.
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    Fixed bugs in LogFactory
    
    - First LSN generated should be 1.0 (if partition (i.e., lsn.hi()) is 0,
      the LSN is treated as invalid.
    - Fixed enforcement of version numbers, which should throw an error
      instead of just printing a debug meddage.
    Updated log factory and log archiver test
    
    - Fixed API of log factory to use void*
    - Fixed bug in log factory stats (version constants declared but not
    defined)
    - Fixed minor bug in test_logarchiver (getRC() removed)
    - Added (still incomplete) RunScanner test using log factory
    1. Corrected some minor bugs.
    2. Moved Stats class out of LogFactory.
    3. Stats class now has a default behavior.
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    pulled out btree_page_h class
    st_bad -> st_unallocated
    removed some dead fix code
    removed/changed incorrect/unneeded references to generic_page_h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Refactoring of decoupled page cleaner
    
    - renamed page_cleaner to page_cleaner_decoupled
    - page_cleaner_decoupled now inherits from page_cleaner_base
    - removed master/slave architecture from page_cleaner_decoupled
    - removed set_cleaner() from bf_tree
    Updated btree_test_env for single-volume infrastructure
    Changes in page cleaner test
    Major changes on the decoupled cleaner code
    This commit contains major changes in the logic of the decoupled cleaner code and the integration with the buffer code.
    It also contains the logic for getting cleaner options from zapps.
    Adding logic for page_cleaner test
    Adding page_cleaner source files and test files.
    Moved latches to sm and fixed test compilation
    Fixed compilation of tests
    Including <random> for gcc 6
    Added stress_btree program
    
    - Performs random insertions, updates, and reads on a single B-tree
    using multiple threads
    Updated & fixed some tests
    Test cases: cleaned up and fixed compilation bugs
    Brought back allocation log records for correct restore
    
    Page allocations now log into page id 0, how it was done before. This
    allows the allocation cached to be restored correctly prior to opening
    the system for new transactions.
    
    Consecutive allocation was disabled since it was never used.
    Cleanup and reorganization of volume mgr methods
    
    - Removed redo_* methods of page allocation in vol_t
    - Removed dismount_all()
    - Added chkpt_serial_m critical section object (used at first but then
    not anymore)
    - Miscellaneous reorganizations
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Some whitespace changes
    Unified methods to create and mount volumes
    
    Since there is no distinction between device and volume anymore, it does
    not make sense to have format_dev and create_vol methods. This commit
    eliminates all redundant methods, leaving only create_vol and mount_vol.
    Updated test cases for page ID refactoring
    Removed device manager and its uses
    
    Shore/Zero always had the concept of a device, which was supposed to be
    composed of multiple volumes -- in the same way a linux device is
    composed of multiple partitions. However, this destinction was never
    really realized, and a device was always assumed to contain just one
    volume.
    
    In a refactoring which was supposed to be done many years ago, I removed
    the device manager and all its uses, delegating to volume operations
    where applicable. It seems like things will keep working as expected,
    but more tests will be required to see if anything is broken by this
    change.
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    removed/changed incorrect/unneeded references to generic_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fix for max_entry_size accounting issue
    fixed calculation of max_entry_size (original calculation forgot to take
    fence keys into account)
    
    resulting value is noticeably smaller and existing tests that assume you can
    use a value of size <page size>/5 no longer meet the API requirement.
    Fixed tests to use <page size>/6 or other appropriate value.
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Updated & fixed some tests
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Test cases: cleaned up and fixed compilation bugs
    Fixing bug in vol_t::read_many_pages() and making read/write calls consistent
    The bug was due to parameter passing for pread() inside read_many_pages().
    read_page(), read_many_pages(), write_page(), write_many_pages() now all receive as parameter a pointer to a page buffer, not a reference.
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Removed old bf_m code
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    introduced use of child slot indirection layer
    still have a few level()'s to remove/deal with
    removed no longer in use constants
    removed/changed incorrect/unneeded references to generic_page_h
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Zero branch from subversion rev 11038
    Fixed some tests
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    Test cases: cleaned up and fixed compilation bugs
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Moved EvictionContext into bf_tree_evict.cpp
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Updated test cases for page ID refactoring
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    Modified test code so it is easier to merge with changed code from master.
    fixed warning in test_spr
    fixed return value warning in test_spr
    fixed bug in SPR test
    ctimne timestamp for backups and vols, test case not passing
    Fixed compile warning messages from test_backup.cpp and test_spr.cpp.
    Minor updates in design documents, more will come later.
    Frequent check-in for the 'Instant Restart' milestone 2 task.  With this check-in, the initial coding is completed, but no test coverage at all.
    
    The code is passing all existing test suites, including test_crash and test_restart running in M1 code path (traditional restart with serial execution).
    Addressed Mark's comments
    more checks in test_spr
    complex testcases for SPR and bug fixes
    New testcase for SPR and bug fixes
    Added a bunch of assertions to log archiver code
    
    - Also wrote new mem_mgmt test
    Updated tests after log manager refactoring
    Copied log archiver files from old plog branch
    Fixed some tests
    Fixed test_checkpoint
    Fixed compilation of tests
    Updated & fixed some tests
    Fixed behavior of page_write log records & checkpoints
    
    - Page writes must be logged with an LSN earlier than what was on the
    pages when the dirty page was copied to the cleaner buffer; otherwise,
    an update which happened after the page was flushed might go unnoticed
    by log analysis, incorrectly marking a drity page as clean.
    Added chkpt_t test and fixed bugs found so far
    Updated btree_test_env for single-volume infrastructure
    Starting to write test case for checkpoint backup table
    Cleaning test_checkpoint.cpp
    Removing headers and comments.
    Modified bf_table test a little bit.
    Added some code to checkpoint tests.
    Adding checkpoint tests.
    Modified bf_table test a little bit.
    Added some code to checkpoint tests.
    Adding checkpoint tests.
    Fixed compilation of tests
    Updated btree_test_env and lock mgr tests
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed flag SM_LEVEL
    Removed SM level 1
    Removed old bf_m code
    merged okvl branch
    RAW-style lock manager
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    dropping solaris support
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    Updated references to tickets to give ticket name and both jira and trac numbers.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Fixed test_btree_insert_100K
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    RAW-style lock manager
    refactoring w_rc_t
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    Add (commented out) failing test_btree_insert_100K.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    dropping solaris support
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Fixed some tests
    Test cases: cleaned up and fixed compilation bugs
    Applied changes from llesrch/archindex
    
    Changes to Log Archive Index:
    - New bit vector to filter page IDs within a run
    - Implemented deserialization
    - New tests for serialization
    - Improved log factory
    - Bugfixes
    Fixed bugs in LogFactory
    
    - First LSN generated should be 1.0 (if partition (i.e., lsn.hi()) is 0,
      the LSN is treated as invalid.
    - Fixed enforcement of version numbers, which should throw an error
      instead of just printing a debug meddage.
    Replaced tab with spaces in logfactory code
    Updated log factory and log archiver test
    
    - Fixed API of log factory to use void*
    - Fixed bug in log factory stats (version constants declared but not
    defined)
    - Fixed minor bug in test_logarchiver (getRC() removed)
    - Added (still incomplete) RunScanner test using log factory
    Zero logrec_t and versions.
    Change fake_logrec_t in LogFactory to reflect the current format of logrec_t in Zero.
    LogFactory now checks for compatibility between its version and log_storage versions.
    Stats now include version info as well.
    Stats version info is also checked by LogFactory constructor.
    Corrected some minor bugs (changes not staged in  previous commit).
    Fixed and updated LogFactory
    
    - max_page_id is incremented linearly instead of using a ratio growth.
    This is because (1) certain ratios cause a bug and the page ID never
    grows (i.e., 100 pages and growth 0.5%) and (2) a linear growth is more
    repredentative of real workloads.
    - Added "sorted" option to generate log records sorted by pageID (useful
    for testing log archive)
    - Updated CMake files to compile tests with logfactory as a library
    - Fixed compilation errors and warnings
    - Replaced some of the "uint_t" usages by plain "unsigned"
    Deleted old LogFactory and added new refactored LogFactory.
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Zero logrec_t and versions.
    Change fake_logrec_t in LogFactory to reflect the current format of logrec_t in Zero.
    LogFactory now checks for compatibility between its version and log_storage versions.
    Stats now include version info as well.
    Stats version info is also checked by LogFactory constructor.
    1. Corrected some minor bugs.
    2. Moved Stats class out of LogFactory.
    3. Stats class now has a default behavior.
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    Copied log archiver files from old plog branch
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Updated btree_test_env and lock mgr tests
    added testcase
    RAW-style lock manager
    Updated btree_test_env and lock mgr tests
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Updated & fixed some tests
    Bringing back swizzling [part 2]
    
    - Some adjustments required
    - Swizzled pages are not always pinned; eviction just checks _swizzled
    flag additionally to pin count
    - Fixed parent adjustment in btree growth and split
    - Also not enforcing that the parent of a swizzled page must be
    swizzled. This has to be done to support switch_parent when performing a
    split, because the new foster child is not swizzled when first created.
    - Fixed btree_test_env and test_bf_tree
    - Eviction not working in combination with swizzling; still have to
    figure out how to perform unswizzling before eviction
    Cleaner refactoring I: modernized thread management & interface
    
    - Updated bf_tree_cleaner to use modern C++11 techniques to control
    thread execution.
    - New mechanisms for waking up claner thread and waiting for a cleaner
    round to complete.
    - Simplified cleaner interface in page_cleaner_base
    bf_tree_cb refactoring: removed dirty flag and added page and clean LSNs
    
    - PageLSN is now managed as a field in the control block -- transactions
    do not touch the page LSN inside the actual page image anymore.
    - Dirty flag was removed and CB field clean_lsn was added.  The field is
    set by the page cleaner without acquiring the page latch. Being a dirty
    page now simply means clean_lsn < page_lsn. This makes the cleaner and
    checkpoints much simpler.
    - Removed all the redundant code that used to set a page as dirty and
    update its LSN. This stuff is now centralized in a few key places.
    - I hope managing page_lsn in the control block will allow future
    optimizations and features like deferred updates.
    Test cases: cleaned up and fixed compilation bugs
    Replaced hierarchy log_m->log_common->log_core with just log_core
    
    - Class hierarchy was completely unnecessary, since there's just one log
    manager implementation. It was introduced back when we had logbuf_core,
    but now it's not needed anymore. This makes the code much simpler.
    Updated tests
    
    - Log archiver new API
    - Deleted buffer test for SwitchParent, which changed in the new
    eviction algorithm
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Updated test cases for page ID refactoring
    Made vid_t a simple typedef and deleted volid_t
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    removed unused include
    RAW-style lock manager
    moved child_emlsn code to handle class
    hierarchical eviction in bufferpool
    [Bufferpool] Fixed shady testcase code that doesn't create pages correctly
    merge with bufferpool change
    Accidentally mixed experimental code into test_bf_tree.cpp. removed
    [Shore Remnant] Another Solaris-specific code removed
    fixing pages outside of the buffer pool is now done via a member like
    every other fix rather than a special constructor.
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    fix spelling mistake
    cleaning up interface needed for swizzling
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    more interface cleanup
    removed use of old interface (e.g., slot_addr)
    btree_page[_header] no longer all public
    beginning to turn slots into items
    pulled out btree_page_h class
    replaced sinome used of casting
    move last of buffer manager's direct dependence on btree_page_h
    removed/changed incorrect/unneeded references to generic_page_h
    Make sure everything compiles in debug mode.
    move B-tree specific headers (as marked) from generic page header to
    btree_page
    btree_page_h now checks page has correct tag a via assertion
    bug fix to one of the tests that did not set the tag correctly
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    page_s -> generic_page
    introduced btree_page
    no code depends on the data field of page_s anymore
    Addressed issues raised in review request 10:
    -added comment explaining why we have the new layout
    -fixed the blockcnt + 1
    -made maximum value of refcount a parameter
    did a global search and replace for blink to foster. this was jira ZERO-127. did debpbuild -t before and after with no issues. Also had to rename experiments/verify/blink_len.cpp to experiments/verify/foster_len.cpp
    Picking up more changes from the merge with the Hideaki 2012 branch.
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Fixed compilation of tests
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    dropping solaris support
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Reenable test_intent_lock as it passes now
    made test_elr less sensitive to system slowness
    pretty much finished implementation of controlled lock violation except
    for one issue with the handling of abort.
    
    Modified test_elr to run the analogous tests with controlled lock
    violation mode.  Sharpened the tests to work somewhat better and fixed a
    bug where the tests assumed different tuples in the same page cause lock
    conflict.
    Zero branch from subversion rev 11038
    Fixed test_checksum and test_insert_many
    Test cases: cleaned up and fixed compilation bugs
    Removed old bf_m code
    RAW-style lock manager
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    refactoring w_rc_t
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Fixed compilation of tests
    Including <random> for gcc 6
    Updated stress_carray with boost prog opts and commit parameter
    
    - All statically-coded parameters are now passed with boost program
    options.
    - New 'commit' parameter allows us to simulate a transaction commit by
    flushing the log every N log records on each thread.
    Added stress test for Aether (carray & log buffer)
    
    - Concurrent threads generate garbage log records with a random size
    according to a normal distribution and insert them into the log
    Fixed compilation of tests
    Removed logdef generation script
    
    - All required declarations and definitions now included directly in the
    code. Further refactoring will make it cleaner.
    Test cases: cleaned up and fixed compilation bugs
    Removed old & unused "pmap" stuff
    Removed SM level 0 (partially)
    
    Class smlevel_0 still exists, but the header sm_int_0.h was removed. All
    files can now simply include sm_base.h
    Removed SM level 1
    Removed SM level 2
    Some whitespace changes
    New volume manager (huge refactoring)
    
    A large fraction of the old io_m was actually methods that simply
    delegated to a given volume. In this new architecture, a volume manager
    is used to manage all mounted volumes and retrieve the vol_t objects
    using either the volume ID or the mounted filesystem path. Besides this
    basic change, many other parts of the code were simplified.
    
    - Page allocation is no longer an SSX, which made no sense since it was
    ignored by recovery -- allocation was replayed by the first formatting
    log record on the page. Furthermore, a page which was allocated
    successfully but never used due to abort of the parent user transaction
    would be left in a "dead" state.
    
    - Parts of the restart code, which I don't think are required with the
    new architecture, were commented out. Further investigation will follow.
    
    - Remove many unused methods and arguments.
    
    NOTE: still have to implement concurrency control of volume operations,
    address issues of logging recovery, and write tests
    Replaced all occurrences of volid+snum with stid_t
    Removed old bf_m code
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    removed btree_page_h::nitems as it should never be used
    removed some unused code
    delete_slot -> delete_item
    removed unnecessary includes of btree_page_h.h
    pulled out btree_page_h class
    removed/changed incorrect/unneeded references to generic_page_h
    renamed:    btree_p.cpp -> btree_page.cpp
    renamed:    btree_p.h -> btree_page.h
    btree_p -> btree_page_h
    renamed:    page.cpp -> generic_page_h.cpp
    renamed:    page.h -> generic_page_h.h
            renamed:    src/sm/page_s.h -> src/sm/generic_page.h
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    renamed:    tests/sm/test_btree_p.cpp -> tests/sm/test_btree_page_h.cpp
    still fails tests 39, 41, 44, 45, 48, 52, but I want to rebase this branch from master
    Zero branch from subversion rev 11038
    Zero branch from subversion rev 11038
    fixed typos due to copy-paste in FindNuma.cmake
    fixed cmake to build things that depende on libnuma only when numa.h exists
    Some distributions put Berkeley DB into a different directory
    Make Zero compilable on Fedora 19.
    This checkin adds a CMake module to look for BerkeleyDB that might be in
    different folders depending on Linux distro.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    use tcmalloc if exists
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Added Google-test 1.7 and google cpplint
    Zero branch from subversion rev 11038
    Zero branch from subversion rev 11038
    Removing #undef USE_SSMTEST
    
    It was not being used anywhere else in the code
    Removing #define KEEP_LOG_PARTITIONS
    
    It was not being used anywhere else
    Removing #define USE_TLS_ALLOCATOR
    
    This was being defined by default anyway. No documentation, be the alternative
    to the TLC allocator was called "naive allocator", so it is probably safe to
    discard it.
    Removing #define BP_ALTERNATE_CB_LATCH
    
    Alternate control blocks and latches in the bufferpool is now the one and only
    behavior supported by Zero. We are not supporting older layout anymore.
    Moving #defines to proper file
    
    Defining variable in the source files might generate unpredictable bugs if
    dependency between compilation units change.
    
    For example, #define BP_ALTERNATE_CB_LATCH was done in bf_tree.h, but used
    also in bf_tree_cb.h. If someone else included bf_tree_cb.h without #define,
    weird behaviors would happen.
    Added timed log records and stubs for sysevent
    
    - Helper class sysevent_timer created to generate timestamps as the
    number of milliseconds since an epoch (Jan 1, 2015)
    
    - TIMED_LOG_RECORDS added as configuration flag. Log records for which a
    timestamp is desired must then observe this flag. Currently being used
    by restore log records.
    
    - Basic stubs created for log record of type sysevent. At first, only
    tick log record will be implemented as a sysevent.
    Added flag KEEP_LOG_PARTITIONS
    Zero branch from subversion rev 11038
    Changes from 'Instant Restart' performance work.
    Added some generic fixes from Ryan Johnson, both bug fixes and changes in make files.
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
    Enabled parent cb pointer on buffer
    
    - Control blocks used to hold a pointer to the parent when swizzling is
    activated. I turned this back on with the BP_MAINTAIN_PARENT_PTR flag.
    - My goal is to use the parent pointer on the new eviction algorithm.
    - Also commented out all stuff related to the swizzled_lru list.
    NUMA pinning for TPCC
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Removed old config flags
    Changed debug message mechanism to work with debug flags (like old Shore-MT)
    - delete src/atomic_ops directory
    - delete fc/atomic_templates.h
    - convert experiments/tpcb/Atomic64Counter.hpp from __sync to lintel atomics
    updates from Hideaki at graduation time
    Attempt to apply all of the work from Brown.
    Revert "Hideaki's updates as of Feb 22, 2012."
    
    This reverts commit 4eb28f5a0131b54ec737d9a3cd7825d119b8749d.
    
    Will re-apply the changes as a branch shortly.
    Hideaki's updates as of Feb 22, 2012.
    Zero branch from subversion rev 11038
